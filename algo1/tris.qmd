---
title: Algorithmes de tris
subtitle: S6 - Algorithmique (1)
lang: fr
tbl-cap-location: bottom
crossref: 
    eq-prefix: Éq.
    tbl-prefix: Tableau
    tbl-title: Tableau
format:
    html: default
    pdf: 
        geometry:
            - top=20mm
            - bottom=20mm
            - left=20mm
            - right=20mm
            - heightrounded
        include-in-header:
            - text:
                \usepackage{fancyhdr}
                \pagestyle{fancy}
                \usepackage{lastpage}
        include-before-body:
            - text:
                \lhead{Spécialité NSI} 
                \rhead{Première}
                \chead{} 
                \cfoot{}
                \lfoot{Lycée \'Emile Duclaux}
                \rfoot{Page \thepage/\pageref{LastPage}}
                \renewcommand{\headrulewidth}{0pt}
                \renewcommand{\footrulewidth}{0pt}
                \thispagestyle{fancy}
                \vspace{-2cm}
        biblio-title: Sources utilisées
        reference-location: document
        keep-tex: true
format-links: [pdf, tex]
---

Dans cette partie du cours, nous allons étudier deux algorithmes de tris : le tri par insertion et le tri par sélection.

Étant donné un tableau de nombres, l'objectif est d'écrire une fonction qui renvoie un tableau contenant les mêmes nombres mais dans l'ordre croissant.

## 1. Tri par insertion

### Le principe

::: {.callout-important}
## Principe de l'algorithme

En commençant par le deuxième élément du tableau :

  * On compare l'élément courant avec l'élément précédent.
  * Si l'élément courant est plus petit, on échange les deux éléments.
  * On continue à comparer et échanger l'élément courant avec les éléments précédents jusqu'à ce que l'élément courant soit plus grand que l'élément précédent.
:::

::: {.content-hidden when-format="html"}

Animation du tri par insertion :

:::

<script type="module" crossorigin src="assets_insertion/index.a606aa25.js"></script>
<link rel="stylesheet" href="assets_insertion/index.df145779.css">

<div id="insertion"></div>

### Programmation

```{python}
def tri_insertion(tableau: list) -> list:
    """Tri en place par insertion le tableau passé en paramètre."""
    for i in range(1, len(tableau)): # <1>
        j = i # <2>
        while j > 0 and tableau[j] < tableau[j-1]: # <3>
            tableau[j], tableau[j-1] = tableau[j-1], tableau[j] # <4>
            j -= 1 # <5>
    return tableau
```
1. On commence à l'indice 1 qui correspond au deuxième élément du tableau.
2. On stocke l'indice courant dans une variable `j` pour pouvoir le modifier.
3. Tant que l'indice courant est supérieur à 0 et que l'élément courant est plus petit que l'élément précédent, on échange les deux éléments.
4. On échange les deux éléments.
5. L'élément courant est maintenant l'élément précédent, on décrémente donc l'indice courant.

Test de l'algorithme :

```{python}
tri_insertion([5, 2, 4, 6, 1, 3])
```

### Preuve de terminaison

Montrons que l'algorithme termine.

D'une part, il est certain que la boucle `for`, boucle bornée par nature, se termine. D'autre part, la boucle `while` se termine aussi. La variable `j` peut être est un **variant de boucle**. À chaque itération, sa valeur de diminue de 1 : elle finit donc toujours par atteindre 0.

La terminaison de l'algorithme est donc prouvée.

### Preuve de correction

Montrons que l'algorithme trie bien le tableau.

Pour cela, considérons la propriété suivante : à chaque itération, le sous-tableau composé des `i` premiers éléments est trié. Montrons que cette propriété est un **invariant de boucle**.

* **Initialisation** : au début de l'algorithme, le sous-tableau composé uniquement du premier élément est trié.
* **Conservation** : supposons que le le sous-tableau composé des `i` premiers éléments est trié : $[e_0, e_1, \ldots, e_{i-1}]$ avec $e_0\leqslant e_1\leqslant \ldots \leqslant e_{i-1}$. L'algorithme considère alors l'élément $e_i$ et le compare avec les éléments précédents. Si $e_i$ est plus petit que $e_{i-1}$, on échange les deux éléments. On continue alors à comparer $e_i$ avec les éléments précédents jusqu'à ce que $e_i$ soit plus grand que l'élément précédent. Le sous-tableau composé des `i+1` premiers éléments est alors trié.
* **Termination** : à la fin de l'algorithme `i` a la valeur `n-1` ce qui correspond à l'indice du dernier élément du tableau. Le sous-tableau composé des `n` premiers éléments est donc trié. Or, `n` est le nombre d'éléments du tableau, donc le tableau entier est trié.

La correction de l'algorithme est donc prouvée.

### Complexité



## 2. Tri par sélection

<script type="module" crossorigin src="assets_selection/index.25db421e.js"></script>
<link rel="stylesheet" href="assets_selection/index.df145779.css">

<div id="selection"></div>
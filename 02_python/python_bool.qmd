---
title: Zoom sur les booléens
---

Pour l'instant nous avons vu deux grands types de données : les nombres (entier ou flottant) et les chaînes de caractères, il existe un troisième type tout aussi important que les deux premiers : les booléens. Un booléen est un type de données qui ne peut prendre que deux valeurs : vrai (`True`) ou faux (`False`). Une expression est soit `True`, soit `False`.

Les opérateurs de comparaison renvoient des booléens.

:::{.callout-important}
## Opérateurs de comparaison

* `a == 0` : teste si `a` est **égal** à 0 ;
* `a != 0` : teste si `a` est **différent** de 0 ;
* `a < 0` : teste si `a` est **strictement inférieur à** 0 ;
* `a > 0` : teste si `a` est **strictement supérieur à** 0 ;
* `a <= 0` : teste si `a` est **inférieur ou égal à** 0 ;
* `a >= 0` : teste si `a` est **supérieur ou égal à** 0.
:::

:::{.callout-warning}
## ATTENTION

Notez le double égal `==` qui permet de distinguer un test d'égalité d'une affectation (association d'une valeur à un nom (variable)). Le fait de confondre le "simple égal" et le "double égal" est une erreur classique qu'il faut éviter.
:::

Il est aussi possible de combiner plusieurs opérateurs booléens grâce aux opérateurs logiques `or` et `and`. On peut représenter le fonctionnement de ces opérateurs dans un tableau, appelé **table de vérité** :

Table de vérité pour `or`

| exp1 | exp2  | exp1  or  exp2 |
| --- | --- | --- |
| True  | True | True |
| True  | False | True |
| False  | True | True |
| False  | False | False |

Table de vérité pour `and`

| exp1 | exp2  | exp1  and  exp2 |
| --- | --- | --- |
| True  | True | True |
| True  | False | False |
| False  | True | False |
| False  | False | False |

On trouve aussi `not` comme opérateur logique de négation avec la table de vérité suivante :

| exp | not (exp) |
| --- | --- |
| True | False |
| False | True |

:::{.callout-warning}
## Attention !

On peut combiner des opérateurs arithmétiques,  de comparaison  et logiques pour créer des expressions booléennes complexes. Il faut prêter attention aux **règles de priorité**. Les parenthèses sont prioritaires sur tous les autres opérateurs donc on peut les utiliser quand on n'est pas certain des règles de priorité ou pour s'en affranchir.
:::

--- 

En programmation informatique, un booléen est un type de variable à deux états (généralement notés vrai et faux), destiné à représenter les valeurs de vérité de la logique et l'algèbre booléenne. Il est nommé ainsi d'après George Boole (1815-1864), fondateur dans le milieu du XIXe siècle de l'algèbre portant son nom.

Nous avons vu qu'en Python, les deux valeurs booléennes sont notées `True` et `False`.

De manière équivalente, on adopte souvent une notation numérique en associant 1 à `True` et 0 à `False`.

## 1. Opérateurs booléens de base

Dans le cours sur les bases de Python, nous avons déjà vu les opérateurs `or`, ``and`` et ``not``.

### Opérateur OU

::: {.callout-tip}
## Définition

Soit $a$ et $b$ deux expressions : 

$$a\textrm{ OU }b\textrm{ est vrai }\iff a\textrm{ est vrai ou }b\textrm{ est vrai}$$
:::

Table de vérité de l'opérateur OU : 

| $a$ | $b$  | $a$  OU  $b$ |
| :---: | :---: | :---: |
| 1  | 1 | 1 |
| 1  | 0 | 1 |
| 0  | 1 | 1 |
| 0  | 0 | 0 |

::: {.callout-warning}
## Remarque

En logique l'opérateur OU est **inclusif** : cela signifie que $a$ OU $b$ est vrai aussi lorsque $a$ est vrai et $b$ est vrai. Dans la langue courant, le mot _ou_ est le plus souvent **exclusif** : dans un menu, par exemple "fromage ou dessert" ne permet pas de prendre les deux.
:::

### Opérateur ET

::: {.callout-tip}
## Définition

Soit $a$ et $b$ deux expressions : 

$$a\textrm{ ET }b\textrm{ est vrai }\iff a\textrm{ est vrai et }b\textrm{ est vrai}$$
:::

Table de vérité de l'opérateur ET : 

| $a$ | $b$  | $a$  ET  $b$ |
| :---: | :---: | :---: |
| 1  | 1 | 1 |
| 1  | 0 | 0 |
| 0  | 1 | 0 |
| 0  | 0 | 0 |

### Opérateur NON

::: {.callout-tip}
## Définition

Soit $a$ une expression : 

$$(\textrm{NON }a)\textrm{ est vrai }\iff a\textrm{ est faux}$$
:::

Table de vérité de l'opérateur NON : 

| $a$ | NON $a$ |
| :---: | :---: |
| 1 | 0 |
| 0 | 1 |

## 2. Expressions booléennes

Les opérateurs de base peuvent être combinés pour formuler des expressions booléennes plus complexes. Pour éviter des problèmes d'interprétation, il est préférable d'utiliser des parenthèses pour marquer les priorités.

::: {.callout-caution}
## Exercice

Recopier et compléter la table de vérité ci-dessous :

| $a$ | $b$  | NON $a$ | NON $b$ | (NON $a$) ET (NON $b$)| NON((NON $a$) ET (NON $b$)) | $a$ OU $b$ |
| :---: | :---: | :---: | :---: |  :---: | :---: | :---: |
| 1  | 1 | | | | | |
| 1  | 0 | | | | | |
| 0  | 1 | | | | | |
| 0  | 0 | | | | | |

Que peut-on constater ?
:::

## 3. Le ou exclusif

Le OU logique étant inclusif, on définit un opérateur spécifique pour le ou exclusif, appelé opérateur XOR.

::: {.callout-tip}
## Définition

Soit $a$ et $b$ deux expressions : 

$$a\textrm{ XOR }b\textrm{ est vrai }\iff (a\textrm{ est vrai et }b\textrm{ est faux})\textrm{ ou }(a\textrm{ est faux et }b\textrm{ est vrai})$$
:::

Table de vérité de l'opérateur XOR : 

| $a$ | $b$  | $a$  XOR  $b$ |
| :---: | :---: | :---: |
| 1  | 1 | 0 |
| 1  | 0 | 1 |
| 0  | 1 | 1 |
| 0  | 0 | 0 |

En Python, l'opérateur `xor` n'existe pas. Le ou exclusif est noté ``^``.

````pycon
>>> True ^ False
True
````

## 4. L'addition binaire en mode booléen

Lorsque nous posons l'addition de deux entiers écrits en base 2, nous avons besoin d'additionner des groupes de 3 bits (un pour chaque nombre et un pour la retenue).

Voyons ce que donne l'addition de trois bits :

| $a$ | $b$ | $c$ | $a+b+c$ |
| :---: | :---: | :---: | :---: |
|0|0|0|0|
|1|0|0|1|
|0|1|0|1|
|0|0|1|1|
|1|1|0|10|
|1|0|1|10|
|0|1|1|10|
|1|1|1|11|

::: {.callout-caution}
## Exercice

En assimilant 0 à ``False`` et 1 à ``True`` écrire une fonction ``add_trois_bits(a, b, c)`` qui retourne la somme $a+b+c$ en utilisant uniquement les opérateurs ET, OU et NON. On retournera la somme sous la forme d'une chaîne de deux caractères (`"01"` par exemple).

````python
def add_3_bits(a, b, c) :
    unite = int(...)
    deuzaine = int(...)
    return str(deuzaine)+str(unite)

assert add_3_bits(0,0,0)=="00"
assert add_3_bits(1,0,0)=="01"
assert add_3_bits(0,1,0)=="01"
assert add_3_bits(0,0,1)=="01"
assert add_3_bits(1,1,0)=="10"
assert add_3_bits(1,0,1)=="10"
assert add_3_bits(0,1,1)=="10"
assert add_3_bits(1,1,1)=="11"
print("C'est parfait !")
````
:::
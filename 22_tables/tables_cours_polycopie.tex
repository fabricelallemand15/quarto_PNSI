\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage[a4paper,margin=2cm]{geometry}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{array}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{fontawesome5}
\usepackage[most]{tcolorbox}
\usepackage{listings}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0.5em}
\everymath{\displaystyle}

\hypersetup{colorlinks=true,linkcolor=blue!50!black,urlcolor=blue!50!black}

\lstset{
  basicstyle=\ttfamily\small,
  frame=single,
  breaklines=true,
  columns=fullflexible,
  keepspaces=true,
  showstringspaces=false
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Première NSI}
\fancyhead[R]{Chapitre 5.3 -- Traitements de données en tables (Cours)}
\fancyfoot[L]{Lycée Émile DUCLAUX}
\fancyfoot[R]{Page \thepage/\pageref{LastPage}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\setlength{\headheight}{14pt}

\fancypagestyle{plain}{
  \fancyhf{}
  \fancyhead[L]{Première NSI}
  \fancyhead[R]{Chapitre 5.3 -- Traitements de données en tables (Cours)}
  \fancyfoot[L]{Lycée Émile DUCLAUX}
  \fancyfoot[R]{Page \thepage/\pageref{LastPage}}
  \renewcommand{\headrulewidth}{0.4pt}
  \renewcommand{\footrulewidth}{0.4pt}
}

\newtcolorbox{importantbox}[1]{
  colback=red!3,
  colframe=red!60!black,
  title={\faExclamationTriangle\ \ #1},
  fonttitle=\bfseries
}

\newtcolorbox{tipbox}[1]{
  colback=green!3,
  colframe=green!45!black,
  title={\faLightbulb\ \ #1},
  fonttitle=\bfseries
}

\newtcolorbox{cautionbox}[1]{
  colback=yellow!5,
  colframe=yellow!45!black,
  title={\faExclamationCircle\ \ #1},
  fonttitle=\bfseries
}

\newtcolorbox{warningbox}[1]{
  colback=orange!6,
  colframe=orange!60!black,
  title={\faExclamationTriangle\ \ #1},
  fonttitle=\bfseries
}

\newcommand{\zone}[1][2.2cm]{\vspace{0.2em}\fbox{\parbox[c][#1][c]{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}{\ }}\vspace{0.3em}}

\begin{document}

\begin{center}
{\LARGE \textbf{5.3 -- Traitements de données en tables}}\\[0.4em]
\large Cours
\end{center}

\section*{1. Table de données et indexation}

\subsection*{1.1. Vocabulaire}

\begin{tipbox}{Définition}
Des données, numériques ou non, sont souvent représentées sous forme de tableaux, ou \textbf{tables}.

\textbf{Vocabulaire :}
\begin{itemize}
  \item Une \textbf{table}, représentée sous forme de tableau, est une collection d'éléments qui sont les lignes du tableau.
  \item Chaque élément de la \textbf{table}, ou ligne de sa représentation sous forme de tableau, s'appelle un \textbf{enregistrement}.
  \item Tous les \textbf{enregistrements} d'une même \textbf{table} sont des \textbf{p-uplets nommés} qui partagent les mêmes \textbf{descripteurs}, appelés aussi \textbf{attributs}. Dans une représentation de la \textbf{table} sous forme de tableau, chaque \textbf{attribut} correspond à une colonne. Chaque \textbf{attribut} est caractérisé par son \textbf{type} et son \textbf{domaine de valeurs} (les valeurs que peut prendre cet attribut).
  \item Dans une représentation sous forme de tableau, les \textbf{descripteurs} ou \textbf{attributs} sont en général placés comme en-tête de colonnes sur la première ligne.
\end{itemize}
\end{tipbox}

\begin{center}
\includegraphics[width=0.8\textwidth]{tableur.png}
\end{center}

\begin{cautionbox}{Exemple}
La table représentée ci-dessus est affichée dans un tableur. Nous voyons les 20 premiers enregistrements de cette table qui rassemble des données sur tous les établissements scolaires primaires et secondaires dans le Cantal (source : \url{https://www.data.gouv.fr/fr/}).

Les attributs de cette table sont :
\begin{itemize}
  \item Le \textit{code} UAI (Unité Administrative Immatriculée) avec un domaine de valeurs particulier ;
  \item le \textit{nom} avec pour domaine de valeur les chaînes de caractères ;
  \item le \textit{statut} avec pour domaine de valeur les deux chaînes \{\texttt{"Public"}, \texttt{"Privé"}\} ;
  \item le \textit{codepostal} avec un domaine de valeurs particulier ;
  \item la \textit{commune} avec pour domaine de valeur les chaînes de caractères ;
  \item la \textit{latitude} et la \textit{longitude} avec pour domaine de valeur les flottants.
\end{itemize}
\end{cautionbox}

\subsection*{1.2. Échange de table de données avec un fichier CSV}

Pour échanger des \textbf{données tabulaires} entre les programmes qui doivent les manipuler, on les exporte puis les importe sous la forme de fichiers textes, c'est-à-dire lisibles par l'être humain.

Afin d'assurer l'interopérabilité entre différents programmes, un fichier doit respecter un \textbf{format} normalisé.

L'un des formats les plus répandus pour l'échange de \textbf{données tabulaires} est le format \href{https://fr.wikipedia.org/wiki/Comma-separated_values}{CSV} pour \textit{Comma Separated Values} :
\begin{itemize}
  \item Un fichier \href{https://fr.wikipedia.org/wiki/Comma-separated_values}{CSV} est un fichier texte donc éditable avec un éditeur de textes comme \href{https://notepad-plus-plus.org/downloads/}{Notepad++}. On peut aussi l'éditer dans un tableur ;
  \item chaque ligne du fichier correspond à un \textbf{enregistrement} de la table ;
  \item pour un \textbf{enregistrement} donné, les valeurs des différents \textbf{attributs} sont séparées en \textbf{champs} par un \textbf{délimiteur} qui est en général l'un des symboles \texttt{,} ou \texttt{;} ou \texttt{:} ;
  \item la première ligne contient en général les noms des attributs.
\end{itemize}

Voici la même table que celle qui est affichée dans un tableur ci-dessus, au format CSV :
\begin{lstlisting}[language={}, basicstyle=\ttfamily\scriptsize]
code,nom,statut,codepostal,commune,latitude,longitude
0150424E,Ecole maternelle de La Fontaine,Public,15000,AURILLAC,44.93215113696133,2.4472797795526975
0150426G,Ecole élémentaire La Jordanne,Public,15000,AURILLAC,44.91746484780829,2.4412899019318455
0150713U,Ecole élémentaire Belbex,Public,15000,AURILLAC,44.91692385174704,2.420740047835959
0150669W,Ecole élémentaire de Canteloube,Public,15000,AURILLAC,44.90604342702414,2.4320205660195438
0150695Z,Ecole élémentaire Paul Doumer,Public,15000,AURILLAC,44.92315413405051,2.4369699098202613
0150708N,Collège privé Gerbert,Privé,15000,AURILLAC,44.915101259869516,2.4353907452880663
...
\end{lstlisting}

On observe que le délimiteur de champ est le symbole \texttt{,} et que les champs peuvent contenir des espaces.

Dans un tel jeu de données, il peut y avoir des champs vides dans certains enregistrements et il se peut aussi que le nombre de champs pour un ne corresponde pas au nombre d'attributs ! Pour traiter un tel fichier avec un programme, il faut d'abord analyser sa structure, ses particularités et prévoir d'éventuelles irrégularités dans les données (absence, erreurs de type, de saisie, corruption du fichier ...). Le \textbf{contrôle de la validité} des données doit donc être une composante du programme de traitement : recherche de doublons, tests de cohérence.

\subsection*{1.3. Manipulation de fichiers CSV en Python}

\begin{tipbox}{Définition}
\textbf{L'indexation de table} est la création d'une structure de données à partir d'une table.

L'indexation d'une table extraite d'un fichier CSV peut se faire vers une structure de données du langage Python : \textbf{tableau de tableaux} ou (mieux) \textbf{tableau de dictionnaires}.
\end{tipbox}

Dans cette section, on considère le fichier \href{https://fr.wikipedia.org/wiki/Comma-separated_values}{CSV}, \texttt{educ\_cantal.csv}, contenant les enregistrements des établissements scolaires primaires et secondaires dans le Cantal.

Présentons deux méthodes de lecture de fichiers \href{https://fr.wikipedia.org/wiki/Comma-separated_values}{CSV} qui utilisent les outils standards de Python.

On fait les hypothèses suivantes : la première ligne du fichier contient les attributs et on connaît le délimiteur, ici le symbole \texttt{,}.

\newpage

\subsubsection*{Avec un tableau de tableaux}

\textbf{Lecture}

On peut extraire les attributs et la table contenus dans le fichier \texttt{educ\_cantal.csv} avec le code ci-dessous :
\begin{lstlisting}[language=Python]
# ouverture du fichier en mode lecture
fichier = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')
# extraction de la ligne des attributs
attributs = fichier.readline().rstrip().split(',')
# extraction des autres lignes
table = [ligne.rstrip().split(',') for ligne in fichier]
# fermeture du fichier
fichier.close()
\end{lstlisting}

La fonction \texttt{open} permet de créer un objet \texttt{fichier} qu'on peut parcourir ligne par ligne avec un curseur : d'abord la première ligne avec \texttt{fichier.readline()} puis les lignes suivantes en itérant sur \texttt{fichier}. Il est important de préciser \textbf{l'encodage du fichier}, par défaut, c'est celui du système d'exploitation.

Chaque ligne est une chaîne de caractères découpée en liste de champs selon le délimiteur passé en paramètre à la méthode \texttt{split}. Le caractère de saut de lignes a d'abord été supprimé avec la méthode \texttt{rstrip}.

On récupère ainsi les attributs comme un tableau de type \texttt{list} et la table comme un tableau d'enregistrements qui sont eux-mêmes des tableaux. Notons que toutes les valeurs sont des chaînes de caractères et qu'il faudra convertir certaines pour les traiter !

\begin{lstlisting}[language=Python]
print(attributs)
print(table[18])
print(table[:2])
\end{lstlisting}

\textbf{Écriture}

On peut ensuite recopier les attributs et la table dans un autre fichier \texttt{educ\_cantal\_copie.csv} avec le code ci-dessous :
\begin{lstlisting}[language=Python]
g = open('educ_cantal_copie.csv', mode='w', encoding='utf8', newline='')
premiere_ligne = ','.join(attributs) + '\n'
g.write(premiere_ligne)
for enregistrement in table:
    g.write(','.join(enregistrement) + '\n')
g.close()
\end{lstlisting}

La méthode \texttt{join} permet de concaténer les éléments d'un tableau de chaînes de caractères avec un délimiteur.

Avec ces méthodes, une table est donc représentée par \textbf{un tableau de tableaux}. On accède à un enregistrement par son index dans la table et à la valeur d'un attribut par son index dans le tableau des attributs (séparé de la table). C'est incommode et le code produit est peu lisible. Ainsi, pour accéder à l'adresse mail du premier enregistrement, il faut saisir \texttt{table[0][2]}. On aimerait écrire \texttt{table[0]['email']}. Pour cela, chaque enregistrement devrait être un p-uplet nommé que nous représenterons par dictionnaire avec pour clefs les attributs de la table. C'est possible en utilisant le \href{https://docs.python.org/fr/3/library/csv.html}{module \texttt{csv}}.

\textbf{Limite :} accès moins lisible (ex. \texttt{table[0][2]}).

\subsubsection*{Avec un tableau de dictionnaires (module \texttt{csv})}

Le \href{https://docs.python.org/fr/3/library/csv.html}{module \texttt{csv}} est disponible dans la bibliothèque standard et peut donc être utilisé sans installation spécifique. À partir de la table contenue dans le même fichier CSV \texttt{'educ\_cantal.csv'}, ce module permet de créer une structure de données d'un accès plus facile.

\textbf{Lecture}

Le code ci-dessous permet d'extraire directement la table d'un fichier CSV dans une structure de données qui est un \textbf{tableau de dictionnaires} : chaque enregistrement est un dictionnaire dont les clefs sont les attributs listés sur la première ligne du fichier.

Remarque : pour les versions de Python 3.6 et 3.7 uniquement, les dictionnaires renvoyés sont spécifiques, de type \texttt{OrderedDict}, et on prendra soin de les convertir en dictionnaires standard avec \texttt{dict} en entrant : \texttt{table = [dict(enregistrement) for ...]}.

\begin{lstlisting}[language=Python]
import csv

f = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')
reader = csv.DictReader(f, delimiter=',')  # création d'un objet reader
table = [enregistrement for enregistrement in reader]
f.close()
\end{lstlisting}

La structure de données représentant la table est un \textbf{tableau de dictionnaires} : l'accès aux enregistrements se fait par index et à leurs attributs par clef : très efficace (coût constant) et code lisible. Notons que toutes les valeurs restent des chaînes de caractères et qu'il faudra en convertir certaines pour les traiter !

\begin{lstlisting}[language=Python]
# premier enregistrement de type dictionnaire
print(table[18])
# tableau de dictionnaires : extrait
print(table[:2])
# nombre d'enregistrements
print(len(table))
# accès facile aux valeurs des attributs par clefs
print(table[18]["nom"])
\end{lstlisting}

\textbf{Écriture}

L'écriture d'un tableau de dictionnaires partageant les mêmes clefs sous forme de table dans un fichier CSV, s'effectue de façon symétrique à travers un objet \texttt{DictWriter}. À titre, d'exemple, on recopie la table extraite précédemment dans un autre fichier CSV. Depuis Python 3.7, le parcours des clefs d'un dictionnaire est garanti dans le même ordre que celui d'insertion donc on peut récupérer la liste des attributs avec \texttt{list(table[0].keys())}.

\begin{lstlisting}[language=Python]
g = open('educ_cantal_copie2.csv', mode='w', encoding='utf8', newline='')
attributs = list(table[0].keys())
writer = csv.DictWriter(g, delimiter=',', fieldnames=attributs)  # création de l'objet writer
writer.writeheader()  # écriture des attributs
for enregistrement in table:
  writer.writerow(enregistrement)  # écriture des enregistrements
g.close()
\end{lstlisting}

{\scriptsize
\textbf{Remarque}

Le module \texttt{csv} permet aussi d'extraire une table d'un fichier CSV sous forme de \textbf{tableau de tableaux} comme dans la méthode précédente. Le découpage des lignes/enregistrements selon le délimiteur est intégré ce qui simplifie le code.

\begin{lstlisting}[language=Python]
f = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')
reader = csv.reader(f, delimiter=',')
table = [ligne for ligne in reader]
f.close()
\end{lstlisting}
}

\section*{2. Recherche dans une table}

Pour accéder aux données, il faut les rechercher et les regrouper suivant différents critères.

\begin{tipbox}{Définition}
\begin{itemize}
  \item \textbf{Sélection} : accéder à un ou plusieurs enregistrements vérifiant un critère.
  \item \textbf{Projection} : accéder à toutes les données d'une colonne.
\end{itemize}
\end{tipbox}

\subsection*{Exemple de sélection}

Supposons qu'on dispose d'une table enregistrée dans une liste de dictionnaires :
\begin{lstlisting}[language=Python]
Table1 = [
    {'Nom': 'Joe', 'Anglais': '17', 'Info': '18', 'Maths': '16'},
    {'Nom': 'Zoé', 'Anglais': '15', 'Info': '17', 'Maths': '19'},
    {'Nom': 'Max', 'Anglais': '19', 'Info': '13', 'Maths': '14'},
    {'Nom': 'Bob', 'Anglais': '12', 'Info': '16', 'Maths': '10'}
]
\end{lstlisting}

On souhaite extraire la liste des enregistrements des élèves ayant eu au moins 16 en maths.

On peut le faire "à la main" :
\begin{lstlisting}[language=Python]
au_moins_16_en_maths = []
for enregistrement in Table1:
  if int(enregistrement['Maths']) >= 16:
    au_moins_16_en_maths.append(enregistrement)
\end{lstlisting}

Le résultat est encore une table :

\begin{lstlisting}[language=Python]
au_moins_16_en_maths
\end{lstlisting}

On peut le faire avec une liste en compréhension :
\begin{lstlisting}[language=Python]
au_moins_16_en_maths = [enre for enre in Table1 if int(enre['Maths']) >= 16]
\end{lstlisting}

Le résultat est identique.

\subsection*{Exemple de projection}

Cette fois, on souhaite récupérer toutes les valeurs pour un champ donné, par exemple toutes les notes de mathématiques.

L'approche est similaire, on crée une liste, on parcourt la table et on ajoute à la liste tous les éléments qui nous intéressent.

\textbf{À la main :}

\begin{lstlisting}[language=Python]
notes_maths = []
for enregistrement in Table1:
  notes_maths.append(enregistrement['Maths'])
\end{lstlisting}

\textbf{Par compréhension :}

\begin{lstlisting}[language=Python]
notes_maths = [enre['Maths'] for enre in Table1]
\end{lstlisting}

Dans les deux cas le résultat est la liste ['16', '19', '14', '10'].

\begin{cautionbox}{Exercices}
\begin{enumerate}[leftmargin=*]
  \item Adapter la sélection afin de récupérer tous les enregistrements des élèves dont le nom comporte un "o".
  \item Projeter pour construire la liste des noms puis celle des paires de notes d'info et de maths :
\end{enumerate}

\[
[(18, 16), (17, 19), (13, 14), (16, 10)]
\]
\end{cautionbox}

% \begin{tipbox}{Solution}
% \begin{enumerate}[leftmargin=*]
%   \item Avec une boucle :
% \end{enumerate}

% \begin{lstlisting}[language=Python]
% nom_avec_o = []
% for enregistrement in Table1:
%     if 'o' in enregistrement['Nom']:
%         nom_avec_o.append(enregistrement)
% \end{lstlisting}

% En compréhension :

% \begin{lstlisting}[language=Python]
% nom_avec_o = [enre for enre in Table1 if 'o' in enre['Nom']]
% \end{lstlisting}

% \begin{enumerate}[leftmargin=*]
%   \setcounter{enumi}{1}
%   \item Liste des noms :
% \end{enumerate}

% \begin{lstlisting}[language=Python]
% # avec une boucle
% liste_noms = []
% for enregistrement in Table1:
%     liste_noms.append(enregistrement['Nom'])

% # avec une liste en compréhension
% liste_noms = [enre['Nom'] for enre in Table1]
% \end{lstlisting}

% paires info/maths

% \begin{lstlisting}[language=Python]
% # avec une boucle
% liste_paires = []
% for enregistrement in Table1:
%     liste_paires.append((enregistrement['Info'], enregistrement['Maths']))

% # avec une liste en compréhension
% liste_paires = [(enre['Info'], enre['Maths']) for enre in Table1]
% \end{lstlisting}
% \end{tipbox}

\section*{3. Tri d'une table}

\subsection*{3.1. Tri d'une table selon une colonne}

Il s'agit ici de trier les données d'une table selon un des attributs de la table, c'est-à-dire selon une colonne. Il faut bien sûr pour cela que les données de cet attribut soient "triables", autrement dit qu'un ordre peut être défini sur ces données. Pour des données numériques, on peut penser à l'ordre croissant ou à l'ordre décroissant. Pour des données textuelles, à l'ordre alphabétique. On peut aussi vouloir trier les données selon plusieurs champs.

Nous allons pour cela utiliser la fonction Python \texttt{sorted} qui s'applique à un objet de type \texttt{list} et qui renvoie une nouvelle \texttt{list} triée. Outre la table à trier, cette fonction peut prendre deux arguments nommés facultatifs :

\begin{itemize}
  \item \texttt{reverse = True} pour un tri dans l'ordre inverse ;
  \item \texttt{key = ...} pour préciser selon quel critère une liste doit être triée.
\end{itemize}

Quelques exemples :

\begin{lstlisting}[language=Python]
ma_liste = [10, 3, 71, 96]
print(sorted(ma_liste))
print(sorted(ma_liste, reverse=True))

mes_couples = [('a', 3), ('d', 2), ('c', 5), ('b', 1)]
print(sorted(mes_couples))     # tuples triés selon leur premier élément (par défaut)

def y(couple):    # on définit une fonction qui retourne le second élément d'un tuple
    return couple[1]

print(sorted(mes_couples, key=y)) # tuples triés selon leur second élément
\end{lstlisting}

\begin{warningbox}{Attention}
Attention, \texttt{sorted} ne renvoie qu'une copie superficielle du tableau ! Si ses éléments sont des références et c'est le cas de l'implémentation des tables de données sous forme de tableaux de dictionnaires, il faut effectuer une copie profonde du tableau avec la fonction \texttt{deepcopy} du module \texttt{copy} pour obtenir une vraie copie triée du tableau initial : \texttt{sorted(deepcopy(tab), key = clef\_tri)}.
\end{warningbox}

\subsection*{3.2. Tri suivant plusieurs colonnes}

Considérons la table suivante :

\begin{lstlisting}[language=Python]
table = [{'élève' : 'guido', 'langage' : 'python', 'note' : 19},
         {'élève' : 'monty', 'langage' : 'python', 'note' : 20},
         {'élève' : 'brian', 'langage' : 'c', 'note' : 20}]
\end{lstlisting}

On souhaite trier en fonction du langage dans l'ordre alphabétique, puis de la note dans l'ordre croissant. La fonction donnée en argument \texttt{key} doit alors retourner le couple ordonné des deux attributs voulus :

\begin{lstlisting}[language=Python]
def cle_langage_note(enre):
    return (enre['langage'], enre['note'])

sorted(table, key = cle_langage_note)
\end{lstlisting}

Si l'on souhaite trier dans l'ordre croissant suivant l'attribut langage et décroissant suivant l'attribut note, on procède en deux étapes :

\begin{lstlisting}[language=Python]
def cle_langage(enre):
  return enre['langage']

def cle_note(enre):
  return enre['note']

table_temp = sorted(table, key = cle_langage)
sorted(table_temp, key = cle_note, reverse = True)
\end{lstlisting}

\section*{4. Fusion de deux tables}

Il est courant de travailler avec plusieurs tables de données. Nous avons alors parfois besoin de rassembler deux tables en une seule ou encore de construire une nouvelle table à partir de certains attributs de tables existantes.

\subsection*{4.1. Fusion de deux tables de même structure}

Le cas le plus simple est lorsque nous disposons de deux tables, par exemple sous la forme de tableaux de dictionnaires, qui possèdent exactement les mêmes attributs.

Une simple \textbf{concaténation} des tableaux permet cette fusion, en prenant garde néanmoins :

\begin{itemize}
  \item À ne pas conserver deux fois la définition des descripteurs ;
  \item à éviter les doublons : cas d'un enregistrement qui se trouverait dans les deux tables initiales.
\end{itemize}

Sous l'hypothèse qu'il n'y a pas de doublons, le code ci-dessous procède à cette fusion :

\begin{lstlisting}[language=Python]
def fusion_tables(table1: list, table2: list) -> list:
  """table 1 et table 2 ont les mêmes descripteurs
  il n'y a pas de doublons"""
    fusion = deepcopy(table1)
  for enreg in table2[1:]:    # on élimine la première ligne (descripteurs)
        fusion.append(deepcopy(enreg))
    return fusion
\end{lstlisting}

\subsection*{4.2. Fusion de deux tables pour un même attribut}

On veut fusionner deux tables selon un attribut commun. On va sélectionner dans chaque table la ligne ayant la même valeur pour l'attribut choisi.

Reprenons le tableau \texttt{Table1} des exemples précédents :

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Nom & Anglais & Info & Maths \\
\hline
Joe & 17 & 18 & 16 \\
Zoé & 15 & 17 & 19 \\
Max & 19 & 13 & 14 \\
\hline
\end{tabular}
\end{center}

Définissons une seconde table, \texttt{Table2} donnant l'âge et le courriel de certains élèves :

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Nom & Age & Courriel \\
\hline
Joe & 16 & joe@info.fr \\
Zoé & 15 & zoe@info.fr \\
\hline
\end{tabular}
\end{center}

On voudrait regrouper les données des deux tables. Elles ont l'attribut \texttt{Nom} en commun. On veut obtenir la table suivante :

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Nom & Age & Courriel & Anglais & Info & Maths \\
\hline
Joe & 16 & joe@info.fr & 17 & 18 & 16 \\
Zoé & 15 & zoe@info.fr & 15 & 17 & 19 \\
\hline
\end{tabular}
\end{center}

On choisit d'exclure la ligne concernant \texttt{Max}, car il n'est pas présent dans la seconde table.

\begin{tipbox}{Définition}
En informatique, la \textbf{jointure} est l'opération permettant d'associer plusieurs tables par le biais d'un lien logique de données entre les différentes tables, le lien étant défini par une condition. Le résultat de l'opération est une nouvelle table.
\end{tipbox}

La \textbf{jointure} s'obtient avec deux boucles imbriquées : on parcourt tous les couples constitués d'enregistrements de la première puis de la seconde table et on filtre à l'aide d'une instruction conditionnelle.

\begin{lstlisting}[language=Python]
from copy import deepcopy

Table1 = [{'Nom': 'Joe', 'Anglais': '17', 'Info': '18', 'Maths': '16'},
      {'Nom': 'Zoé', 'Anglais': '15', 'Info': '17', 'Maths': '19'},
      {'Nom': 'Max', 'Anglais': '19', 'Info': '13', 'Maths': '14'},
      {'Nom': 'Bob', 'Anglais': '12', 'Info': '16', 'Maths': '10'}]

Table2 = [{'Nom': 'Joe', 'Age': 16, 'Couriel': 'joe@info.fr'},
      {'Nom': 'Zoé', 'Age': 15, 'Couriel': 'zoe@info.fr'}]


def jointure_selon_attribut_commun(t1: list, t2: list, attr: str) -> list:
  """Effectue la jointure entre les tables t1 et t2 selon l'attribut commun attr"""
    jointure = []
    for item1 in t1:
        for item2 in t2:
            if item1[attr] == item2[attr]:
        # définition d'une ligne de la nouvelle table reprenant le contenu de la ligne en cours de t1
                new_line = deepcopy(item1)
        # boucle pour ajouter les champs de la ligne de t2 autres que attr
                for cle in item2:
                    if cle != attr:
                        new_line[cle] = item2[cle]
        # ajout de la nouvelle ligne à la nouvelle table
                jointure.append(new_line)
    return jointure


print(jointure_selon_attribut_commun(Table2, Table1, 'Nom'))
\end{lstlisting}

\textbf{Remarque} : dans la fonction ci-dessus, on suppose que le nom des attributs est toujours une chaîne de caractères.

\end{document}

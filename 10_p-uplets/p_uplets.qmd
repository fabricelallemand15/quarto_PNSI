---
title: 5.1 - Les p-uplets en Python
---

:::{.callout-tip}
## Définition
Un objet de type tuple, un p-uplet, est une **suite ordonnée d'éléments** qui peuvent être chacun de n'importe quel type. On parlera indifféremment de **p-uplet** ou de **tuple**.
:::

Les p-uplets et les tableaux (listes), déjà étudiés, sont deux structures de données très semblables, mais il existe une différence importante : **les éléments d'un p-uplet ne sont pas modifiables**, alors que les éléments d'une liste sont modifiables. En particulier, **on ne peut pas** procéder à une affectation de la forme ``t[i]=valeur`` pour un p-uplet ``t`` (ce qui est possible pour une liste).

## 1. Création d'un p-uplet

Pour créer un p-uplet non vide, on écrit $n$ valeurs séparées par des virgules et placées entre des **parenthèses**. Par exemple :

* ``t = ("a", "b", "c", 3)`` pour un tuple à 4 éléments ;
* ``t = ("a", )``pour un tuple à 1 élément (attention à la virgule) ;
* ``t = ()`` pour un tuple à 0 éléments (ici, pas de virgule, mais des parenthèses).

On peut aussi, quand il n'y a pas d'ambiguïté, ne pas écrire les parenthèses : ``t = 1, 2, 3, 4``. Mais les parenthèses peuvent améliorer la lisibilité et on les utilisera de préférence.

On dit aussi qu'on **empaquette** les valeurs 1, 2, 3 et 4 dans le quadruplet ``t``.

## 2. Opérations

Nous avons deux opérateurs de concaténation qui s'utilisent comme avec les chaînes de caractères, ce sont les opérateurs `+` et `*`.

De nouveaux p-uplets sont créés.

````python
>>> t1 = ("a", "b")
>>> t2 = ("c", "d")
>>> t1 + t2
('a', 'b', 'c', 'd')
>>> 3 * t1
('a', 'b', 'a', 'b', 'a', 'b')
````

## 3. Appartenance

Pour tester l'appartenance d'un élément à un tuple, on utilise l'opérateur ``in`` :

````python
>>> t = ("a", "b", "c")
>>> "a" in t
True
>>> "d" in t
False
````

## 4. Utilisation des indices

Les indices permettent d'accéder aux différents éléments d'un tuple. Pour accéder à un élément d'indice ``i`` d'un tuple ``t``, la syntaxe est ``t[i]``. L'indice ``i`` peut prendre les valeurs entières de 0 à $n − 1$ où $n$ est la longueur du tuple. Cette longueur s'obtient avec la fonction ``len``. Exemple :

````python
>>> t = ("a", 1, "b", 2, "c", 3)
>>> len(t)
6
>>> t[2]
'b'
````

Les indices commencent toujours à 0 et par exemple le troisième élément a pour indice 2. Le dernier élément d'un tuple ``t`` a pour indice ``len(t)-1``. On accède ainsi au dernier élément avec ``t[len(t)-1]`` qui peut s'abréger en ``t[-1]``. Les indices négatifs permettent donc d'accéder aux éléments du tuple "en partant de la fin".

````python
>>> t = ("a", 1, "b", 2, "c", 3)
>>> t[-1]
3
>>> t[-2]
'c'
````

Exemple avec des tuples emboîtés (un tuple contenant des tuples) :

````python
>>> t = (("a", "b"), ("c", "d"))
>>> t[1][0]
'c'
````

Explication : ``t[1]`` est le tuple ``("c", "d")`` et ``'c'`` est l'élément d'indice 0 de ce tuple.

Rappelons ce qui a été annoncé plus haut : les éléments d'un tuple ne sont pas modifiables par une affectation de la forme ``t[i]=valeur`` qui provoque une erreur et arrête le programme.

## 5. Affectation multiple

Prenons pour exemple l'affectation ``a, b, c = 1, 2, 3``. Ceci signifie que le tuple ``(a, b, c)`` prend pour valeur le tuple ``(1, 2, 3)``, autrement dit les valeurs respectives des variables ``a``, ``b`` et ``c`` sont 1, 2 et 3.

En particulier, l'instruction ``a, b = b, a`` permet d'échanger les valeurs des deux variables ``a`` et ``b``.

Les valeurs des éléments d'un tuple peuvent ainsi être stockées dans des variables.

````python
>>> t = (1, 2, 3)
>>> a, b, c = t
>>> b
2
````

Cette syntaxe s'utilise souvent avec une fonction qui renvoie un tuple.

Voici un exemple avec une fonction qui calcule et renvoie les longueurs des trois côtés d'un triangle ABC. La fonction prend en paramètres trois p-uplets représentant les coordonnées des trois points. On importe au préalable la fonction racine carrée ``sqrt`` du module ``math``.

````{.python code-line-numbers="true"}
from math import sqrt

def longueurs(A, B, C):
    xA, yA = A
    xB, yB = B
    xC, yC = C
    dAB = sqrt((xB - xA) ** 2 + (yB - yA) ** 2)
    dBC = sqrt((xC - xB) ** 2 + (yC - yB) ** 2)
    dAC = sqrt((xC - xA) ** 2 + (yC - yA) ** 2)
    return dAB, dBC, dAC
````

Dans cette fonction, les variables ``A``, ``B`` et ``C`` sont des 2-uplets représentant les coordonnées des points A, B et C. Aux lignes 4, 5, 6, on **dépaquette** ces 2-uplets pour procéder à une affectation multiple.

La fonction étant définie, nous l'utilisons dans l'interpréteur :

````python
>>> M = (3.4, 7.8)
>>> N = (5, 1.6)
>>> P = (-3.8, 4.3)
>>> dMN, dNP, dMP = longueurs(M, N, P)
>>> dMN
6.403124237432848
````

## 6. Parcours d'un tuple avec une boucle for

Une boucle ``for`` permet de parcourir chacun des éléments d'un tuple.

Comme pour les tableaux, on peut parcourir un tuple en utilisant les indices, mais on peut aussi parcourir directement les éléments du tuple sans faire appel à des indices :

````python
>>> t = (1,2,3,4)
>>> # Parcours avec les indices
>>> for i in range(len(t)):
        print(t[i])
1
2
3
4
>>> # Parcours direct des éléments
>>> for k in t: 
        print(k)
1
2
3
4
````

:::{.callout-important}
## À retenir
* Un p-uplet, ou tuple, est une structure ordonnée qui permet de contenir plusieurs éléments qui sont tous accessibles.
* Un même p-uplet peut contenir des éléments de types différents. Un p-uplet peut contenir d'autres p-uplets.
* Un p-uplet est **immuable**, c'est-à-dire non modifiable : on ne peut pas procéder à une affectation de la forme ``t[i]=valeur``
:::

**Remarque** : en français, un objet non modifiable élément par élément après sa création est dit **immuable**. En anglais, on dit **immutable**.

:::{.callout-note}
## Remarque : p-uplets nommés
Dans le programme, il est fait mention de p-uplets nommés. Ce type de variable est semblable aux p-uplets, avec toutes leurs propriétés, mais les éléments ne sont pas indexés par un entier 0, 1, 2 ..., mais par un descripteur qui peut par exemple être une chaîne de caractères :

````python
>>> monsieurX = {"nom": "X", "́prenom": "Monsieur", "age": 47}
>>> monsieurX["age"]
47
````

Le type p-uplet nommé n'existe pas en Python (ou alors il faut utiliser une bibliothèque supplémentaire). Nous utiliserons à la place des dictionnaires ([voir le cours sur les dictionnaires](../12_dictionnaires/dicos.qmd)).
:::
[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "algo1/exos_recherche.html",
    "href": "algo1/exos_recherche.html",
    "title": "Exercices - Recherche dichotomique",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "algo1/exos_recherche.html#fa-desktop-t.p.-bilan-et-compléments",
    "href": "algo1/exos_recherche.html#fa-desktop-t.p.-bilan-et-compléments",
    "title": "Exercices - Recherche dichotomique",
    "section": " T.P. : Bilan et compléments",
    "text": "T.P. : Bilan et compléments\n\n\n\n\n\n\nImportant\n\n\n\nNotebook Capytale pour ce T.P. : Capytale \nCe T.P. est à faire dans Capytale en suivant le lien ci-dessus."
  },
  {
    "objectID": "algo1/exos_tris.html",
    "href": "algo1/exos_tris.html",
    "title": "Exercices - Algorithmes de tris",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "algo1/exos_tris.html#fa-desktop-exercice-1",
    "href": "algo1/exos_tris.html#fa-desktop-exercice-1",
    "title": "Exercices - Algorithmes de tris",
    "section": " Exercice 1",
    "text": "Exercice 1\nCet exercice est à faire dans Capytale.\nÉcrire une fonction trie_chaine qui prend en argument une liste de chaînes de caractères et qui modifie cette liste en la triant en fonction du nombre de lettres. Cette fonction ne renvoie rien.\nTester la fonction avec la liste [\"un\", \"deux\", \"trois\", \"quatre\", \"cinq\", \"six\", \"sept\", \"huit\", \"neuf\", \"dix\"]."
  },
  {
    "objectID": "algo1/exos_tris.html#fa-desktop-exercice-2-le-tri-à-bulles",
    "href": "algo1/exos_tris.html#fa-desktop-exercice-2-le-tri-à-bulles",
    "title": "Exercices - Algorithmes de tris",
    "section": " Exercice 2 : le tri à bulles",
    "text": "Exercice 2 : le tri à bulles\nCet exercice est à faire dans Capytale.\nL’algorithme de tri à bulles est le suivant :\n\nOn parcourt la liste de gauche à droite.\nSi deux éléments consécutifs sont dans le mauvais ordre, on les échange.\nSi, à l’étape précédente, au moins un échange a eu lieu, on recommence à l’étape 1.\nSinon, la liste est triée et on arrête.\n\n\nÉcrire toutes les étapes du tri à bulles pour la liste [5, 3, 2, 4, 1].\nSoit \\(n\\) un entier naturel non nul et \\(L\\) une liste de \\(n\\) entiers rangés dans l’ordre décroissant (pire des cas). Combien d’échanges sont nécessaires pour trier \\(L\\) dans l’ordre croissant ? En déduire une évaluation de la complexité de cet algorithme.\nÉcrire une fonction tri_bulles qui prend en argument une liste de nombres et qui modifie cette liste en la triant par ordre croissant en utilisant l’algorithme du tri à bulles. Cette fonction ne renvoie rien.\nAjouter une variable compteur dans la fonction tri_bulles qui compte le nombre d’échanges effectués. Ce nombre doit être renvoyé par la fonction. Tester la fonction avec la liste [5, 3, 2, 4, 1] et vérifier que le compteur vaut bien 6."
  },
  {
    "objectID": "algo1/exos_tris.html#fa-desktop-t.p.-bilan-et-compléments",
    "href": "algo1/exos_tris.html#fa-desktop-t.p.-bilan-et-compléments",
    "title": "Exercices - Algorithmes de tris",
    "section": " T.P. : Bilan et compléments",
    "text": "T.P. : Bilan et compléments\n\n\n\n\n\n\nImportant\n\n\n\nNotebook Capytale pour ce T.P. : Capytale \nCe T.P. est à faire dans Capytale en suivant le lien ci-dessus."
  },
  {
    "objectID": "algo1/generalites.html",
    "href": "algo1/generalites.html",
    "title": "Notions de base (Cours)",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème."
  },
  {
    "objectID": "algo1/generalites.html#introduction",
    "href": "algo1/generalites.html#introduction",
    "title": "Notions de base (Cours)",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème."
  },
  {
    "objectID": "algo1/generalites.html#terminaison-dun-algorithme",
    "href": "algo1/generalites.html#terminaison-dun-algorithme",
    "title": "Notions de base (Cours)",
    "section": "2. Terminaison d’un algorithme",
    "text": "2. Terminaison d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la terminaison d’un algorithme, c’est prouver que l’algorithme se termine dans tous les cas. C’est notamment très important lorsque l’algorithme comporte des boucles conditionnelles.\n\n\nPrenons comme exemple l’algorithme suivant qui calcule la puissance entière d’un nombre :\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nComment justifier que cet algorithme se termine dans tous les cas ? Cela revient à montrer que la boucle conditionnelle while compteur &lt; n se termine après un nombre fini d’itérations. Pour cela, on utilise un variant de boucle : c’est une valeur qui évolue à chaque itération de la boucle et qui permet de prouver que celle-ci se termine.\nDans notre exemple, on peut choisir comme variant de boucle la valeur de la variable \\(compteur\\). En effet, cette variable est initialisée à 0 et est incrémentée de 1 à chaque itération. Après \\(n\\) itérations, la condition de sortie de boucle sera donc vraie et la boucle se terminera.\nLa terminaison de l’algorithme est donc démontrée."
  },
  {
    "objectID": "algo1/generalites.html#correction-dun-algorithme",
    "href": "algo1/generalites.html#correction-dun-algorithme",
    "title": "Notions de base (Cours)",
    "section": "3. Correction d’un algorithme",
    "text": "3. Correction d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la correction d’un algorithme, c’est prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\n\n\nConsidérons à nouveau l’algorithme de calcul de puissance entière. Comment prouver que cet algorithme calcule bien la puissance entière d’un nombre ?\nOn utilise pour cela un invariant de boucle : c’est une propriété qui est vraie avant et après chaque itération de la boucle, et qui doit permettre de prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\nDans notre exemple de calcul de puissance entière, on peut choisir comme invariant de boucle la propriété suivante : \\[p=x^{compteur}\\]\n\n\n\n\n\n\nPour prouver q’une propriété est un invariant de boucle…\n\n\n\nIl faut démontrer :\n\nInitialisation : la propriété est vraie avant le premier passage dans la boucle\nConservation : si la propriété est vraie avant une itération, alors elle sera aussi vraie après cette itération.\nConclusion : une fois la boucle terminée, la propriété est vraie.\n\n\n\nCette méthode de raisonnement est appelée raisonnement par récurrence et est très utilisée en mathématiques (au programme en spécialité mathématiques de terminale).\nDans notre exemple, on a :\n\nInitialisation : La propriété est vraie avec les valeurs initiales des variables car \\(x^0=1\\) et \\(p=1\\).\nConservation : Si nous avons \\(p=x^{compteur}\\) avant une itération, alors nous avons \\(x^{compteur+1}=x^{compteur}\\times x = p\\times x\\). le passage dans la boucle augmente \\(compteur\\) de 1 et remplace \\(p\\) par \\(p\\times x\\). Après l’itération, la propriété \\(p=x^{compteur}\\) est donc encore vraie.\nConclusion : En sortie de boucle, on a donc \\(p=x^{compteur}\\). Or on a aussi l’égalité \\(compteur = n\\) qui a provoqué la sortie de boucle. Finalement, nous avons donc \\(p=x^n\\), ce qui prouve que l’algorithme effectue bien l’opération attendue."
  },
  {
    "objectID": "algo1/generalites.html#complexité",
    "href": "algo1/generalites.html#complexité",
    "title": "Notions de base (Cours)",
    "section": "4. Complexité",
    "text": "4. Complexité\nLa durée d’exécution d’un programme traduisant un algorithme donné va dépendre des performances de la machine sur laquelle le programme est exécuté, mais aussi du nombre d’instructions élémentaires mobilisées lors de son exécution. Une partie de ce temps d’exécution provient donc de la façon dont l’algorithme est écrit et non de la façon dont il est programmé.\nOn parle de complexité temporelle d’un algorithme (et non d’un programme) pour mesurer l’efficacité intrinsèque de l’algorithme. Dans la pratique, il s’agit de compter le nombre d’opérations élémentaires (affectations, comparaisons, calculs arithmétiques, …) effectuées par l’algorithme.\nLa complexité en temps d’un algorithme dépend :\n\nde la taille des données passées en paramètres : plus ces données seront volumineuses, plus il faudra d’opérations élémentaires pour les traiter. On notera \\(n\\) le nombre de données à traiter.\nde la donnée en elle-même, de la façon dont sont réparties les différentes valeurs qui la constituent. Par exemple, si on effectue une recherche séquentielle d’un élément dans une liste non triée, on parcourt un par un les éléments jusqu’à trouver, ou pas, celui recherché. Ce parcours peut s’arrêter dès le début si le premier élément est “le bon”. Mais on peut également être amené à parcourir la liste en entier si l’élément cherché est en dernière position, ou même n’y figure pas.\n\nCette remarque conduit à préciser la définition de la complexité en temps. On peut en effet distinguer deux formes de complexité en temps :\n\nla complexité dans le meilleur des cas : c’est la situation la plus favorable, par exemple : recherche d’un élément situé à la première position d’une liste ;\nla complexité dans le pire des cas : c’est la situation la plus défavorable, par exemple : recherche d’un élément dans une liste alors qu’il n’y figure pas.\n\nOn calculera le plus souvent la complexité dans le pire des cas, car elle est la plus pertinente. Il vaut mieux en effet toujours envisager le pire.\n\nOrdres de grandeurs\nPour comparer des algorithmes, il n’est pas nécessaire de calculer la valeur exacte de la complexité, mais seulement un ordre de grandeur asymptotique, noté en mathématiques \\(\\mathcal{O}\\) (notation “grand O”). La définition rigoureuse de cette notation n’est pas au programme de NSI. Il faut cependant en avoir une idée intuitive : dire que la complexité d’un algorithme est en \\(\\mathcal{O}(n^2)\\), par exemple, signifie que cette complexité croît, lorsque \\(n\\) devient grand, de la même façon que la fonction carré. Plus précisément, elle est majorée par une fonction du type \\(c\\times n^2\\), où \\(c\\) est un réel positif.\nLes classes de complexité à connaître en première, de la meilleure à la pire :\n\n\n\n\n\n\n\n\n\\(\\mathcal{O}\\)\nType de complexité\nExemple\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nconstante\nAccès à une cellule de tableau\n\n\n\\(\\mathcal{O}(n)\\)\nlinéaire\nRecherche du maximum dans un tableau non trié\n\n\n\\(\\mathcal{O}(n^2)\\)\nquadratique\nParcours d’un tableau à deux dimensions\n\n\n\\(\\mathcal{O}(n^3)\\)\ncubique\nParcours d’un tableau à trois dimensions\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nReprenons l’algorithme du calcul de la puissance d’un nombre.\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nNous comptons la complexité en termes d’opérations arithmétiques : additions et multiplications. À chaque passage dans la boucle, nous avons deux opérations et la boucle est parcourue \\(n\\) fois . Nous avons donc au total une complexité de \\(2n\\) opérations arithmétiques, donc une complexité en \\(\\mathcal{O}(n)\\), linéaire.\n\n\n\nVisualisation graphique du temps d’exécution\nEn utilisant le module timeit comme expliqué dans cet article, on peut visualiser graphiquement le temps d’exécution de l’algorithme en fonction de la taille des données.\n\nimport matplotlib.pyplot as plt\nimport timeit\n\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\n\nabscisses = [k for k in range(0, 20, 1)]\nordonnees = []\nfor n in abscisses:\n    ordonnees.append(timeit.timeit('puissance(2, n)', number=100, globals=globals()))\n\nfig, ax = plt.subplots()\nax.set_xlabel('n')\nax.set_ylabel('temps (s)')\nplt.plot(abscisses, ordonnees, 'r')\nplt.show()\n\n\n\n\n\n\n\n\nLa courbe obtenue est proche d’une droite, ce qui est cohérent avec la complexité linéaire de l’algorithme.."
  },
  {
    "objectID": "algo1/index.html",
    "href": "algo1/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "algo1/index.html#points-traités-dans-cette-séquence",
    "href": "algo1/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "algo1/parcoursTableau.html",
    "href": "algo1/parcoursTableau.html",
    "title": "Parcours séquentiel d’un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#recherche-dune-occurrence",
    "href": "algo1/parcoursTableau.html#recherche-dune-occurrence",
    "title": "Parcours séquentiel d’un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#recherche-dun-extremum",
    "href": "algo1/parcoursTableau.html#recherche-dun-extremum",
    "title": "Parcours séquentiel d’un tableau",
    "section": "2. Recherche d’un extremum",
    "text": "2. Recherche d’un extremum\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui recherche le plus grand élément du tableau. Pour cela, on commence par choisir comme maximum temporaire le premier élément du tableau. On parcourt ensuite le tableau en testant à chaque fois si la valeur courante est plus grande que le maximum temporaire. Si c’est le cas, on met à jour le maximum temporaire avec la valeur courante.\n\ndef max(tab):\n    \"\"\"Retourne le plus grand élément du tableau\"\"\"\n    m = tab[0]\n    for i in range(1, len(tab)):\n        if tab[i] &gt; m:\n            m = tab[i]\n    return m\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(max(tab))\n\n2023\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau, sauf la première. Il y a donc au total \\(n-1\\) itérations. Nous avons aussi \\(n-1\\) comparaisons. Au total, le nombre d’opérations est donc de \\(2n-2\\). On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#calcul-dune-moyenne",
    "href": "algo1/parcoursTableau.html#calcul-dune-moyenne",
    "title": "Parcours séquentiel d’un tableau",
    "section": "3. Calcul d’une moyenne",
    "text": "3. Calcul d’une moyenne\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui calcule la moyenne des éléments du tableau.\n\ndef moyenne(tab):\n    \"\"\"Retourne la moyenne des éléments du tableau\"\"\"\n    s = 0\n    for i in range(len(tab)):\n        s += tab[i]\n    return s / len(tab)\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(moyenne(tab))\n\n409.4\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. Nous avons aussi \\(n\\) additions et une division. Au total, le nombre d’opérations est donc de \\(2n+1\\). On peut donc dire que l’algorithme est encore de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/recherche.html",
    "href": "algo1/recherche.html",
    "title": "Recherche dichotomique dans un tableau trié",
    "section": "",
    "text": "On s’intéresse ici au problème de la recherche d’une valeur dans un tableau que l’on supposera triée dans l’ordre croissant."
  },
  {
    "objectID": "algo1/recherche.html#approche-naïve",
    "href": "algo1/recherche.html#approche-naïve",
    "title": "Recherche dichotomique dans un tableau trié",
    "section": "1. Approche naïve",
    "text": "1. Approche naïve\nLa première idée qui peut venir à l’esprit est de considérer les éléments du tableau les uns après les autres et de les comparer avec l’élément recherché.\nOn peut ainsi écrire une fonction recherche_naive qui prend en paramètre un tableau tàbleau et une valeur valeur et qui renvoie l’indice de la première occurrence de valeur dans tableau ou -1 si valeur n’est pas dans tableau.\n\ndef recherche_naive(tableau, valeur):\n    for i in range(len(tableau)):\n        if tableau[i] == valeur:\n            return i\n    return -1\n\nTest de cette fonction :\n\nrecherche_naive([1, 2, 3, 4, 5], 3)\n\n2\n\n\n\nrecherche_naive([1, 2, 3, 4, 5], 6)\n\n-1\n\n\nLa complexité dans le pire des cas correspond ici au cas où la valeur recherchée n’est pas dans la liste. Il faut alors parcourir toutes les valeurs du tableau et faire \\(n\\) comparaisons, où \\(n\\) est la taille du tableau. L’algorithme naïf a donc une complexité linéaire en \\(\\mathcal{O}(n)\\).\nIl est possible d’être plus efficace en exploitant le fait que la liste est triée."
  },
  {
    "objectID": "algo1/recherche.html#recherche-dichotomique",
    "href": "algo1/recherche.html#recherche-dichotomique",
    "title": "Recherche dichotomique dans un tableau trié",
    "section": "2. Recherche dichotomique",
    "text": "2. Recherche dichotomique\n\nLe principe\nDe façon intuitive, la recherche dichotomique consiste à diviser par deux la zone de recherche à chaque étape.\nOn commence par considérer l’ensemble des éléments du tableau. On regarde ensuite la valeur de l’élément du milieu du tableau. Si cette valeur est inférieure à la valeur recherchée, alors on poursuit la recherche sur la moitié supérieure du tableau. Si la valeur est supérieure à la valeur recherchée, alors on poursuit la recherche sur la moitié inférieure. Si la valeur est égale à la valeur recherchée, on a trouvé l’élément recherché.\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\n\nOn considère le tableau tableau trié dans l’ordre croissant dans lequel on recherche la valeur valeur.\nOn définit les bornes gauche et droite du tableau : indices du premier et du dernier élément de la partie du tableau dans laquelle on recherche.\nTant que gauche est inférieur ou égal à droite :\n\nOn calcule l’indice milieu du milieu du tableau.\nSi tableau[milieu] est égal à valeur, on renvoie milieu.\nSi tableau[milieu] est inférieur à valeur, on met à jour gauche à milieu + 1. Lors de l’itération suivante, on ne considèrera donc que la partie du tableau située à droite de milieu.\nSi tableau[milieu] est supérieur à valeur, on met à jour droite à milieu - 1. Lors de l’itération suivante, on ne considèrera donc que la partie du tableau située à gauche de milieu.\n\nOn renvoie -1 si valeur n’est pas dans tableau.\n\n\n\nExemple\nOn considère le tableau [1,4,7,10,13,16,19,22,25] et on cherche la valeur 22.\nOn commence par considérer l’ensemble des éléments du tableau (gauche=0 et droite=8). On regarde ensuite la valeur de l’élément du milieu du tableau. Ici, il s’agit de l’élément d’indice 4 (milieu=4), qui vaut 13. La valeur recherchée est supérieure à 13, donc on ne considère que la partie du tableau située à droite de l’élément du milieu.\nOn répète alors l’opération sur la partie du tableau située à droite de l’élément du milieu (gauche=5 et droite=8). On obtient le tableau [16,19,22,25] et on cherche la valeur 22. L’élément du milieu de ce tableau vaut 19 (milieu=6), qui est inférieur à 22. On ne considère donc que la partie du tableau située à droite de l’élément du milieu.\nOn répète donc l’opération sur la partie du tableau située à droite (gauche=7 et droite=8). On obtient le tableau [22,25] et on cherche la valeur 22. L’élément du milieu de ce tableau vaut 22 (milieu=7), qui est égal à 22. On a donc trouvé la valeur recherchée et l’algorithme est terminé en trois étapes.\n\n\n\nRecherche dichotomique\n\n\n\n\nProgrammation\nÉcrivons une fonction recherche_dichotomique qui prend en paramètre un tableau tableau et une valeur valeur et qui renvoie l’indice d’une occurrence de valeur dans tableau ou -1 si valeur n’est pas dans tableau.\n\ndef recherche_dichotomique(tableau, valeur):\n    gauche = 0\n    droite = len(tableau) - 1\n    while gauche &lt;= droite:\n        milieu = (gauche + droite) // 2\n        if tableau[milieu] == valeur:\n            return milieu\n        elif tableau[milieu] &lt; valeur:\n            gauche = milieu + 1\n        else:\n            droite = milieu - 1\n    return -1\n\nTest de cette fonction :\n\nrecherche_dichotomique([1, 2, 3, 4, 5], 2)\n\n1\n\n\n\nrecherche_dichotomique([1, 2, 3, 4, 5], 6)\n\n-1\n\n\n\n\nPreuve de terminaison\nPour prouver que l’algorithme se termine, il faut prouver que la boucle while se termine, et donc que la condition d’arrêt gauche &gt; droite finit par être vérifiée ou bien que la condition tableau[milieu] == valeur est vérifiée.\nChoisissons comme variant de boucle la différence droite - gauche et plaçons-nous dans le cas le plus défavorable où la condition tableau[milieu] == valeur n’est jamais vérifiée. À chaque passage dans la boucle, soit gauche est incrémenté de 1, soit droite est décrémenté de 1. La différence droite - gauche est donc toujours diminuée de 1. Au bout d’un nombre fini d’itérations (au maximum égal à la taille du tableau moins un), la condition notre variant de boucle devient donc égal à zéro et la boucle se termine.\nLa terminaison de l’algorithme est donc prouvée.\n\n\nPreuve de correction\nConsidérons la propriété suivante : à chaque étape de l’algorithme, la valeur recherchée est située dans la partie du tableau située entre les indices gauche et droite inclus, ou bien elle n’est pas dans le tableau.\nMontrons que cette propriété est un invariant de boucle. C’est-à-dire que cette propriété est vraie avant l’exécution de la première itération de la boucle et qu’elle est vraie après l’exécution de chaque itération de la boucle.\nInitialisation : avant l’exécution de la première itération de la boucle, si la valeur est dans le tableau, alors elle est située dans la partie du tableau située entre les indices gauche et droite inclus. En effet, gauche vaut 0 et droite vaut la taille du tableau moins un, donc la valeur recherchée est située dans la partie du tableau située entre les indices 0 et la taille du tableau moins un inclus (c’est le tableau entier !).\nConservation : supposons que la propriété est vraie à l’entrée dans une itération de la boucle while. Il y a trois possibilités :\n\ntableau[milieu] == valeur est vérifiée. Dans ce cas, la propriété est vraie à la sortie de l’itération de la boucle et l’algorithme retourne l’indice attendu.\ntableau[milieu] &lt; valeur est vérifiée. Dans ce cas, gauche est incrémenté de 1. La valeur recherchée est donc située dans la partie du tableau située entre les indices gauche et droite inclus, ou bien elle est absente du tableau.\ntableau[milieu] &gt; valeur est vérifiée. Dans ce cas, droite est décrémenté de 1. La valeur recherchée est donc située dans la partie du tableau située entre les indices gauche et droite inclus, ou bien elle est absente du tableau.\n\nConclusion : la propriété est donc un invariant de boucle.\nDeux cas sont à considérer pour conclure. Si le test tableau[milieu] == valeur est vérifié au cours des itérations, alors la valeur est trouvée dans le tableau et on retourne son indice milieu : c’est bien le comportement attendu. Si le test tableau[milieu] == valeur n’est jamais vérifié, alors l’algorithme se termine lorsque gauche &gt; droite. D’après notre invariant de boucle, soit la valeur est alors absente du tableau, soit elle est située dans la partie du tableau située entre les indices gauche et droite inclus. Mais cette partie du tableau est un tableau vide []. La valeur est donc absente du tableau et on retourne l’indice -1 : c’est bien le comportement attendu.\nL’algorithme est donc correct.\n\n\nComplexité\nPour évaluer la complexité de cet algorithme, nous allons évaluer le nombre d’itérations nécessaires en fonction de la taille \\(n\\) du tableau, dans le pire des cas, c’est-à-dire lorsque la valeur recherchée n’est pas dans le tableau.\nÀ chaque étape, la taille du sous-tableau contenant potentiellement la valeur recherchée est divisée par deux. Au bout de \\(k\\) étapes, la taille du sous-tableau est donc de \\(\\frac{n}{2^k}\\) environ. Si la valeur recherchée n’est pas dans le tableau, alors on finit par arriver à un tableau de taille 1 et la boucle se termine au tour suivant. Soit \\(k\\) le nombre d’itérations nécessaires pour que la taille du sous-tableau soit de 1. On a donc \\(\\frac{n}{2^k}\\approx 1\\), et par conséquent \\(n=2^k\\). On en déduit que \\(k=\\log_2 n\\).\nL’algorithme de recherche dichotomique est donc en \\(\\mathcal{O}(\\log n)\\). On parle de complexité logarithmique. Cette complexité est meilleure que la complexité linéaire.\n\n\n\n\n\n\nNotion de logarithme de base 2\n\n\n\nSi \\(x\\) est une puissance de 2, alors \\(\\log_2 x\\) est égal à l’exposant de cette puissance. Par exemple, \\(\\log_2 8 = 3\\) car \\(8 = 2^3\\).\n\n\nPour un tableau de départ de taille \\(16=2^4\\) dans lequel on cherche une valeur qui n’y est pas, on effectue 4 itérations :\n\nau premier tour, on divise le tableau en deux parties de taille \\(8=2^3\\) et on cherche dans la partie de gauche (par exemple) ;\nau deuxième tour, on divise la partie de gauche en deux parties de taille \\(4=2^2\\) et on cherche dans la partie de gauche (par exemple) ;\nau troisième tour, on divise la partie de gauche en deux parties de taille \\(2=2^1\\) et on cherche dans la partie de gauche (par exemple) ;\nau quatrième tour, on divise la partie de gauche en deux parties de taille \\(1=2^0\\) et on cherche dans la partie de gauche (par exemple).\n\nOn retrouve bien un nombre d’itérations de l’ordre de \\(\\log_2 n\\).\n\n\nComparaison expérimentale des deux algorithmes\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps_naive = []\ntemps_dicho = []\n# on applique la recherche dans le pire des cas : valeur absente su tableau\nvaleur = 1000\nfor n in tailles:\n    temps_naive.append(timeit.timeit(\n        \"recherche_naive([k for k in range(n)], valeur)\",\n        globals=globals(),\n        number=100\n    ))\n    temps_dicho.append(timeit.timeit(\n        \"recherche_dichotomique([k for k in range(n)], valeur)\",\n        globals=globals(),\n        number=100\n    ))\nplt.plot(tailles,temps_naive, 'b', label=\"Recherche naïve\")\nplt.plot(tailles,temps_dicho, 'r', label=\"Recherche dichotomique\")\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "algo1/tris.html",
    "href": "algo1/tris.html",
    "title": "Algorithmes de tris",
    "section": "",
    "text": "Dans cette partie du cours, nous allons étudier deux algorithmes de tris : le tri par insertion et le tri par sélection.\nÉtant donné un tableau de nombres, l’objectif est d’écrire une fonction qui renvoie un tableau contenant les mêmes nombres mais dans l’ordre croissant."
  },
  {
    "objectID": "algo1/tris.html#tri-par-insertion",
    "href": "algo1/tris.html#tri-par-insertion",
    "title": "Algorithmes de tris",
    "section": "1. Tri par insertion",
    "text": "1. Tri par insertion\n\nLe principe\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\nEn commençant par le deuxième élément du tableau :\n\nOn compare l’élément courant avec l’élément précédent.\nSi l’élément courant est plus petit, on échange les deux éléments.\nOn continue à comparer et échanger l’élément courant avec les éléments précédents jusqu’à ce que l’élément courant soit plus grand que l’élément précédent.\n\n\n\n\n\n\n\n\nExemple : Soit à trier le tableau \\([5,2,7,3]\\).\n\nOn commence par le deuxième élément du tableau, c’est-à-dire l’élément 2. On compare l’élément 2 avec l’élément 5. L’élément 2 est plus petit que l’élément 5, on échange les deux éléments. Le tableau est donc \\([2,5,7,3]\\).\nOn continue avec l’élément 7. L’élément 7 est plus grand que l’élément 5, on ne fait rien.\nOn continue avec l’élément 3. L’élément 3 est plus petit que l’élément 7, on échange les deux éléments. Le tableau est donc \\([2,5,3,7]\\). On continue à comparer et échanger l’élément 3 avec les éléments précédents jusqu’à ce que l’élément 3 soit plus grand que l’élément 5. Le tableau est donc \\([2,3,5,7]\\). L’algorithme est terminé. Le tableau est trié.\n\n\n\nProgrammation\n\ndef tri_insertion(tableau: list) -&gt; list:\n    \"\"\"Tri en place par insertion le tableau passé en paramètre.\"\"\"\n1    for i in range(1, len(tableau)):\n2        j = i\n3        while j &gt; 0 and tableau[j] &lt; tableau[j-1]:\n4            tableau[j], tableau[j-1] = tableau[j-1], tableau[j]\n5            j -= 1\n    return tableau\n\n\n1\n\nOn commence à l’indice 1 qui correspond au deuxième élément du tableau.\n\n2\n\nOn stocke l’indice courant dans une variable j pour pouvoir le modifier.\n\n3\n\nTant que l’indice courant est supérieur à 0 et que l’élément courant est plus petit que l’élément précédent, on échange les deux éléments.\n\n4\n\nOn échange les deux éléments.\n\n5\n\nL’élément courant est maintenant l’élément précédent, on décrémente donc l’indice courant.\n\n\n\n\nTest de l’algorithme :\n\ntri_insertion([5, 2, 4, 6, 1, 3])\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nPreuve de terminaison\nMontrons que l’algorithme se termine.\nD’une part, il est certain que la boucle for, boucle bornée par nature, se termine. D’autre part, la boucle while se termine aussi. La variable j est un variant de boucle. À chaque itération, sa valeur diminue de 1 : elle finit donc toujours par atteindre 0.\nLa terminaison de l’algorithme est donc prouvée.\n\n\nPreuve de correction\nMontrons que l’algorithme trie bien le tableau.\nPour cela, considérons la propriété suivante : à chaque itération, le sous-tableau composé des i premiers éléments est trié. Montrons que cette propriété est un invariant de boucle.\n\nInitialisation : au début de l’algorithme, le sous-tableau composé uniquement du premier élément est trié.\nConservation : supposons que le le sous-tableau composé des i premiers éléments est trié : \\([e_0, e_1, \\ldots, e_{i-1}]\\) avec \\(e_0\\leqslant e_1\\leqslant \\ldots \\leqslant e_{i-1}\\). L’algorithme considère alors l’élément \\(e_i\\) et le compare avec les éléments précédents. Si \\(e_i\\) est plus petit que \\(e_{i-1}\\), on échange les deux éléments. On continue alors à comparer \\(e_i\\) avec les éléments précédents jusqu’à ce que \\(e_i\\) soit plus grand que l’élément précédent. Le sous-tableau composé des i+1 premiers éléments est alors trié.\nConclusion : à la fin de l’algorithme i a la valeur n-1 ce qui correspond à l’indice du dernier élément du tableau. Le sous-tableau composé des n premiers éléments est donc trié. Or, n est le nombre d’éléments du tableau, donc le tableau entier est trié.\n\nLa correction de l’algorithme est donc prouvée.\n\n\nComplexité\nOn recherche la complexité dans le pire des cas. Le pire des cas est le cas où le tableau de départ est rangé dans l’ordre décroissant.\nNotons \\(n\\) la taille du tableau de départ.\nLa boucle for comporte \\(n-1\\) itérations.\nDans le cas où le tableau de départ est rangé dans l’ordre décroissant, la boucle while comporte 1 opération, puis 2, puis 3, etc. jusqu’à \\(n-1\\) opérations pour la dernière itération. On obtient donc la somme suivante pour le nombre total d’opérations :\n\\[1+2+3+\\ldots+(n-1)=\\frac{n(n-1)}{2}\\]\nSachant que \\(\\frac{n(n-1)}{2} = \\frac{n^2-n}{2}\\), il s’agit donc d’une complexité quadratique, en \\(\\mathcal{O}(n^2)\\)."
  },
  {
    "objectID": "algo1/tris.html#tri-par-sélection",
    "href": "algo1/tris.html#tri-par-sélection",
    "title": "Algorithmes de tris",
    "section": "2. Tri par sélection",
    "text": "2. Tri par sélection\n\n\n\n\n\n\nLe principe\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\nEn commençant par le premier élément du tableau :\n\nOn recherche le plus petit élément parmi les éléments suivants du tableau.\nOn échange l’élément courant avec le plus petit élément.\n\n\n\nExemple : Soit à trier le tableau \\([5,2,3,7]\\).\n\nOn commence par le premier élément, 5. On recherche le plus petit élément parmi les éléments suivants du tableau, c’est-à-dire 2. On échange 5 et 2 : le tableau est maintenant \\([2,5,3,7]\\).\nL’élément courant est maintenant le deuxième du tableau, c’est donc encore 5. On recherche le plus petit élément parmi les éléments suivants du tableau, c’est-à-dire 3. On échange 5 et 3 : le tableau est maintenant \\([2,3,5,7]\\).\nL’élément courant est maintenant le troisième du tableau, c’est donc encore 5. On recherche le plus petit élément parmi les éléments suivants du tableau, mais aucun n’est plus petit que 5. On ne fait donc rien.\nL’élément courant est maintenant le dernier du tableau, c’est donc 7. On ne fait donc rien et le tableau est trié.\n\n\n\nProgrammation\n\ndef tri_selection(tableau: list) -&gt; list:\n    \"\"\"Trie en place par sélection le tableau passé en paramètre.\"\"\"\n1    for i in range(len(tableau)):\n2        min = i\n3        for j in range(i+1, len(tableau)):\n4            if tableau[j] &lt; tableau[min]:\n                min = j\n5        tableau[i], tableau[min] = tableau[min], tableau[i]\n    return tableau\n\n\n1\n\nOn commence à l’indice 0 qui correspond au premier élément du tableau.\n\n2\n\nOn stocke l’indice courant dans une variable min pour pouvoir le modifier.\n\n3\n\nOn parcourt le tableau à partir de l’indice i+1 jusqu’à la fin.\n\n4\n\nSi l’élément courant est plus petit que l’élément stocké dans min, on met à jour min.\n\n5\n\nOn échange les deux éléments.\n\n\n\n\nTest de l’algorithme :\n\ntri_selection([5, 2, 4, 6, 1, 3])\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nPreuve de terminaison\nL’algorithme se termine puisqu’il comporte deux boucles for qui sont toutes deux bornées par nature.\n\n\nPreuve de correction\nMontrons que l’algorithme trie bien le tableau.\nPour cela, considérons la propriété suivante : à chaque itération, le sous-tableau composé des i premiers éléments est trié. Montrons que cette propriété est un invariant de boucle.\n\nInitialisation : au début de l’algorithme, le sous-tableau composé uniquement du premier élément est trié.\nConservation : supposons que le le sous-tableau composé des i premiers éléments est trié : \\([e_0, e_1, \\ldots, e_{i-1}]\\) avec \\(e_0\\leqslant e_1\\leqslant \\ldots \\leqslant e_{i-1}\\). Par construction, tous les éléments suivants sont supérieurs à \\(e_{i-1}\\). L’algorithme considère alors l’élément \\(e_i\\) et le compare avec les éléments suivants. Si un élément est plus petit que \\(e_i\\), on échange les deux éléments. Le sous-tableau composé des i+1 premiers éléments est alors trié.\nConslusion : à la fin de l’algorithme i a la valeur n-1 ce qui correspond à l’indice du dernier élément du tableau. Le sous-tableau composé des n premiers éléments est donc trié. Or, n est le nombre d’éléments du tableau, donc le tableau entier est trié.\n\nLa correction de l’algorithme est donc prouvée.\n\n\nComplexité\nOn recherche la complexité dans le pire des cas. Le pire des cas est le cas où le tableau de départ est rangé dans l’ordre décroissant.\nNotons \\(n\\) la taille du tableau de départ.\nLa boucle for i comporte \\(n-1\\) itérations. La boucle for j comporte \\(n-1\\) itérations pour la première itération, puis \\(n-2\\) itérations pour la seconde itération, etc. jusqu’à 1 opération pour la dernière itération. On obtient donc la somme suivante pour le nombre total d’opérations :\n\\[n-1+(n-2)+(n-3)+\\ldots+1=\\frac{n(n-1)}{2}\\]\nSachant que \\(\\frac{n(n-1)}{2} = \\frac{n^2-n}{2}\\), il s’agit donc d’une complexité quadratique, en \\(\\mathcal{O}(n^2)\\)."
  },
  {
    "objectID": "algo1/tris.html#observation-expérimentale-de-la-complexité",
    "href": "algo1/tris.html#observation-expérimentale-de-la-complexité",
    "title": "Algorithmes de tris",
    "section": "3. Observation expérimentale de la complexité",
    "text": "3. Observation expérimentale de la complexité\n\nTri par insertion\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps = []\n# on applique le tri dans le pire des cas : tableau trié dans l'ordre décroissant\nfor n in tailles:\n    temps.append(timeit.timeit(\n        \"tri_insertion([n-k for k in range(n)])\",\n        globals=globals(),\n        number=1\n    ))\nplt.plot(tailles, temps)\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nTri par sélection\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps = []\n# on applique le tri dans le pire des cas : tableau trié dans l'ordre décroissant\nfor n in tailles:\n    temps.append(timeit.timeit(\n        \"tri_selection([n-k for k in range(n)])\",\n        globals=globals(),\n        number=1\n    ))\nplt.plot(tailles, temps)\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.show()\n\n\n\n\n\n\n\n\nDans les deux cas, la forme grossièrement parabolique de la courbe est caractéristique de la complexité quadratique."
  },
  {
    "objectID": "algo1/tris.html#compléments",
    "href": "algo1/tris.html#compléments",
    "title": "Algorithmes de tris",
    "section": "Compléments",
    "text": "Compléments\nSur le site interstices.info un article très complet sur les algorithmes de tri, avec des animations pour mieux comprendre."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spécialité NSI - Première",
    "section": "",
    "text": "Bienvenue !\nCe site est destiné à regrouper les cours et les exercices concernant l’enseignement de spécialité NSI de première du lycée Émile Duclaux d’Aurillac.\nLien vers l’ENT du lycée : https://cas.ent.auvergnerhonealpes.fr/login"
  },
  {
    "objectID": "reseaux/index.html",
    "href": "reseaux/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nTransmission de données dans un réseau. Protocoles de communication. Architecture d’un réseau\nMettre en évidence l’intérêt du découpage des données en paquets et de leur encapsulation. Dérouler le fonctionnement d’un protocole simple de récupération de perte de paquets (bit alterné). Simuler ou mettre en oeuvre un réseau.\nLe protocole peut être expliqué et simulé en mode débranché. Le lien est fait avec ce qui a été vu en classe de seconde sur le protocole TCP/IP. Le rôle des différents constituants du réseau local de l’établissement est présenté."
  },
  {
    "objectID": "reseaux/index.html#points-traités-dans-cette-séquence",
    "href": "reseaux/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nTransmission de données dans un réseau. Protocoles de communication. Architecture d’un réseau\nMettre en évidence l’intérêt du découpage des données en paquets et de leur encapsulation. Dérouler le fonctionnement d’un protocole simple de récupération de perte de paquets (bit alterné). Simuler ou mettre en oeuvre un réseau.\nLe protocole peut être expliqué et simulé en mode débranché. Le lien est fait avec ce qui a été vu en classe de seconde sur le protocole TCP/IP. Le rôle des différents constituants du réseau local de l’établissement est présenté."
  },
  {
    "objectID": "reseaux/reseaux_archi.html",
    "href": "reseaux/reseaux_archi.html",
    "title": "Architecture d’un réseau",
    "section": "",
    "text": "Ce cours a pour but de présenter la constitution classique d’un réseau et les équipements associés. La partie relative aux protocoles utilisés lors des échanges entre deux machines est détaillée dans le cours suivant.\nIl est basé sur le cours de LASSUS (2021)."
  },
  {
    "objectID": "reseaux/reseaux_archi.html#premier-réseau-local",
    "href": "reseaux/reseaux_archi.html#premier-réseau-local",
    "title": "Architecture d’un réseau",
    "section": "1. Premier réseau local",
    "text": "1. Premier réseau local\nAu sein du logiciel Filius, créons le réseau local ci-dessous :\n\n\n\n\n\nTestons le ping de la machine 192.168.0.1 vers la machine 192.168.0.3.\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1. La carte réseau et son adresse MAC\nChaque ordinateur sur le réseau dispose d’une adresse MAC (Media Access Control), qui est une valeur unique attribuée à sa carte réseau (Ethernet, Wifi, 4G, 5G, …) lors de sa fabrication en usine.\nCette adresse est codée sur 48 bits, présentés sous la forme de 6 octets en hexadécimal. Exemple : fc:aa:14:75:45:a5\nLes trois premiers octets correspondent au code du fabricant.\nUn site comme https://www.macvendorlookup.com/ vous permet de retrouver le fabricant d’une adresse MAC quelconque.\n\n\n1.2. Switch, hub, quelle différence ?\n\nAu sein d’un hub Ethernet (de moins en moins vendus), il n’y a aucune analyse des données qui transitent : il s’agit simplement d’un dédoublement des fils de cuivre (tout comme une multiprise électrique). L’intégralité des messages est donc envoyée à l’intégralité des ordinateurs du réseau, même s’ils ne sont pas concernés.\n\n\n\n\n\n\n\nAu sein d’un switch Ethernet, une analyse est effectuée sur la trame qui est à distribuer. Lors d’un branchement d’un nouvel ordinateur sur le switch, celui-ci récupère son adresse MAC, ce qui lui permet de trier les messages et de ne les distribuer qu’au bon destinataire."
  },
  {
    "objectID": "reseaux/reseaux_archi.html#un-deuxième-sous-réseau",
    "href": "reseaux/reseaux_archi.html#un-deuxième-sous-réseau",
    "title": "Architecture d’un réseau",
    "section": "2. Un deuxième sous-réseau",
    "text": "2. Un deuxième sous-réseau\nRajoutons un deuxième sous-réseau de la manière suivante (penser à bien renommer les switchs).\n\n\n\n\n\nComment relier ces deux sous-réseaux ?\nUne réponse pas si bête : avec un câble entre les deux switchs !\n\n\n\n\n\nTestons cette hypothèse en essayant d’envoyer un ping à la machine 192.168.1.2 depuis la machine 192.168.0.1.\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\n\n\n\n\nCela ne marche pas. L’ordinateur refuse d’envoyer le ping vers la machine 192.168.1.2.\n(nous le verrons plus loin : car elle n’est pas dans son sous-réseau)\n\n\n\nTemporairement, renommons la machine 192.168.1.2 en 192.168.0.33. Testons à nouveau le ping depuis la machine 192.168.0.1.\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\n\n\n\n\nCela marche. Les paquets sont bien acheminés.\n\n\n\nDans la deuxième situation, les machines sont considérées comme faisant partie du même sous-réseau. Dans la première situation, elles sont considérées comme faisant partie de deux sous-réseaux différents. Mais comment est-ce déterminé ? C’est ce que nous allons voir dans la suite.\n\n2.1. Notion de masque de sous-réseau\nDans Filius, lors de l’attribution de l’adresse IP à une machine, une ligne nous permet de spécifier le masque de sous-réseau (appelé simplement « Masque » dans Filius). C’est ce masque qui va permettre de déterminer si une machine appartient à un sous-réseau ou non, en fonction de son adresse IP.\n\n\n\n\n\n\n2.1.1 Explication basique\n\nSi le masque est 255.255.255.0, toutes les machines partageant les mêmes trois premiers nombres de leur adresse IP appartiendront au même sous-réseau. Comme ceci est le réglage par défaut de Filius, cela explique pourquoi 192.168.0.33 et 192.168.0.1 sont sur le même sous-réseau, et pourquoi 192.168.1.2 et 192.168.0.1 ne sont pas sur le même sous-réseau.\n\nDans cette configuration, 256 machines peuvent donc appartenir au même sous-réseau (ce n’est pas tout à fait le cas, car les adresses finissant par 0 ou par 255 sont réservées).\n\nSi le masque est 255.255.0.0, toutes les machines partageant les mêmes deux premiers nombres de leur adresse IP appartiendront au même sous-réseau.\n\nDans cette configuration, 65 536 machines peuvent être dans le même sous-réseau. (car 256^2=65536)\nExercice\n\nRenommons 192.168.0.33 en 192.168.1.2 et modifions son masque en 255.255.0.0.\nModifions aussi le masque de 192.168.0.1 en 255.255.0.0.\nTestons le ping de 192.168.0.1 vers 192.168.1.2.\n\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\n\n\n\n\nCela marche. Les deux machines appartiennent maintenant au même sous-réseau.\n\n\n\n\n\n2.1.2 Explication avancée\nLorsqu’une machine A veut envoyer un message à une machine B, elle doit déterminer si cette machine :\n\nappartient au même sous-réseau : auquel cas le message est envoyé directement via un ou plusieurs switchs.\nn’appartient pas au même sous-réseau : auquel cas le message doit d’abord transiter par un routeur (voir 3.)\n\nQuelle opération permet de distinguer cette appartenance à un même sous-réseau ?\nAppelons IP_A et IP_B les adresses IP respectives des machines A et B.\nAppelons M le masque de sous-réseau.\nNommons & l’opérateur de conjonction entre nombres binaires : il s’agit d’un ET bit à bit.\n\n\n\n\n\n\nPropriété\n\n\n\nA et B appartiennent au même sous-réseau ⇔ IP_A & M = IP_B & M\n\n\nExemple : considérons trois machines A, B, C d’IP respectives 192.168.129.10, 192.168.135.200 et 192.168.145.1, configurées avec un masque de sous-réseau égal à 255.255.248.0.\n\n\n\n\nmachine A\nmachine B\nmachine C\n\n\n\n\nIP\n192.168.129.10\n192.168.135.200\n192.168.145.1\n\n\nM\n255.255.248.0\n255.255.248.0\n255.255.248.0\n\n\nIP & M\n192.168.128.0\n192.168.128.0\n192.168.144.0\n\n\n\nRègles de calcul pour le ET bit à bit :\n\npour tout octet x, x & 255 = x et x & 0 = 0.\n129 & 248 s’écrit en binaire 10000001 & 11111000 qui vaut 10000000, soit 128 en décimal.\n\nConclusion : les machines A et B sont sous le même sous-réseau, mais pas la machine C.\n\n\n2.1.3 Cohérence entre les deux explications\nLorsqu’un masque de sous-réseau est égal à 255.255.255.0, l’opération de conjonction & avec chaque IP ne laissera intacts que les 3 premiers octets, le dernier sera égal à 0. Donc si deux adresses s’écrivent A.B.C.X et A.B.C.Y, elles appartiendront au même sous-réseau (c’est le cas de 192.168.0.33 et 192.168.0.1).\n\n\n\n2.2 Écriture des masques de sous-réseau : notation CIDR\nD’après ce qui précède, 2 informations sont nécessaires pour déterminer le sous-réseau auquel appartient une machine : son IP et le masque de sous-réseau.\nUne convention de notation permet d’écrire simplement ces deux renseignements : la notation CIDR.\nExemple : Une machine d’IP 192.168.0.33 avec un masque de sous-réseau 255.255.255.0 sera désignée par 192.168.0.33 / 24 en notation CIDR.\nLe suffixe / 24 signifie que le masque de sous-réseau commence par 24 bits consécutifs de valeur 1 : le reste des bits (donc 8 bits) est mis à 0.\nAutrement dit, ce masque vaut 11111111.11111111.11111111.00000000 , soit 255.255.255.0.\nDe la même manière, le suffixe / 16 donnera un masque de 11111111.11111111.00000000.00000000 , soit 255.255.0.0.\nOu encore, un suffixe / 21 donnera un masque de 11111111.11111111.11111000.00000000 , soit 255.255.248.0.\n\n\n2.3 Adresses IP et masques : ce qu’il faut retenir\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLes ordinateurs s’identifient sur les réseaux à l’aide d’une adresse IP (Internet Protocol).\nSuivant la norme IPv4, les adresses IP sont encodées sur 4 octets : on parle d’IPv4.\nChaque octet pouvant varier de la valeur (décimale) 0 à 255, cela signifie que les adresses IP théoriquement possibles vont de 0.0.0.0 à 255.255.255.255.\nIl y a donc \\(256^4=4 294 967 296\\) adresses possibles. On a longtemps cru que ce nombre serait suffisant. Ce n’est plus le cas, on est donc en train de passer sur des adresses à 6 octets (en hexadécimal) : voir la norme IPv6.\n\n\n\nExemple\n\n\n\nimage"
  },
  {
    "objectID": "reseaux/reseaux_archi.html#un-vrai-réseau-contenant-deux-sous-réseaux-distincts-la-nécessité-dun-routeur",
    "href": "reseaux/reseaux_archi.html#un-vrai-réseau-contenant-deux-sous-réseaux-distincts-la-nécessité-dun-routeur",
    "title": "Architecture d’un réseau",
    "section": "3. Un vrai réseau contenant deux sous-réseaux distincts : la nécessité d’un routeur",
    "text": "3. Un vrai réseau contenant deux sous-réseaux distincts : la nécessité d’un routeur\nNotre solution initiale (relier les deux switchs par un câble pour unifier les deux sous-réseaux) n’est pas viable à l’échelle d’un réseau planétaire.\nPour que les machines de deux réseaux différents puissent être connectées, on va utiliser un dispositif équipé de deux cartes réseaux, situé à cheval entre les deux sous-réseaux. Cet équipement de réseau est appelé routeur ou passerelle.\n\n\n\n\n\n\n3.1 Principe de fonctionnement\nImaginons que la machine 192.168.0.1 / 24 veuille communiquer avec la machine 172.16.52.3 / 24.\nL’observation du masque de sous-réseau de la machine 192.168.0.1 / 24 nous apprend qu’elle ne peut communiquer qu’avec les adresses de la forme 192.168.0.X / 24, où X est un nombre entre 0 et 255.\nLes 3 étapes du routage :\n\nLorsque qu’une machine A veut envoyer un message à une machine B, elle va tout d’abord vérifier si cette machine appartient à son réseau local. Si c’est le cas, le message est envoyé par l’intermédiaire du switch qui relie les deux machines.\nSi la machine B n’est pas trouvée sur le réseau local de la machine A, le message va être acheminé vers le routeur, par l’intermédiaire de son adresse de passerelle (qui est bien une adresse appartenant au sous-réseau de A).\nDe là, le routeur va regarder si la machine B appartient au deuxième sous-réseau auquel il est connecté. Si c’est le cas, le message est distribué, sinon, le routeur va donner le message à un autre routeur auquel il est connecté et va le charger de distribuer ce message : c’est le procédé (complexe) de routage qui sera abordé en classe de Terminale.\n\nDans notre exemple, l’adresse 172.16.52.3 n’est pas dans le sous-réseau de 192.168.0.1. Le message va donc transiter par le routeur.\n\n\n\n\n\n\n\n3.2 Illustration avec Filius\n\nRajoutons un routeur entre le SwitchA et le SwitchB. \nConfiguration du routeur :\n\nL’interface reliée au Switch A doit avoir une adresse du sous-réseau A. On donne souvent une adresse finissant par 254, qui est en quelque sorte la dernière adresse du réseau (en effet l’adresse en 255 est appelée adresse de broadcast, utilisée pour envoyer un ping en une seule fois à l’intégralité d’un sous-réseau).\n\nOn donne donc l’adresse 192.168.0.254 pour l’interface reliée au Switch A, et 192.168.1.254 pour l’interface reliée au Switch B.\n\n\n\n\n\n\n\nDans l’onglet général, sélectionner « Routage automatique ».\nAinsi configuré notre routeur peut jouer le rôle de passerelle entre les deux sous-réseaux.\n\n\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\n\n\n\n\nCela ne marche pas. La carte réseau refuse d’envoyer les paquets, car elle ne sait pas où les envoyer.\n\n\n\nPourquoi cet échec ? Parce que nous devons dire à chaque machine qu’une passerelle est maintenant disponible pour pouvoir sortir de son propre sous-réseau. Il faut donc aller sur la machine 192.168.0.1 et lui donner l’adresse de sa passerelle, qui est 192.168.0.254.\n\n\n\n\n\nAttention, il faut faire de même pour 192.168.1.2 (avec la bonne passerelle…)\nTestons à nouveau le ping… Cette fois cela marche.\nPlus intéressant : effectuons un traceroute entre 192.168.0.1 et 192.168.1.2.\n\n\n\n\n\nOn constate que la machine 192.168.1.2 est atteignable en deux sauts depuis 192.168.0.1, en passant par la passerelle 192.168.0.254\nCas d’un réseau domestique\nChez vous, la box de votre opérateur joue simultanément le rôle de switch et de routeur :\n\nswitch, car elle répartit la connexion entre les différents dispositifs (ordinateurs branchés en ethernet, smartphone en wifi, tv connectée…)\nrouteur, car elle fait le lien entre ce sous-réseau domestique (les appareils de votre maison) et le réseau internet.\n\n\n\n\n\n\nL’image ci-dessous présente le résultat de la commande ipconfig sous Windows. On y retrouve l’adresse IP locale 192.168.9.103, le masque de sous-réseau 255.255.255.0 et l’adresse de la passerelle 192.168.9.1.\n\n\n\n3.3 Annexe : rajout d’un serveur DNS\n\n3.3.1 Ajout d’un serveur web\n\nConnectons un ordinateur au SwitchB, sur l’adresse 192.168.1.30 et installons dessus un Serveur web et démarrons-le. \nSur la machine 192.168.0.1, rajoutons un Navigateur Web. En tapant dans la barre d’adresse l’adresse IP du Serveur web, la page d’accueil de Filius s’affiche.\n\n\nLors d’une utilisation classique d’un navigateur web, c’est une url mémorisable qui s’affiche, et non une adresse IP : on retient en effet plus facilement https://www.google.com/ que http://216.58.213.131, qui renvoient pourtant à la même adresse.\nLa machine qui assure ce rôle d’annuaire entre les serveurs web et leur adresse IP s’appelle un serveur DNS. Pour pouvoir indexer la totalité des sites internet, son rôle est structuré de manière hiérarchique.\n\n\n3.3.1 Ajout d’un serveur DNS\n\nRajoutons un serveur DNS minimal, qui n’aura dans son annuaire d’un seul site. Il faut pour cela raccorder une nouvelle machine (mais une machine déjà sur le réseau aurait très bien pu jouer ce rôle), et installer dessus un serveur DNS.\n\nSur ce serveur DNS, associons l’adresse http://www.vivelansi.fr à l’adresse IP 192.168.1.30.\n\nDe retour sur notre machine 192.168.0.1, spécifions maintenant l’adresse du serveur DNS :\n\nDepuis le navigateur web de la machine 192.168.0.1, le site http://www.vivelansi.fr est maintenant accessible."
  },
  {
    "objectID": "reseaux/reseaux_protocole.html",
    "href": "reseaux/reseaux_protocole.html",
    "title": "Protocoles de communication",
    "section": "",
    "text": "Ce cours est basé sur le cours de LASSUS (2021)."
  },
  {
    "objectID": "reseaux/reseaux_protocole.html#modèle-osi-modèle-internet",
    "href": "reseaux/reseaux_protocole.html#modèle-osi-modèle-internet",
    "title": "Protocoles de communication",
    "section": "1. Modèle OSI, modèle Internet",
    "text": "1. Modèle OSI, modèle Internet\nLes bits transmis d’un ordinateur à un autre contiennent, en plus des données utiles (le mot «bonjour» dans un email), une multitude de données (tout aussi utiles) qui vont aider à l’acheminement de ces bits au bon endroit, puis au bon ordinateur, puis au bon logiciel. Les différents protocoles qui régissent cette transmission sont regroupés dans ce qui est appelé un modèle. Deux modèles synthétisent ces protocoles :\n\nle modèle Internet (ou modèle TCP/IP, 1974), organisé en 4 couches : liaison, réseau, transport, application.\nle modèle OSI (Open Systems Interconnection, 1984), organisé en 7 couches : physique, liaison, réseau, transport, session, présentation,application.\n\nCes deux modèles coïncident suivant le schéma ci-dessus. Ce sont des modèles théoriques. Leur utilisation dans la pratique est parfois plus floue, avec des protocoles à cheval sur plusieurs couches.\nDans la suite de ce cours, nous évoquerons les couches par leur numéro dans le modèle OSI.\n\n\n\n\n\nLors de son émission, un message va subir successivement toutes les transformations effectuées par chaque couche, depuis sa création (couche 7) jusqu’à sa transmission physique (couche 1).\nLorsque ce même message sera réceptionné, les transformations seront effectuées dans l’ordre inverse, jusqu’à la présentation du message au destinataire.\n\n\n\n\n\n\ncouches 7-6-5 — couches application-présentation-session : Ces couches (réunies dans le modèle Internet en une couche unique «application» ) regroupent les protocoles nécessaires à la bonne mise en forme d’un message (au sens large) avant sa transmission. Ces protocoles peuvent être de nature très différente : protocole HTTP pour la transmisson de pages web, protocole FTP pour le transfert de fichiers, protocoles POP ou IMAP pour le courrier électronique… \ncouche 4 — couche transport :\nLe protocole majeur de cette couche est le protocole TCP :\n\nil s’assure par SYN-ACK que l’émetteur et le récepteur sont prêts à échanger des messages.\nil découpe en segments numérotés le message à transmettre (côté émetteur) ou bien recompose le message total en remettant les segments dans l’ordre (côté récepteur).\nLes éléments échangés avec la couche inférieure sont des segments. \n\ncouche 3 — couche réseau :\nC’est la couche où chaque segment numéroté est encapsulé dans un paquet qui, suivant le protocole IP, va contenir son adresse source et son adresse de destination. C’est à ce niveau que se décide si le message doit rester dans le réseau local ou être envoyé sur un autre réseau via la passerelle du routeur.\nLes éléments échangés avec la couche inférieure sont des paquets. \ncouche 2 — couche liaison :\nC’est l’encapsulation finale du message. Suivant le protocole Ethernet, les informations sont transmises d’une carte réseau à une autre, grâce à leur adresse MAC (Media Access Controler).\nLes éléments échangés avec la couche inférieure sont des trames. \ncouche 1 — couche physique :\nC’est la couche où le message est transmis physiquement d’un point à un autre. Par signal lumineux (fibre optique), par ondes (wifi), par courant électrique (Ethernet)… Les éléments transmis sont les bits.\n\nLors de son parcours, une trame peut être partiellement décapsulée et remonter à la couche 3, avant de redescendre et de continuer son chemin. C’est le cas notamment lors du passage dans un routeur. Mais jamais, lors de son acheminement, le contenu réel du message n’est ouvert : les paquets transmis sont acheminés de manière identique, qu’ils contiennent les éléments constitutifs d’une vidéo YouTube ou d’un email à votre cousin."
  },
  {
    "objectID": "reseaux/reseaux_protocole.html#observation-des-trames-avec-filius",
    "href": "reseaux/reseaux_protocole.html#observation-des-trames-avec-filius",
    "title": "Protocoles de communication",
    "section": "2. Observation des trames avec Filius",
    "text": "2. Observation des trames avec Filius\n\n2.1. Ping à travers un switch\nVous pouvez télécharger le fichier ping_switch.fls.\n\nRelions une machine 192.168.0.10 d’adresse MAC BC:81:81:42:9C:31 à une machine 192.168.0.11 d’adresse MAC 2A:AB:AC:27:D6:A7 à travers un switch.\n\n\n\n\n\n\n\nObservons la table SAT de notre switch : elle est vide, car aucune machine n’a encore cherché à communiquer.\n\n\n\n\n\n\n\nLançons un ping depuis 192.168.0.10 vers 192.168.0.11 et observons les données échangées :\n\n\n\n\n\n\n\nObservons de plus près la première ligne de données échangées.\n\n\n\n\n\n\nCette première ligne est une requête ARP. ARP est un protocole qui s’interface entre la couche 3 / réseau (appelée dans la capture d’écran Internet) et la couche 2 / liaison (appelée dans la capture d’écran Réseau). Comme indiqué dans le commentaire, elle consiste à un appel à tout le réseau : “Est-ce que quelqu’un ici possède l’IP 192.168.0.11 ?\nMessage 1 : « Qui possède l’IP 192.168.0.11 ? »\nIl faut comprendre à cette étape que l’adresse IP est totalement inutile pour répérer un ordinateur dans un sous-réseau. Ce sont les adresses MAC qui permettent de se repérer dans un sous-réseau. Les adresses IP, elles, permettront éventuellement d’acheminer le message jusqu’au bon sous-réseau (elles n’intéressent donc que les routeurs).\nRevenons à notre ping vers 192.168.0.11.\nLa commande arp -a effectuée dans un terminal de la machine 192.168.0.10 nous permet de voir qu’elle ne connaît encore personne dans son sous-réseau. La table de correspondance IP ⮀ MAC ne contient que l’adresse de broadcast 255.255.255.255, qui permet d’envoyer un message à tout le réseau.\n\nConstatant qu’elle ne sait pas quelle est l’adresse MAC de 192.168.0.11, la machine 192.168.0.10 commence donc par envoyer un message à tout le sous-réseau, par l’adresse MAC de broadcast FF:FF:FF:FF:FF:FF. Le switch va lui aussi relayer ce message à tous les équipements qui lui sont connectés (dans notre cas, un seul ordinateur).\nMessage 2 : « Moi ! »\nLa machine 192.168.0.11 s’est reconnue dans le message de broadcast de la machine 192.168.0.10. Elle lui répond pour lui donner son adresse MAC.\n\n\n\n\n\nÀ partir de ce moment, la machine 192.168.0.10 sait comment communiquer avec 192.168.0.11. Elle l’écrit dans sa table arp, afin de ne plus avoir à émettre le message n°1 :\n\n\n\n\n\nLe switch, qui a vu passer sur ses ports 0 et 1 des messages venant des cartes MAC BC:81:81:42:9C:31 et 2A:AB:AC:27:D6:A7, peut mettre à jour sa table SAT :\n\n\n\n\n\nPar la suite, il saura sur quel port rediriger les messages destinés à ces deux adresses MAC. Un switch est un équipement de réseau de la couche 2 du modèle OSI, il ne sait pas lire les adresses IP : il ne travaille qu’avec les adresses MAC.\nMessage 3 : le ping est envoyé\n\n\n\n\n\nSchématisons cette trame Ethernet (couche 2 du modèle OSI) :\n\n\n\n\n\nMessage 4 : le pong est retourné\n\n\n\n\n\n\n\n\n\n\n\n\n2.2. Ping à travers un routeur\nVous pouvez télécharger le fichier ping_routeur.fls.\n\n\n\n\n\nL’objectif est d’observer les différentes trames lors d’un ping entre :\n\nla machine 192.168.0.1 / 24 (adresse MAC F9:E1:D6:0B:29:03 ) et\nla machine 192.168.1.1 / 24 (adresse MAC D3:79:96:B8:5C:A4 )\n\nLe routeur est configuré ainsi :\n\ninterface sur le réseau A :\n\nIP : 192.168.0.254\nMAC : 77:C2:22:C9:5C:E7\n\ninterface sur le réseau B :\n\nIP : 192.168.1.254\nMAC : 66:E5:4E:7D:0B:B0\n\n\nÉtape 0 : le routeur signale sa présence\nLors de l’observation des messages reçus ou émis par la machine 192.168.0.1, on peut être intrigué par ce tout premier message reçu, émis par le routeur :\n\n\n\n\n\nOn peut y distinguer les 4 couches du modèle Internet. Le routeur, par ce message distribué à tous les éléments du sous-réseau A (il envoie un message équivalent sur son sous-réseau B), déclare sa présence, et le fait qu’il possède deux interfaces, une pour chaque réseau. Il se positionne ainsi comme une passerelle : «c’est par moi qu’il faudra passer si vous voulez sortir de votre sous-réseau». Dans cette trame envoyée figure son adresse MAC, de sorte que tous les membres de son sous-réseau pourront donc communiquer avec lui.\nÉtape 1 : de 192.168.0.1 vers le routeur\nLa machine 192.168.0.1 / 24 calcule que la machine 192.168.1.1 / 24 avec laquelle elle veut communiquer n’est pas dans son sous-réseau. Elle va donc envoyer son message à sa passerelle, qui est l’adresse du routeur dans son sous-réseau.\nCette première trame est :\n\n\n\n\n\nÉtape 2 : le routeur décapsule la trame\nLe routeur est un équipement de réseau de couche 3 (couche réseau). Il doit observer le contenu du paquet IP (sans remonter jusqu’au contenu du message) pour savoir, suivant le procédé de routage (voir cours de Terminale), où acheminer ce paquet.\nDans notre cas, l’adresse IP 192.168.1.1de destination lui est accessible : elle fait partie de son sous-réseau B.\nLe routeur va modifier la valeur du TTL (Time To Live), en la décrémentant de 1. Si, après de multiples routages, cette valeur devenait égale à 0, ce paquet serait détruit. Ceci a pour but d’éviter l’encombrement des réseaux avec des paquets ne trouvant pas leur destination.\n\n\n\n\n\n\nNAT : translation d’adresse\n\n\n\nDans notre cas, le routeur va laisser intacte l’adresse IP Source. Ce n’est pas toujours le cas. Dans le cas classique de la box qui relie votre domicile à internet, le routeur contenu dans celle-ci va remplacer l’adresse locale de votre ordinateur ou smartphone (ex 192.168.0.26) par son IP publique (celle apparaissant sur whatsmyip.com, par exemple). Elle effectue ce qu’on appelle une translation d’adresse (NAT).\nPourquoi ? Parce que sinon la réponse du serveur distant que vous interrogez serait envoyée sur une adresse locale (votre adresse 192.168.0.26), qui est introuvable depuis un réseau extérieur. Il faut donc remplacer toutes les adresses locales par l’IP publique de votre box. Pour éviter que la réponse du serveur web que vous avez interrogé ne soit affichée sur l’ordinateur de vos parents, le routeur affecte des ports différents à chaque machine de son sous-réseau. Ce port est inclus dans le message transmis au serveur, et il l’est aussi dans sa réponse : le routeur peut donc rediriger le trafic vers la bonne machine du sous-réseau.\n\n\nLe routeur va ré-encapsuler le paquet IP modifié, et créer une nouvelle trame Ethernet en modifiant :\n\nl’adresse MAC source : il va mettre l’adresse MAC de son interface dans le sous-réseau B.\nl’adresse MAC de destination : il va mettre l’adresse MAC de 192.168.1.1 (qu’il aura peut-être récupérée au préalable par le protocole ARP)\n\nCette deuxième trame est donc :\n\n\n\n\n\nOn peut observer dans Filius cette trame, en se positionnant sur l’interface 192.168.1.254 du routeur, ou sur 192.168.1.1 :\n\n\n\n\n\nEn suivant le même principe, la machine 192.168.1.1 pourra envoyer son pong."
  },
  {
    "objectID": "reseaux/reseaux_protocole.html#protocole-du-bit-alterné",
    "href": "reseaux/reseaux_protocole.html#protocole-du-bit-alterné",
    "title": "Protocoles de communication",
    "section": "3. Protocole du bit alterné",
    "text": "3. Protocole du bit alterné\nCe protocole est un exemple simple de fiabilisation du transfert de données.\n\n1. Contexte\n\nAlice veut envoyer à Bob un message M, qu’elle a prédécoupé en sous-messages M0, M1, M2,…\nAlice envoie ses sous-messages à une cadence Δt fixée.\n\n\n\n2. Situation idéale\n\n\n\n\n\nDans cette situation, les sous-messages arrivent tous à destination dans le bon ordre. La transmission est correcte.\n\n\n3. Situation réelle\nMais parfois, les choses ne se passent pas toujours aussi bien. Car si on maîtrise parfaitement le timing de l’envoi des sous-messages d’Alice, on ne sait pas combien de temps vont mettre ces sous-messages pour arriver, ni même (attention je vais passer dans un tunnel) s’ils ne vont pas être détruits en route.\n\n\n\n\n\nLe sous-message M0 est arrivé après le M1, le message M2 n’est jamais arrivé…\nQue faire ?\nÉcartons l’idée de numéroter les sous-messages, afin que Bob puisse remettre dans l’ordre les messages arrivés, ou même redemander spécifiquement des sous-messages perdus. C’est ce que réalise le protocole TCP (couche 4 — transport), c’est très efficace, mais cher en ressources. Essayons de trouver une solution plus basique.\n\n\n3. Solution naïve…\nPourquoi ne pas demander à Bob d’envoyer un signal pour dire à Alice qu’il vient bien de recevoir son sous-message ? Nous appelerons ce signal ACK (comme acknowledgement, traduisible par «accusé de réception»). Ce signal ACK permettra à Alice de renvoyer un message qu’elle considérera comme perdu :\n\n\n\n\n\nN’ayant pas reçu le ACK consécutif à son message M1, Alice suppose (avec raison) que ce message n’est pas parvenu jusqu’à Bob, et donc renvoie le message M1.\n\n\n4. Mais peu efficace…\n\n\n\n\n\nLe deuxième ACK de Bob a mis trop de temps pour arriver (ou s’est perdu en route) et donc Alice a supposé que son sous-message M1 n’était pas arrivé. Elle l’a donc renvoyé, et Bob se retrouve avec deux fois le sous-message M1. La transmission est incorrecte. En faisant transiter un message entre Bob et Alice, nous multiplions par 2 la probabilité que des problèmes techniques de transmission interviennent. Et pour l’instant rien ne nous permet de les détecter.\n\n\n5. Bob prend le contrôle\nBob va maintenant intégrer une méthode de validation du sous-message reçu. Il pourra décider de le garder ou de l’écarter. Le but est d’éviter les doublons.\nPour réaliser ceci, Alice va rajouter à chacun de ses sous-messages un bit de contrôle, que nous appelerons FLAG (drapeau). Au départ, ce FLAG vaut 0. Quand Bob reçoit un FLAG, il renvoie un ACK égal au FLAG reçu.\nAlice va attendre ce ACK contenant le même bit que son dernier FLAG envoyé :\n\ntant qu’elle ne l’aura pas reçu, elle continuera à envoyer le même sous-message, avec le même FLAG.\ndès qu’elle l’a reçu, elle peut envoyer un nouveau sous-message en inversant («alternant») le bit de son dernier FLAG (d’où le nom de ce protocole).\n\nBob, de son côté, va contrôler la validité de ce qu’il reçoit : il ne gardera que les sous-messages dont le FLAG est égal à l’inverse de son dernier ACK. C’est cette méthode qui lui permettra d’écarter les doublons.\nObservons ce protocole dans plusieurs cas :\n\n5.1 Cas où le sous-message est perdu\n\n\n\n\n\n\n\n5.2 Cas où le ACK est perdu\n\n\n\n\n\nLe protocole a bien détecté le doublon du sous-message M1.\n\n\n5.3 Cas où un sous-message est en retard\n\n\n\n\n\nLe protocole a bien détecté le doublon du sous-message M1… mais que se passerait-il si notre premier sous-message M1 était encore plus en retard ?\n\n\n\n6. Conclusion\nLe protocole du bit alterné a longtemps été utilisé au sein de la couche 2 du modèle OSI (distribution des trames Ethernet). Simple et léger, il peut toutefois être facilement mis en défaut, ce qui explique qu’il ait été remplacé par des protocoles plus performants."
  },
  {
    "objectID": "ressources.html",
    "href": "ressources.html",
    "title": "Sources utilisées",
    "section": "",
    "text": "Pour rédiger ce cours et préparer les exercices, TP, projets présentés ici, j’ai utilisé de nombreuses sources que je vais essayer de citer ici, sans prétendre être exhaustif.\n\nDocuments d’accompagnement Eduscol.\nContenus du MOOC “Numérique et Sciences Informatiques : les fondamentaux” de l’INRIA, disponible sur la plateforme fun-mooc.\nApprendre à programmer avec Python 3, Gérard Swinnen, éditions Eyrolles, 2012. Disponible en ligne\nLe site interstices : https://interstices.info/.\nLes images et illustrations sont soit produites par mes soins, soit issues de Pixabay ou de Wikimedia commons ou encore de Pexels et, dans tous les cas, libres de droits.\nCours de David Roche.\nCours de Frédéric Junier.\nCours de Van Zuijlen Stéphan.\nCours de Konieczko Quentin\nCours de Olivier Lécluse\nCours du Lycée Blaise Pascal de Clermont-Ferrand\nCours du lycée Champollion de Grenoble\nCours du site Lyceum\nCours du site Mon Lycée Numérique\nCours du Lycée Stanislas de Wissembourg\nCours d’informatique de François Brucker (école Centrale de Marseille)\nCours de Philippe Rigaux sur les bases de données.\nCours de Gilles Lassus\nLe site MDN Web Docs : excellentissime ressource pour tout apprendre sur les langages HTML, CSS, Javascript et le protocole HTTP.\nLe site de M. JANVIER."
  },
  {
    "objectID": "tables/index.html",
    "href": "tables/index.html",
    "title": "S7-Traitement de données en tables",
    "section": "",
    "text": "Les données organisées en table correspondent à une liste de p-uplets nommés qui partagent les mêmes descripteurs. La mobilisation de ce type de structure de données permet de préparer les élèves à aborder la notion de base de données qui ne sera présentée qu’en classe terminale. Il s’agit d’utiliser un tableau doublement indexé ou un tableau de p-uplets, dans un langage de programmation ordinaire et non dans un système de gestion de bases de données.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nIndexation de tables\nImporter une table depuis un fichier texte tabulé ou un fichier CSV.\nEst utilisé un tableau doublement indexé ou un tableau de p-uplets qui partagent les mêmes descripteurs.\n\n\nRecherche dans une table\nRechercher les lignes d’une table vérifiant des critères exprimés en logique propositionnelle.\nLa recherche de doublons, les tests de cohérence d’une table sont présentés.\n\n\nTri d’une table\nTrier une table suivant une colonne.\nUne fonction de tri intégrée au système ou à une bibliothèque peut être utilisée.\n\n\nFusion de tables\nConstruire une nouvelle table en combinant les données de deux tables.\nLa notion de domaine de valeurs est mise en évidence."
  },
  {
    "objectID": "tables/index.html#programme",
    "href": "tables/index.html#programme",
    "title": "S7-Traitement de données en tables",
    "section": "",
    "text": "Les données organisées en table correspondent à une liste de p-uplets nommés qui partagent les mêmes descripteurs. La mobilisation de ce type de structure de données permet de préparer les élèves à aborder la notion de base de données qui ne sera présentée qu’en classe terminale. Il s’agit d’utiliser un tableau doublement indexé ou un tableau de p-uplets, dans un langage de programmation ordinaire et non dans un système de gestion de bases de données.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nIndexation de tables\nImporter une table depuis un fichier texte tabulé ou un fichier CSV.\nEst utilisé un tableau doublement indexé ou un tableau de p-uplets qui partagent les mêmes descripteurs.\n\n\nRecherche dans une table\nRechercher les lignes d’une table vérifiant des critères exprimés en logique propositionnelle.\nLa recherche de doublons, les tests de cohérence d’une table sont présentés.\n\n\nTri d’une table\nTrier une table suivant une colonne.\nUne fonction de tri intégrée au système ou à une bibliothèque peut être utilisée.\n\n\nFusion de tables\nConstruire une nouvelle table en combinant les données de deux tables.\nLa notion de domaine de valeurs est mise en évidence."
  },
  {
    "objectID": "tables/tables_cours.html",
    "href": "tables/tables_cours.html",
    "title": "Traitements de données en tables (cours)",
    "section": "",
    "text": "Définition\n\n\n\nDes données, numériques ou non, sont souvent représentées sous forme de tableaux, ou tables.\nVocabulaire :\n\nUne table, représentée sous forme de tableau, est une collection d’éléments qui sont les lignes du tableau.\nChaque élément de la table, ou ligne de sa représentation sous forme de tableau, s’appelle un enregistrement.\n\nTous les enregistrements d’une même table sont des p-uplets nommés qui partagent les mêmes descripteurs, appelés aussi attributs. Dans une représentation de la table sous forme de tableau, chaque attribut correspond à une colonne. Chaque attribut est caractérisé par son type et son domaine de valeurs (les valeurs que peut prendre cet attribut).\n\nDans une représentation sous forme de tableau, les descripteurs ou attributs sont en général placés comme en-tête de colonnes sur la première ligne.\n\n\n\n\n\n\ntableur\n\n\n\n\n\n\n\n\nExemple\n\n\n\nLa table représentée ci-dessus est affichée dans un tableur. Nous voyons les 20 premiers enregistrements de cette table qui rassemble des données sur tous les établissements scolaires primaires et secondaires dans le Cantal (source : https://www.data.gouv.fr/fr/).\nLes attributs de cette table sont :\n\nle code UAI (Unité Administrative Immatriculée) avec un domaine de valeurs particulier ;\nle nom avec pour domaine de valeur les chaînes de caractères ;\nle statut avec pour domaine de valeur les deux chaînes {“Public”, “Privé”} ;\nle codepostal avec un domaine de valeurs particulier ;\nla commune avec pour domaine de valeur les chaînes de caractères ;\nla latitude et la longitude avec pour domaine de valeur les flottants.\n\n\n\n\n\n\nPour échanger des données tabulaires entre les programmes qui doivent les manipuler, on les exporte puis les importe sous la forme de fichiers textes, c’est-à-dire lisibles par l’être humain.\nAfin d’assurer l’interopérabilité entre différents programmes, un fichier doit respecter un format normalisé.\nL’un des formats les plus répandus pour l’échange de données tabulaires est le format CSV pour Comma Separated Values :\n\nun fichier CSV est un fichier texte donc éditable avec un éditeur de textes comme Notepad++. On peut aussi l’éditer dans un tableur ;\nchaque ligne du fichier correspond à un enregistrement de la table ;\npour un enregistrement donné, les valeurs des différents attributs sont séparées en champs par un délimiteur qui est en général l’un des symboles , ou ; ou : ;\nla première ligne contient en général les noms des attributs.\n\nVoici la même table que celle qui est affichée dans un tableur ci-dessus, au format CSV :\n\n\netablissements.csv\n\ncode,nom,statut,codepostal,commune,latitude,longitude\n0150424E,Ecole maternelle de La Fontaine,Public,15000,AURILLAC,44.93215113696133,2.4472797795526975\n0150426G,Ecole élémentaire La Jordanne,Public,15000,AURILLAC,44.91746484780829,2.4412899019318455\n0150713U,Ecole élémentaire Belbex,Public,15000,AURILLAC,44.91692385174704,2.420740047835959\n0150669W,Ecole élémentaire de Canteloube,Public,15000,AURILLAC,44.90604342702414,2.4320205660195438\n0150695Z,Ecole élémentaire Paul Doumer,Public,15000,AURILLAC,44.92315413405051,2.4369699098202613\n0150708N,Collège privé Gerbert,Privé,15000,AURILLAC,44.915101259869516,2.4353907452880663\n0150082H,Ecole élémentaire privée Externat de L'Enfant-Jésus,Privé,15000,AURILLAC,44.925334485056936,2.4395702526084304\n0150430L,Ecole élémentaire Le Palais,Public,15000,AURILLAC,44.92790494767797,2.44295019912506\n0150431M,Ecole élémentaire Jean-Baptiste Rames,Public,15000,AURILLAC,44.92587579761087,2.443909493077494\n0150639N,Collège Jeanne de La Treilhe,Public,15000,AURILLAC,44.931332705102776,2.446920262863509\n0150340N,Ecole élémentaire Tivoli,Public,15000,AURILLAC,44.91458511629758,2.437120525044205\n0150420A,Ecole élémentaire des Frères Delmas,Public,15000,AURILLAC,44.93257502395094,2.448510197138493\n0150427H,Ecole élémentaire Les Alouettes,Public,15000,AURILLAC,44.931185754042616,2.4377296545614717\n0150760V,Lycée Polyvalent privé Gerbert,Privé,15000,AURILLAC,44.91492261677949,2.435849985504045\n0150761W,Section d'enseignement professionnel du Lycée privé Gerbert,Privé,15000,AURILLAC,44.91510125343173,2.435389478195114\n0150773J,Ecole élementaire privée La Calandreta del Vernhat,Privé,15000,AURILLAC,44.90477730883497,2.434630577068397\n0150006A,Lycée polyvalent Monnet-Mermoz - Lycée des métiers des sciences et techniques appliquées à l'industrie et aux services,Public,15005,AURILLAC CEDEX,44.93647192501501,2.4525295902159927\n0150036H,Section d'enseignement professionnel du Lycée Monnet-Mermoz,Public,15005,AURILLAC CEDEX,44.93588796606886,2.451329778620416\n0150646W,Lycée général Emile Duclaux,Public,15005,AURILLAC CEDEX,44.927782859640786,2.439440592922277\n\nOn observe que le délimiteur de champ est le symbole , et que les champs peuvent contenir des espaces.\nDans un tel jeu de données, il peut y avoir des champs vides dans certains enregistrements et il se peut aussi que le nombre de champs pour un ne corresponde pas au nombre d’attributs ! Pour traiter un tel fichier avec un programme, il faut d’abord analyser sa structure, ses particularités et prévoir d’éventuelles irrégularités dans les données (absence, erreurs de type, de saisie, corruption du fichier …). Le contrôle de la validité des données doit donc être une composante du programme de traitement : recherche de doublons, tests de cohérence.\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nL’indexation de table est la création d’une structure de données à partir d’une table de données.\nL’indexation d’une table extraite d’un fichier CSV peut se faire vers une structure de données du langage Python : tableau de tableaux ou (mieux) tableau de dictionnaires.\n\n\nDans cette section, on considère le fichier CSV, educ_cantal.csv, contenant les enregistrements des établissements scolaires primaires et secondaires dans le Cantal.\nPrésentons deux méthodes de lecture de fichiers CSV qui utilisent les outils standards de Python.\nOn fait les hypothèses suivantes : la première ligne du fichier contient les attributs et on connaît le délimiteur, ici le symbole ,.\n\n\n\n\nLecture\n\nOn peut extraire les attributs et la table contenus dans le fichier educ_cantal.csv avec le code ci-dessous :\n\n# ouverture du fichier en mode lecture\nfichier = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')\n# extraction de la ligne des attributs\nattributs = fichier.readline().rstrip().split(',')\n# extraction des autres lignes\ntable = [ligne.rstrip().split(',') for ligne in fichier]\n# fermeture du fichier\nfichier.close()\n\nLa fonction open permet de créer un objet fichier qu’on peut parcourir ligne par ligne avec un curseur : d’abord la première ligne avec fichier.readline() puis les lignes suivantes en itérant sur fichier. Il est important de préciser l’encodage du fichier, par défaut c’est celui du système d’exploitation.\nChaque ligne est une chaîne de caractères découpée en liste de champs selon le délimiteur passé en paramètre à la méthode split. Le caractère de saut de lignes a d’abord été supprimé avec la méthode rstrip.\nOn récupère ainsi les attributs comme un tableau de type list et la table comme un tableau d’enregistrements qui sont eux-mêmes des tableaux. Notons que toutes les valeurs sont des chaînes de caractères et qu’il faudra convertir certaines pour les traiter !\n\nprint(attributs)\nprint(table[18])\nprint(table[:2])\n\n['code', 'nom', 'statut', 'codepostal', 'id_commune', 'latitude', 'longitude']\n['0150030B', 'Lycée polyvalent de Haute Auvergne', 'Public', '15101', '187', '45.0352036275507', '3.0819798437208243']\n[['0150001V', 'Collège Maurice Peschaud', 'Public', '15160', '1', '45.230605740493495', '2.9353501250960568'], ['0150005Z', 'Collège La Jordanne', 'Public', '15005', '14', '44.92112535663867', '2.4404905355487023']]\n\n\n\nÉcriture\n\nOn peut ensuite recopier les attributs et la table dans un autre fichier educ_cantal_copie.csv avec le code ci-dessous :\n\ng = open('educ_cantal_copie.csv', mode='w', encoding='utf8', newline='') # ouverture du fichier en mode écriture\npremiere_ligne = ','.join(attributs) + '\\n'\ng.write(premiere_ligne)\nfor enregistrement in table:\n    g.write(','.join(enregistrement) + '\\n')\ng.close()\n\nLa méthode join permet de concaténer les éléments d’un tableau de chaînes de caractères avec un délimiteur.\n\nAvec ces méthodes, une table est donc représentée par un tableau de tableaux. On accède à un enregistrement par son index dans la table et à la valeur d’un attribut par son index dans le tableau des attributs (séparé de la table). C’est incommode et le code produit est peu lisible. Ainsi, pour accéder à l’adresse mail du premier enregistrement il faut saisir table[0][2]. On aimerait écrire table[0]['email']. Pour cela, chaque enregistrement devrait être un p-uplet nommé que nous représenterons par dictionnaire avec pour clefs les attributs de la table. C’est possible en utilisant le module csv.\n\n\n\n\nLe module csv est disponible dans la bibliothèque standard et peut donc être utilisé sans installation spécifique. À partir de la table contenu dans le même fichier CSV 'educ_cantal.csv', ce module permet de créer une structure de données d’un accès plus facile.\n\nLecture\n\nLe code ci-dessous permet d’extraire directement la table d’un fichier CSV dans une structure de données qui est un tableau de dictionnaires : chaque enregistrement est un dictionnaire dont les clefs sont les attributs listés sur la première ligne du fichier.\nRemarque : pour les versions de Python 3.6 et 3.7 uniquement, les dictionnaires renvoyés sont spécifiques, de type OrderedDict, et on prendra soin de les convertir en dictionnaires standard avec dict en entrant : table = [dict(enregistrement) for ...].\n\nimport csv\n\nf = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')\nreader = csv.DictReader(f, delimiter=',')  # création d'un objet reader\ntable = [enregistrement for enregistrement in reader]\nf.close()\n\nLa structure de données représentant la table est un tableau de dictionnaires : l’accès aux enregistrements se fait par index et à leurs attributs par clef : très efficace (coût constant) et code lisible. Notons que toutes les valeurs restent des chaînes de caractères et qu’il faudra convertir certaines pour les traiter !\n\n# premier enregistrement de type dictionnaire\nprint(table[18])\n# tableu de dictionnaires : extrait\nprint(table[:2])\n# nombre d'enregistrements\nprint(len(table))\n# accès facile aux valeurs des attributs par clefs\nprint(table[18][\"nom\"])\n\n{'code': '0150030B', 'nom': 'Lycée polyvalent de Haute Auvergne', 'statut': 'Public', 'codepostal': '15101', 'id_commune': '187', 'latitude': '45.0352036275507', 'longitude': '3.0819798437208243'}\n[{'code': '0150001V', 'nom': 'Collège Maurice Peschaud', 'statut': 'Public', 'codepostal': '15160', 'id_commune': '1', 'latitude': '45.230605740493495', 'longitude': '2.9353501250960568'}, {'code': '0150005Z', 'nom': 'Collège La Jordanne', 'statut': 'Public', 'codepostal': '15005', 'id_commune': '14', 'latitude': '44.92112535663867', 'longitude': '2.4404905355487023'}]\n203\nLycée polyvalent de Haute Auvergne\n\n\n\nÉcriture\n\nL’écriture d’un tableau de dictionnaires partageant les mêmes clefs sous forme de table dans un fichier CSV, s’effectue de façon symétrique à travers un objet DictWriter. À titre, d’exemple, on recopie la table extraite précédemment dans un autre fichier CSV. Depuis Python 3.7, le parcours des clefs d’un dictionnaire est garanti dans le même ordre que celui d’insertion donc on peut récupérer la liste des attributs avec list(table[0].keys())\n\ng = open('educ_cantal_copie2.csv', mode='w', encoding='utf8', newline='')\nattributs = list(table[0].keys())\nwriter = csv.DictWriter(g, delimiter=',', fieldnames=attributs)  # création de l'objet writer\nwriter.writeheader()  # écriture des attributs\nfor enregistrement in table:\n    writer.writerow(enregistrement)  # écriture des enregistrements\ng.close()\n\n\nRemarque\n\nLe module csv permet aussi d’extraire une table d’un fichier CSV sous forme de tableau de tableaux comme dans la méthode précédente. Le découpage des lignes/enregistrements selon le délimiteur est intégré ce qui simplifie le code.\n\nf = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')\nreader = csv.reader(f, delimiter=',')\ntable = [ligne for ligne in reader]\nf.close()"
  },
  {
    "objectID": "tables/tables_cours.html#table-de-données-et-indexation",
    "href": "tables/tables_cours.html#table-de-données-et-indexation",
    "title": "Traitements de données en tables (cours)",
    "section": "",
    "text": "Définition\n\n\n\nDes données, numériques ou non, sont souvent représentées sous forme de tableaux, ou tables.\nVocabulaire :\n\nUne table, représentée sous forme de tableau, est une collection d’éléments qui sont les lignes du tableau.\nChaque élément de la table, ou ligne de sa représentation sous forme de tableau, s’appelle un enregistrement.\n\nTous les enregistrements d’une même table sont des p-uplets nommés qui partagent les mêmes descripteurs, appelés aussi attributs. Dans une représentation de la table sous forme de tableau, chaque attribut correspond à une colonne. Chaque attribut est caractérisé par son type et son domaine de valeurs (les valeurs que peut prendre cet attribut).\n\nDans une représentation sous forme de tableau, les descripteurs ou attributs sont en général placés comme en-tête de colonnes sur la première ligne.\n\n\n\n\n\n\ntableur\n\n\n\n\n\n\n\n\nExemple\n\n\n\nLa table représentée ci-dessus est affichée dans un tableur. Nous voyons les 20 premiers enregistrements de cette table qui rassemble des données sur tous les établissements scolaires primaires et secondaires dans le Cantal (source : https://www.data.gouv.fr/fr/).\nLes attributs de cette table sont :\n\nle code UAI (Unité Administrative Immatriculée) avec un domaine de valeurs particulier ;\nle nom avec pour domaine de valeur les chaînes de caractères ;\nle statut avec pour domaine de valeur les deux chaînes {“Public”, “Privé”} ;\nle codepostal avec un domaine de valeurs particulier ;\nla commune avec pour domaine de valeur les chaînes de caractères ;\nla latitude et la longitude avec pour domaine de valeur les flottants.\n\n\n\n\n\n\nPour échanger des données tabulaires entre les programmes qui doivent les manipuler, on les exporte puis les importe sous la forme de fichiers textes, c’est-à-dire lisibles par l’être humain.\nAfin d’assurer l’interopérabilité entre différents programmes, un fichier doit respecter un format normalisé.\nL’un des formats les plus répandus pour l’échange de données tabulaires est le format CSV pour Comma Separated Values :\n\nun fichier CSV est un fichier texte donc éditable avec un éditeur de textes comme Notepad++. On peut aussi l’éditer dans un tableur ;\nchaque ligne du fichier correspond à un enregistrement de la table ;\npour un enregistrement donné, les valeurs des différents attributs sont séparées en champs par un délimiteur qui est en général l’un des symboles , ou ; ou : ;\nla première ligne contient en général les noms des attributs.\n\nVoici la même table que celle qui est affichée dans un tableur ci-dessus, au format CSV :\n\n\netablissements.csv\n\ncode,nom,statut,codepostal,commune,latitude,longitude\n0150424E,Ecole maternelle de La Fontaine,Public,15000,AURILLAC,44.93215113696133,2.4472797795526975\n0150426G,Ecole élémentaire La Jordanne,Public,15000,AURILLAC,44.91746484780829,2.4412899019318455\n0150713U,Ecole élémentaire Belbex,Public,15000,AURILLAC,44.91692385174704,2.420740047835959\n0150669W,Ecole élémentaire de Canteloube,Public,15000,AURILLAC,44.90604342702414,2.4320205660195438\n0150695Z,Ecole élémentaire Paul Doumer,Public,15000,AURILLAC,44.92315413405051,2.4369699098202613\n0150708N,Collège privé Gerbert,Privé,15000,AURILLAC,44.915101259869516,2.4353907452880663\n0150082H,Ecole élémentaire privée Externat de L'Enfant-Jésus,Privé,15000,AURILLAC,44.925334485056936,2.4395702526084304\n0150430L,Ecole élémentaire Le Palais,Public,15000,AURILLAC,44.92790494767797,2.44295019912506\n0150431M,Ecole élémentaire Jean-Baptiste Rames,Public,15000,AURILLAC,44.92587579761087,2.443909493077494\n0150639N,Collège Jeanne de La Treilhe,Public,15000,AURILLAC,44.931332705102776,2.446920262863509\n0150340N,Ecole élémentaire Tivoli,Public,15000,AURILLAC,44.91458511629758,2.437120525044205\n0150420A,Ecole élémentaire des Frères Delmas,Public,15000,AURILLAC,44.93257502395094,2.448510197138493\n0150427H,Ecole élémentaire Les Alouettes,Public,15000,AURILLAC,44.931185754042616,2.4377296545614717\n0150760V,Lycée Polyvalent privé Gerbert,Privé,15000,AURILLAC,44.91492261677949,2.435849985504045\n0150761W,Section d'enseignement professionnel du Lycée privé Gerbert,Privé,15000,AURILLAC,44.91510125343173,2.435389478195114\n0150773J,Ecole élementaire privée La Calandreta del Vernhat,Privé,15000,AURILLAC,44.90477730883497,2.434630577068397\n0150006A,Lycée polyvalent Monnet-Mermoz - Lycée des métiers des sciences et techniques appliquées à l'industrie et aux services,Public,15005,AURILLAC CEDEX,44.93647192501501,2.4525295902159927\n0150036H,Section d'enseignement professionnel du Lycée Monnet-Mermoz,Public,15005,AURILLAC CEDEX,44.93588796606886,2.451329778620416\n0150646W,Lycée général Emile Duclaux,Public,15005,AURILLAC CEDEX,44.927782859640786,2.439440592922277\n\nOn observe que le délimiteur de champ est le symbole , et que les champs peuvent contenir des espaces.\nDans un tel jeu de données, il peut y avoir des champs vides dans certains enregistrements et il se peut aussi que le nombre de champs pour un ne corresponde pas au nombre d’attributs ! Pour traiter un tel fichier avec un programme, il faut d’abord analyser sa structure, ses particularités et prévoir d’éventuelles irrégularités dans les données (absence, erreurs de type, de saisie, corruption du fichier …). Le contrôle de la validité des données doit donc être une composante du programme de traitement : recherche de doublons, tests de cohérence.\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nL’indexation de table est la création d’une structure de données à partir d’une table de données.\nL’indexation d’une table extraite d’un fichier CSV peut se faire vers une structure de données du langage Python : tableau de tableaux ou (mieux) tableau de dictionnaires.\n\n\nDans cette section, on considère le fichier CSV, educ_cantal.csv, contenant les enregistrements des établissements scolaires primaires et secondaires dans le Cantal.\nPrésentons deux méthodes de lecture de fichiers CSV qui utilisent les outils standards de Python.\nOn fait les hypothèses suivantes : la première ligne du fichier contient les attributs et on connaît le délimiteur, ici le symbole ,.\n\n\n\n\nLecture\n\nOn peut extraire les attributs et la table contenus dans le fichier educ_cantal.csv avec le code ci-dessous :\n\n# ouverture du fichier en mode lecture\nfichier = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')\n# extraction de la ligne des attributs\nattributs = fichier.readline().rstrip().split(',')\n# extraction des autres lignes\ntable = [ligne.rstrip().split(',') for ligne in fichier]\n# fermeture du fichier\nfichier.close()\n\nLa fonction open permet de créer un objet fichier qu’on peut parcourir ligne par ligne avec un curseur : d’abord la première ligne avec fichier.readline() puis les lignes suivantes en itérant sur fichier. Il est important de préciser l’encodage du fichier, par défaut c’est celui du système d’exploitation.\nChaque ligne est une chaîne de caractères découpée en liste de champs selon le délimiteur passé en paramètre à la méthode split. Le caractère de saut de lignes a d’abord été supprimé avec la méthode rstrip.\nOn récupère ainsi les attributs comme un tableau de type list et la table comme un tableau d’enregistrements qui sont eux-mêmes des tableaux. Notons que toutes les valeurs sont des chaînes de caractères et qu’il faudra convertir certaines pour les traiter !\n\nprint(attributs)\nprint(table[18])\nprint(table[:2])\n\n['code', 'nom', 'statut', 'codepostal', 'id_commune', 'latitude', 'longitude']\n['0150030B', 'Lycée polyvalent de Haute Auvergne', 'Public', '15101', '187', '45.0352036275507', '3.0819798437208243']\n[['0150001V', 'Collège Maurice Peschaud', 'Public', '15160', '1', '45.230605740493495', '2.9353501250960568'], ['0150005Z', 'Collège La Jordanne', 'Public', '15005', '14', '44.92112535663867', '2.4404905355487023']]\n\n\n\nÉcriture\n\nOn peut ensuite recopier les attributs et la table dans un autre fichier educ_cantal_copie.csv avec le code ci-dessous :\n\ng = open('educ_cantal_copie.csv', mode='w', encoding='utf8', newline='') # ouverture du fichier en mode écriture\npremiere_ligne = ','.join(attributs) + '\\n'\ng.write(premiere_ligne)\nfor enregistrement in table:\n    g.write(','.join(enregistrement) + '\\n')\ng.close()\n\nLa méthode join permet de concaténer les éléments d’un tableau de chaînes de caractères avec un délimiteur.\n\nAvec ces méthodes, une table est donc représentée par un tableau de tableaux. On accède à un enregistrement par son index dans la table et à la valeur d’un attribut par son index dans le tableau des attributs (séparé de la table). C’est incommode et le code produit est peu lisible. Ainsi, pour accéder à l’adresse mail du premier enregistrement il faut saisir table[0][2]. On aimerait écrire table[0]['email']. Pour cela, chaque enregistrement devrait être un p-uplet nommé que nous représenterons par dictionnaire avec pour clefs les attributs de la table. C’est possible en utilisant le module csv.\n\n\n\n\nLe module csv est disponible dans la bibliothèque standard et peut donc être utilisé sans installation spécifique. À partir de la table contenu dans le même fichier CSV 'educ_cantal.csv', ce module permet de créer une structure de données d’un accès plus facile.\n\nLecture\n\nLe code ci-dessous permet d’extraire directement la table d’un fichier CSV dans une structure de données qui est un tableau de dictionnaires : chaque enregistrement est un dictionnaire dont les clefs sont les attributs listés sur la première ligne du fichier.\nRemarque : pour les versions de Python 3.6 et 3.7 uniquement, les dictionnaires renvoyés sont spécifiques, de type OrderedDict, et on prendra soin de les convertir en dictionnaires standard avec dict en entrant : table = [dict(enregistrement) for ...].\n\nimport csv\n\nf = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')\nreader = csv.DictReader(f, delimiter=',')  # création d'un objet reader\ntable = [enregistrement for enregistrement in reader]\nf.close()\n\nLa structure de données représentant la table est un tableau de dictionnaires : l’accès aux enregistrements se fait par index et à leurs attributs par clef : très efficace (coût constant) et code lisible. Notons que toutes les valeurs restent des chaînes de caractères et qu’il faudra convertir certaines pour les traiter !\n\n# premier enregistrement de type dictionnaire\nprint(table[18])\n# tableu de dictionnaires : extrait\nprint(table[:2])\n# nombre d'enregistrements\nprint(len(table))\n# accès facile aux valeurs des attributs par clefs\nprint(table[18][\"nom\"])\n\n{'code': '0150030B', 'nom': 'Lycée polyvalent de Haute Auvergne', 'statut': 'Public', 'codepostal': '15101', 'id_commune': '187', 'latitude': '45.0352036275507', 'longitude': '3.0819798437208243'}\n[{'code': '0150001V', 'nom': 'Collège Maurice Peschaud', 'statut': 'Public', 'codepostal': '15160', 'id_commune': '1', 'latitude': '45.230605740493495', 'longitude': '2.9353501250960568'}, {'code': '0150005Z', 'nom': 'Collège La Jordanne', 'statut': 'Public', 'codepostal': '15005', 'id_commune': '14', 'latitude': '44.92112535663867', 'longitude': '2.4404905355487023'}]\n203\nLycée polyvalent de Haute Auvergne\n\n\n\nÉcriture\n\nL’écriture d’un tableau de dictionnaires partageant les mêmes clefs sous forme de table dans un fichier CSV, s’effectue de façon symétrique à travers un objet DictWriter. À titre, d’exemple, on recopie la table extraite précédemment dans un autre fichier CSV. Depuis Python 3.7, le parcours des clefs d’un dictionnaire est garanti dans le même ordre que celui d’insertion donc on peut récupérer la liste des attributs avec list(table[0].keys())\n\ng = open('educ_cantal_copie2.csv', mode='w', encoding='utf8', newline='')\nattributs = list(table[0].keys())\nwriter = csv.DictWriter(g, delimiter=',', fieldnames=attributs)  # création de l'objet writer\nwriter.writeheader()  # écriture des attributs\nfor enregistrement in table:\n    writer.writerow(enregistrement)  # écriture des enregistrements\ng.close()\n\n\nRemarque\n\nLe module csv permet aussi d’extraire une table d’un fichier CSV sous forme de tableau de tableaux comme dans la méthode précédente. Le découpage des lignes/enregistrements selon le délimiteur est intégré ce qui simplifie le code.\n\nf = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')\nreader = csv.reader(f, delimiter=',')\ntable = [ligne for ligne in reader]\nf.close()"
  },
  {
    "objectID": "tables/tables_cours.html#recherche-dans-une-table",
    "href": "tables/tables_cours.html#recherche-dans-une-table",
    "title": "Traitements de données en tables (cours)",
    "section": "2. Recherche dans une table",
    "text": "2. Recherche dans une table\nPour accéder aux données, il faut les rechercher et les regrouper suivant différents critères.\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLorsqu’on souhaite accéder à un ou plusieurs enregistrements vérifiant un critère, on réalise une sélection.\nLorsqu’on souhaite accéder à toutes les données d’une colonne on réalise une projection.\n\n\n\n\nExemple de sélection\nSupposons qu’on dispose d’une table enregistrée dans une liste de dictionnaires :\n\nTable1 = [\n    {'Nom': 'Joe', 'Anglais': '17', 'Info': '18', 'Maths': '16'},\n    {'Nom': 'Zoé', 'Anglais': '15', 'Info': '17', 'Maths': '19'},\n    {'Nom': 'Max', 'Anglais': '19', 'Info': '13', 'Maths': '14'},\n    {'Nom': 'Bob', 'Anglais': '12', 'Info': '16', 'Maths': '10'}\n]\n\nOn souhaite extraire la liste des enregistrements des élèves ayant eu au moins 16 en maths.\nOn peut le faire “à la main” :\n\nau_moins_16_en_maths = []\nfor enregistrement in Table1:\n    if int(enregistrement['Maths']) &gt;= 16:\n        au_moins_16_en_maths.append(enregistrement)\n\nLe résultat est encore une table :\n\nau_moins_16_en_maths\n\n[{'Nom': 'Joe', 'Anglais': '17', 'Info': '18', 'Maths': '16'},\n {'Nom': 'Zoé', 'Anglais': '15', 'Info': '17', 'Maths': '19'}]\n\n\nOn peut le faire avec une liste en compréhension :\n\nau_moins_16_en_maths = [enre for enre in Table1 if int(enre['Maths']) &gt;= 16]\n\nLe résultat est identique.\n\n\nExemple de projection\nCette fois, on souhaite récupérer toutes les valeurs pour un champ donné, par exemple toutes les notes de mathématiques.\nL’approche est similaire, on crée une liste, on parcourt la table et on ajoute à la liste tous les éléments qui nous intéressent.\n\nà la main :\n\n\nnotes_maths = []\nfor enregistrement in Table1:\n    notes_maths.append(enregistrement['Maths'])\n\n\npar compréhension :\n\n\nnotes_maths = [enre['Maths'] for enre in Table1]\n\nDans les deux cas le résultat est la liste [‘16’, ‘19’, ‘14’, ‘10’].\n\n\n\n\n\n\nExercices\n\n\n\n\nAdapter la sélection afin de récupérer tous les enregistrements des élèves dont le nom comporte un “o”.\nProjeter afin de construire la liste des noms puis celle des paires de notes d’info et de maths :\n[(18, 16), (17, 19), (13, 14), (16, 10)]\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nAvec une boucle :\n\n\nnom_avec_o = []\nfor enregistrement in Table1:\n    if 'o' in enregistrement['Nom']:\n        nom_avec_o.append(enregistrement)\n\nEn compréhension :\n\nnom_avec_o = [enre for enre in Table1 if 'o' in enre['Nom']]\n\n\nListe des noms :\n\n\n# avec une boucle\nliste_noms = []\nfor enregistrement in Table1:\n    liste_noms.append(enregistrement['Nom'])\n\n# avec une liste en compréhension\nliste_noms = [enre['Nom'] for enre in Table1]\n\npaires info/maths\n\n# avec une boucle\nliste_paires = []\nfor enregistrement in Table1:\n    liste_paires.append((enregistrement['Info'], enregistrement['Maths']))\n\n# avec une liste en compréhension\nliste_paires = [(enre['Info'], enre['Maths']) for enre in Table1]"
  },
  {
    "objectID": "tables/tables_cours.html#tri-dune-table",
    "href": "tables/tables_cours.html#tri-dune-table",
    "title": "Traitements de données en tables (cours)",
    "section": "3. Tri d’une table",
    "text": "3. Tri d’une table\n\n3.1. Tri d’une table selon une colonne\nIl s’agit ici de trier les données d’une table selon un des attributs de la table, c’est-à-dire selon une colonne. Il faut bien sûr pour cela que les données de cet attribut soient “triables”, c’est-à-dire qu’un ordre puisse être défini sur ces données. Pour des données numériques, on peut penser à l’ordre croissant ou à l’ordre décroissant. Pour des données textuelles, à l’ordre alphabétique. On peut aussi vouloir trier les données selon plusieurs champs.\nNous allons pour cela utiliser la fonction Python sorted qui s’applique à un objet de type list et qui renvoie une nouvelle list triée. Outre la table à trier, cette fonction peut prendre deux arguments nommés facultatifs :\n\nreverse = True pour un tri dans l’ordre inverse ;\nkey = ... pour préciser selon quel critère une liste doit être triée.\n\nQuelques exemples :\n\nma_liste = [10, 3, 71, 96]\nprint(sorted(ma_liste))\nprint(sorted(ma_liste, reverse=True))\n\nmes_couples = [('a', 3), ('d', 2), ('c', 5), ('b', 1)]\nprint(sorted(mes_couples))     # tuples triés selon leur premier élément (par défaut)\n\ndef y(couple):    # on définit une fonction qui retourne le second élément d'un tuple\n    return couple[1]\n\nprint(sorted(mes_couples, key=y)) # tuples triés selon leur second élément\n\n[3, 10, 71, 96]\n[96, 71, 10, 3]\n[('a', 3), ('b', 1), ('c', 5), ('d', 2)]\n[('b', 1), ('d', 2), ('a', 3), ('c', 5)]\n\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention, sorted ne renvoie qu’une copie superficielle du tableau ! Si ses éléments sont des références et c’est le cas de l’implémentation des tables de données sous forme de tableaux de dictionnaires, il faut effectuer une copie profonde du tableau avec la fonction deepcopy du module copy pour obtenir une vraie copie triée du tableau initial : sorted(deepcopy(tab), key = clef_tri).\n\n\n\n\n3.2. Tri suivant plusieurs colonnes\nConsidérons la table suivante :\n\ntable = [{'élève' : 'guido', 'langage' : 'python', 'note' : 19},\n         {'élève' : 'monty', 'langage' : 'python', 'note' : 20},\n         {'élève' : 'brian', 'langage' : 'c', 'note' : 20}]\n\nOn souhaite trier en fonction du langage dans l’ordre alphabétique, puis de la note dans l’ordre croissant. La fonction donnée en argument key doit alors retourner la couple ordonné des deux attributs voulus :\n\ndef cle_langage_note(enre):\n    return (enre['langage'], enre['note'])\n\nsorted(table, key = cle_langage_note)\n\n[{'élève': 'brian', 'langage': 'c', 'note': 20},\n {'élève': 'guido', 'langage': 'python', 'note': 19},\n {'élève': 'monty', 'langage': 'python', 'note': 20}]\n\n\nSi l’on souhaite trier dans l’ordre croissant suivant l’attribut langage et décroissant suivant l’attribut note, on procède en deux étapes :\n\ndef cle_langage(enre):\n    return enre['langage']\n\ndef cle_note(enre):\n    return enre['note']\n\ntable_temp = sorted(table, key = cle_langage)\nsorted(table_temp, key = cle_note, reverse = True)\n\n[{'élève': 'brian', 'langage': 'c', 'note': 20},\n {'élève': 'monty', 'langage': 'python', 'note': 20},\n {'élève': 'guido', 'langage': 'python', 'note': 19}]"
  },
  {
    "objectID": "tables/tables_cours.html#fusion-de-deux-tables",
    "href": "tables/tables_cours.html#fusion-de-deux-tables",
    "title": "Traitements de données en tables (cours)",
    "section": "4. Fusion de deux tables",
    "text": "4. Fusion de deux tables\nIl est courant de travailler avec plusieurs tables de données. Nous avons alors parfois besoin de rassembler deux tables en une seule ou encore de construire une nouvelle table à partir de certains attributs de tables existantes.\n\n4.1. Fusion de deux tables de même structure\nLe cas le plus simple est lorsque nous disposons de deux tables, par exemple sous la forme de tableaux de dictionnaires, qui possèdent exactement les mêmes attributs.\nUne simple concaténation des tableaux permet cette fusion, en prenant garde néanmoins :\n\nà ne pas conserver deux fois la définition des descripteurs ;\nà éviter les doublons : cas d’un enregistrement qui se trouverait dans les deux tables initiales.\n\nSous l’hypothèse qu’il n’y a pas de doublons, le code ci-dessous procède à cette fusion :\n\ndef fusion_tables(table1: list, table2: list) -&gt; list:\n    \"\"\"table 1 et table 2 ont les mêmes descripteurs\n    il n'y a pas de doublons\"\"\"\n    fusion = deepcopy(table1)\n    for enreg in table2[1:]:    # on élimine la première ligne (descripteurs)\n        fusion.append(deepcopy(enreg))\n    return fusion\n\n\n\n4.2. Fusion de deux tables pour un même attribut\nOn veut fusionner deux tables selon un attribut commun. On va sélectionner dans chaque table la ligne ayant la même valeur pour l’attribut choisi.\nReprenons le tableau Table1 des exemples précédents :\n\n\n\nNom\nAnglais\nInfo\nMaths\n\n\n\n\nJoe\n17\n18\n16\n\n\nZoé\n15\n17\n19\n\n\nMax\n19\n13\n14\n\n\n\nDéfinissons une seconde table, Table2 donnant l’âge et le courriel de certains élèves :\n\n\n\nNom\nAge\nCourriel\n\n\n\n\nJoe\n16\njoe@info.fr\n\n\nZoé\n15\nzoe@info.fr\n\n\n\nOn voudrait regrouper les données des deux tables. Elles ont l’attribut Nom en commun. On veut obtenir la table suivante :\n\n\n\nNom\nAge\nCourriel\nAnglais\nInfo\nMaths\n\n\n\n\nJoe\n16\njoe@info.fr\n17\n18\n16\n\n\nZoé\n15\nzoe@info.fr\n15\n17\n19\n\n\n\nOn choisit d’exclure la ligne concernant Max car il n’est pas présent dans la seconde table.\n\n\n\n\n\n\nDéfinition\n\n\n\nEn informatique, la jointure est l’opération permettant d’associer plusieurs tables par le biais d’un lien logique de données entre les différentes tables, le lien étant défini par une condition. Le résultat de l’opération est une nouvelle table.\n\n\nLa jointure s’obtient avec deux boucles imbriquées : on parcourt tous les couples constitués d’enregistrements de la première puis de la seconde table et on filtre à l’aide d’une instruction conditionnelle.\n\nfrom copy import deepcopy\n\nTable1 = [{'Nom': 'Joe', 'Anglais': '17', 'Info': '18', 'Maths': '16'},\n          {'Nom': 'Zoé', 'Anglais': '15', 'Info': '17', 'Maths': '19'},\n          {'Nom': 'Max', 'Anglais': '19', 'Info': '13', 'Maths': '14'},\n          {'Nom': 'Bob', 'Anglais': '12', 'Info': '16', 'Maths': '10'}]\n\nTable2 = [{'Nom': 'Joe', 'Age': 16, 'Couriel': 'joe@info.fr'},\n          {'Nom': 'Zoé', 'Age': 15, 'Couriel': 'zoe@info.fr'}]\n\n\ndef jointure_selon_attribut_commun(t1: list, t2: list, attr: str) -&gt; list:\n    \"\"\"Effectue la jointure entre les tables t1 et t2 selon l'attribut commun attr\"\"\"\n    jointure = []\n    for item1 in t1:\n        for item2 in t2:\n            if item1[attr] == item2[attr]:\n                # définition d'une ligne de la nouvelle table reprenant le contenu de la ligne en cours de t1\n                new_line = deepcopy(item1)\n                # boucle pour ajouter les champs de la ligne de t2 autres que attr\n                for cle in item2:\n                    if cle != attr:\n                        new_line[cle] = item2[cle]\n                # ajout de la nouvelle ligne à la nouvelle table\n                jointure.append(new_line)\n    return jointure\n\n\nprint(jointure_selon_attribut_commun(Table2, Table1, 'Nom'))\n\n[{'Nom': 'Joe', 'Age': 16, 'Couriel': 'joe@info.fr', 'Anglais': '17', 'Info': '18', 'Maths': '16'}, {'Nom': 'Zoé', 'Age': 15, 'Couriel': 'zoe@info.fr', 'Anglais': '15', 'Info': '17', 'Maths': '19'}]\n\n\nRemarque : dans la fonction ci-dessus, on suppose que le nom des attributs est toujours une chaîne de caractères."
  },
  {
    "objectID": "tables/tables_exos.html",
    "href": "tables/tables_exos.html",
    "title": "Exercices - Traitements de données en tables",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "tables/tables_exos.html#fa-desktop-exercice-1",
    "href": "tables/tables_exos.html#fa-desktop-exercice-1",
    "title": "Exercices - Traitements de données en tables",
    "section": " Exercice 1",
    "text": "Exercice 1\nDans cet exercice, on utilise le fichier CSV listant les établissements scolaires du Cantal déjà rencontré dans le cours (Source : https://www.data.gouv.fr/fr/). Ce fichier utilise l’encodage UTF-8.\nAvertissement : Dans cet exercice, certaines questions nécessitent la comparaison de valeurs numériques alors que les données sont toutes au format chaîne de caractères. Il faut donc penser, si besoin, à convertir les données au format numérique adéquat.\n\nImporter ce fichier dans un programme Python et indexer les données sous la forme d’un tableau de dictionnaires nommé table_educ.\nCombien d’enregistrements contient cette table ?\nOpérations de sélection :\n\nEn utilisant une boucle, écrire des instructions permettant de définir le tableau etab_AURILLAC contenant les enregistrements qui correspondent à des établissement situés à Aurillac.\nEn utilisant une définition de tableau en compréhension, écrire une instruction permettant d’obtenir le tableau contenant les enregistrements de tous les établissements privés du Cantal.\n\nOpérations de projection :\n\nEn utilisant une boucle, écrire des instructions permettant d’obtenir le tableau de tous les codes UAI des établissements du Cantal.\nEn utilisant une définition de tableau en compréhension, écrire une instruction permettant d’obtenir le tableau de tous les noms d’établissements utilisés dans le Cantal.\nOn souhaite obtenir le tableau des noms de communes dans lesquelles existe au moins un établissement scolaire, sans répétition (une commune dans laquelle existent trois établissements ne doit apparaître qu’une fois). Trouver une solution pour ce faire.\n\nOpérations de tri :\n\nTrier les données par ordre croissant de code postaux.\nTrier les données d’Ouest en Est, puis du Nord au Sud.\nTrier les données suivant deux critères : d’abord la commune, puis à l’intérieur de chaque commmune, selin le statut : public en premier, privé en dernier.\n\nOpération de jointure :\n\nImporter le fichier CSV population_Cantal.csv et indexer les données sous la forme d’un tableau de dictionnaires nommé population (Source des données : Insee, Recensement de la population 2019). Ce fichier utilise l’encodage UTF-8.\nAttention: Ouvrir d’abord le fichier dans Notepad ++ et observer le délimiteur utilisé, le nom des attributs, …\nCombien d’enregistrements contient cette table ?\nÉcrire les instructions permettant d’effectuer la jointure entre les tables table_educ et population sous la forme d’une table nommée new_table qui reprend tous les attributs de la table table_educ en ajoutant à chaque enregistrement la population de la commune considérée sous la forme d’un champ nommé “population”.\nEnregistrer les données de la table new_table dans un nouveau fichier CSV nommé exo1_jointure.csv.\nOuvrir ce fichier dans un tableur. Certains enregistrements n’ont pas de valeur pour le champ “population”. Chercher la cause de cette anomalie et essayer de la corriger.\n\n\n\n\n\n\n\n\nÀ retenir\n\n\n\nLorsqu’on rapproche deux tables, il faut toujours veiller à la cohérence des noms des attributs, des formats des données (domaines de valeurs), aux doublons, …\nCela implique souvent un travail préliminaire de formatage des données avant de passer à leur exploitation proprement dite. Ce formatage a été fait pour vous dans cet exercice, sauf pour le petit problème restant qui est apparu dans la dernière question."
  },
  {
    "objectID": "tables/tables_exos.html#fa-desktop-exercice-2",
    "href": "tables/tables_exos.html#fa-desktop-exercice-2",
    "title": "Exercices - Traitements de données en tables",
    "section": " Exercice 2",
    "text": "Exercice 2\nPour s’entraîner, on reprend le fichier population_Cantal.csv. Pour chaque question, écrire des instructions Python permettant d’y répondre. Vous pourrez dans certains cas proposer plusieurs solutions.\n\nConstruire la table des mêmes données, mais triées par population décroissante.\nFaire le tableau des noms de communes dont le nom complet se termine par “AC”. Combien y en a-t-il ?\nConstruire la table des enregistrements correspondant aux communes dont la population est comprise au sens large entre 1000 et 2000 habitants.\nQuestion ouverte : construire le tableau des noms de communes qui sont composés de plusieurs mots."
  },
  {
    "objectID": "tables/tables_quiz.html",
    "href": "tables/tables_quiz.html",
    "title": "Quiz : Données en tables",
    "section": "",
    "text": "Quiz : Données en tables\n\nDans la plupart des fichiers CSV, que contient la première ligne ?\n\nRéponse A : des notes concernant la table de données\nRéponse B : les sources des données\nRéponse C : les descripteurs des champs de la table de données\nRéponse D : l’auteur de la table de données\n\nLaquelle de ces affirmations est vraie ?\n\nRéponse A : on ne peut accéder au contenu d’un fichier CSV que par l’intermédiaire d’un programme Python\nRéponse B : CSV est un format de chiffrement des données\nRéponse C : le format CSV a été conçu pour assurer la confidentialité d’une partie du code d’un programme\nRéponse D : les fichiers CSV sont composés de données séparées par des caractères comme des virgules\n\nQu’est-ce que le format de fichier CSV ?\n\nRéponse A : un format de fichier mis au point par Microsoft pour Excel\nRéponse B : un format de fichier pour décrire une base de données\nRéponse C : un format de fichier où les données sont séparées par un caractère tel qu’une virgule\nRéponse D : un format de fichier décrivant une page Web\n\nOn considère l’extraction suivante d’une base de données des départements français. Cette extraction a ensuite été sauvegardée dans un fichier texte.\n\"1\",\"01\",\"Ain\",\"AIN\",\"ain\",\"A500\"\n\"2\",\"02\",\"Aisne\",\"AISNE\",\"aisne\",\"A250\"\n\"3\",\"03\",\"Allier\",\"ALLIER\",\"allier\",\"A460\"\n\"4\",\"04\",\"Alpes-de-Haute-Provence\",\"ALPES-DE-HAUTE-PROVENCE\",\"alpes-de-haute-provence\",\"A412316152\"\n\"5\",\"05\",\"Hautes-Alpes\",\"HAUTES-ALPES\",\"hautes-alpes\",\"H32412\"\nOn considère le code suivant :\nimport csv\n\nf = open('departements.csv', mode='r', encoding='UTF-8', newline='')\nlesLignes = csv.reader(f)\nfor uneLigne in lesLignes:\n    print(uneLigne[3])\nf.close()\nQue va produire l’exécution de ce code ?\n\nRéponse A : L’affichage de la troisième colonne à savoir le nom du département avec une majuscule initiale\nRéponse B : L’affichage de tout le contenu du fichier\nRéponse C : L’affichage du nombre total de départements figurant dans le fichier\nRéponse D : L’affichage de la quatrième colonne, à savoir le nom du département tout en majuscules\n\nOn dispose du fichier 'info.csv' donné ci-dessous :\nnom, prenom, naissance, deces\nlovelace, ada, 1815, 1852\nvon neumann, john, 1903, 1957\nturing, alan, 1912, 1954\nmccarthy, john, 1927, 2011\nfloyd, robert, 1936, 2001\nLe programme ci-dessous nous permet de créer un tableau à partir de ce fichier.\nfile = open(\"info.csv\", \"r\")\nfirstLine = file.readline()  # chargement de la ligne d'entête\ntableau = [line.split(',') for line in file]  # chargement des données\nLes index des lignes de ce tableau vont :\n\nRéponse A : de 0 à 3\nRéponse B : de 1 à 4\nRéponse C : de 0 à 4\nRéponse D : de 0 à 5\n\nQuelle expression Python permet d’accéder au numéro de téléphone de Tournesol, sachant que le répertoire a été défini par l’affectation suivante :\nrepertoire = [{'nom': 'Dupont', 'tel': '5234'},\n          {'nom': 'Tournesol', 'tel': '5248'},\n          {'nom': 'Dupond', 'tel': '3452'}]\n\nRéponse A : repertoire['Tournesol']\nRéponse B : repertoire['tel'][1]\nRéponse C : repertoire[1]['tel']\nRéponse D : repertoire['Tournesol'][tel]"
  }
]
[
  {
    "objectID": "ressources.html",
    "href": "ressources.html",
    "title": "Sources utilisées",
    "section": "",
    "text": "Pour rédiger ce cours et préparer les exercices, TP, projets présentés ici, j’ai utilisé de nombreuses sources que je vais essayer de citer ici, sans prétendre être exhaustif.\n\nDocuments d’accompagnement Eduscol.\nContenus du MOOC “Numérique et Sciences Informatiques : les fondamentaux” de l’INRIA, disponible sur la plateforme fun-mooc.\nApprendre à programmer avec Python 3, Gérard Swinnen, éditions Eyrolles, 2012. Disponible en ligne\nLe site interstices : https://interstices.info/.\nLes images et illustrations sont soit produites par mes soins, soit issues de Pixabay ou de Wikimedia commons ou encore de Pexels et, dans tous les cas, libres de droits.\nCours de David Roche.\nCours de Frédéric Junier.\nCours de Van Zuijlen Stéphan.\nCours de Konieczko Quentin\nCours de Olivier Lécluse\nCours du Lycée Blaise Pascal de Clermont-Ferrand\nCours du lycée Champollion de Grenoble\nCours du site Lyceum\nCours du site Mon Lycée Numérique\nCours du Lycée Stanislas de Wissembourg\nCours d’informatique de François Brucker (école Centrale de Marseille)\nCours de Philippe Rigaux sur les bases de données.\nCours de Gilles Lassus\nLe site MDN Web Docs : excellentissime ressource pour tout apprendre sur les langages HTML, CSS, Javascript et le protocole HTTP.\nLe site de M. JANVIER.\nLe site de M. Meyroneinc."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Mentions légales",
    "section": "",
    "text": "Mentions légales\n\nSite personnel de Fabrice LALLEMAND, Lycée Emile DUCLAUX, 16 avenue Henri MONDOR, 15000 AURILLAC, téléphone 04 71 48 22 22.\nCe site est hébergé en Auvergne par o2switch."
  },
  {
    "objectID": "27_ihm/index.html",
    "href": "27_ihm/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nPériphériques d’entrée et de sortie. Interface HommeMachine (IHM)\nIdentifier le rôle des capteurs et actionneurs. Réaliser par programmation une IHM répondant à un cahier des charges donné.\nLes activités peuvent être développées sur des objets connectés, des systèmes embarqués ou robots."
  },
  {
    "objectID": "27_ihm/ihm_cours.html",
    "href": "27_ihm/ihm_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Définition\n\n\n\nUn système informatique embarqué est un système de traitement de l’information autonome ne possédant pas d’entrée et sortie standard comme le clavier et l’écran. Les informations sont reçues de l’extérieur par le biais de capteurs, elles sont traitées par un processeur et selon le programme du système des actions physiques peuvent être déclenchées avec des actionneurs. Les capteurs sont des périphériques d’entrée et les actionneurs des périphériques de sortie.\n\n\nLes signaux capturés sont analogiques, analogues au phénomène : par exemple la rotation de l’axe d’un anémomètre qui mesure la vitesse du vent sur une station météo. Pour être traités par le processeur, ils sont numérisés transformés en un nombre fini d’informations codées par des 0 et des 1 par échantillonnage (nombre fini de relevés) et quantification (nombre fini de valeurs possibles).\nLes microcontrôleurs sont des circuits intégrés qui concentrent une mémoire, un processeur, des entrées-sorties comme un ordinateur, mais se caractérisent par une miniaturisation accrue, une plus faible consommation électrique et des performances moindres, mais suffisantes pour des applications toujours plus nombreuses avec les progrès techniques.\nLes systèmes informatiques embarqués sont utilisés dans tous les domaines : l’industrie (robots), le transport (avionique, automobile, métro …), la médecine (stimulateurs cardiaques, imagerie …), la maison (domotique, appareils ménagers …), les télécommunications (téléphonie …), le monde du travail (contrôle d’accès …), les loisirs (vélo électrique …).\nOn parle d’informatique ubiquitaire pour désigner cette omniprésence de l’informatique dans notre environnement.\nLes smartphones modernes ne sont pas des microcontrôleurs, mais des ordinateurs miniatures bien plus puissants que les systèmes de guidage des premières missions Apollo qui ont amené l’homme sur la lune ! Ils sont dotés de nombreux capteurs.\n\n\n\nSource : flickr / Intel Free Press\n\n\n\n\n\n\n\nSource : Yassine Haddab Université de Montpellier\n\n\n\n\n\n\n\n\nMéthode\n\n\n\nUn algorithme de contrôle fréquent sur un système informatique embarqué consiste en une boucle infinie où s’enchaînent capture d’événements par les émetteurs, traitement puis action par les actionneurs.\nInitialiser les actionneurs à leur position de départ\nTant que Vrai \n    Lire les informations des capteurs\n    Traiter ces informations\n    Calculer des informations sur les actionneurs\n    Transmettre ces informations aux actionneurs",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 8 - Interfaces homme-machine et robotique",
      "Cours"
    ]
  },
  {
    "objectID": "27_ihm/ihm_cours.html#architecture-dun-système-embarqué",
    "href": "27_ihm/ihm_cours.html#architecture-dun-système-embarqué",
    "title": "Cours",
    "section": "",
    "text": "Définition\n\n\n\nUn système informatique embarqué est un système de traitement de l’information autonome ne possédant pas d’entrée et sortie standard comme le clavier et l’écran. Les informations sont reçues de l’extérieur par le biais de capteurs, elles sont traitées par un processeur et selon le programme du système des actions physiques peuvent être déclenchées avec des actionneurs. Les capteurs sont des périphériques d’entrée et les actionneurs des périphériques de sortie.\n\n\nLes signaux capturés sont analogiques, analogues au phénomène : par exemple la rotation de l’axe d’un anémomètre qui mesure la vitesse du vent sur une station météo. Pour être traités par le processeur, ils sont numérisés transformés en un nombre fini d’informations codées par des 0 et des 1 par échantillonnage (nombre fini de relevés) et quantification (nombre fini de valeurs possibles).\nLes microcontrôleurs sont des circuits intégrés qui concentrent une mémoire, un processeur, des entrées-sorties comme un ordinateur, mais se caractérisent par une miniaturisation accrue, une plus faible consommation électrique et des performances moindres, mais suffisantes pour des applications toujours plus nombreuses avec les progrès techniques.\nLes systèmes informatiques embarqués sont utilisés dans tous les domaines : l’industrie (robots), le transport (avionique, automobile, métro …), la médecine (stimulateurs cardiaques, imagerie …), la maison (domotique, appareils ménagers …), les télécommunications (téléphonie …), le monde du travail (contrôle d’accès …), les loisirs (vélo électrique …).\nOn parle d’informatique ubiquitaire pour désigner cette omniprésence de l’informatique dans notre environnement.\nLes smartphones modernes ne sont pas des microcontrôleurs, mais des ordinateurs miniatures bien plus puissants que les systèmes de guidage des premières missions Apollo qui ont amené l’homme sur la lune ! Ils sont dotés de nombreux capteurs.\n\n\n\nSource : flickr / Intel Free Press\n\n\n\n\n\n\n\nSource : Yassine Haddab Université de Montpellier\n\n\n\n\n\n\n\n\nMéthode\n\n\n\nUn algorithme de contrôle fréquent sur un système informatique embarqué consiste en une boucle infinie où s’enchaînent capture d’événements par les émetteurs, traitement puis action par les actionneurs.\nInitialiser les actionneurs à leur position de départ\nTant que Vrai \n    Lire les informations des capteurs\n    Traiter ces informations\n    Calculer des informations sur les actionneurs\n    Transmettre ces informations aux actionneurs",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 8 - Interfaces homme-machine et robotique",
      "Cours"
    ]
  },
  {
    "objectID": "27_ihm/ihm_cours.html#interface-homme-machine",
    "href": "27_ihm/ihm_cours.html#interface-homme-machine",
    "title": "Cours",
    "section": "Interface Homme Machine",
    "text": "Interface Homme Machine\n\n\n\n\n\n\nDéfinition\n\n\n\nUne Interface Homme Machine est un ensemble de moyens physiques (boutons, manettes) ou logiciels (interface graphique) qui permettent à un humain d’échanger des informations avec une machine.\nLes moyens matériels permettant l’interaction sont appelés périphériques : on distingue les périphériques d’entrée ou de sortie.\nDouglas Engelbart est un des pionniers des IHM en informatique avec son système NLS qui introduit la première souris.\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCompléter la légende de la figure ci-dessous représentant différents composants et périphériques d’un ordinateur :\n\n\n\nSource : Gustavb / CC BY-SA (http://creativecommons.org/licenses/by-sa/3.0/)\n\n\n\n\n\nFiabilité et sécurité\n\nLa sûreté est la garantie qu’un système fait ce qu’il doit faire et ne fait pas ce qu’il ne doit pas faire. Les programmes des systèmes embarqués doivent parfois s’exécuter avec des contraintes fortes (manque de ressource, temps de réaction très rapide) et ils ne sont pas toujours développés avec la rigueur nécessaire. Les bugs sont donc fréquents. Parfois bénins (une mauvaise gestion des années bissextiles a provoqué l’arrêt du lecteur MP3 Zune de Microsoft le 31/12/2008), ils peuvent aussi avoir a des conséquences dramatiques : les bugs du Therac 25 (appareil de radiographie) ou du contrôle moteur sur les Toyota Camry ont provoqué plusieurs morts.\nLa confidentialité est une problématique majeure des systèmes embarqués qui collectent des données personnelles sur leurs utilisateurs, comme les cartes électroniques de transport en commun.\nLa sécurité est souvent un point faible des systèmes embarqués, qui manquent de ressources matérielles, ont des cycles de vie longs sans mise à jour et mettent en jeu des modes de communication sans contact particulièrement vulnérables.\n\nPar exemple, une voiture ne peut démarrer que si la carte de démarrage se trouve à proximité, car la carte et la voiture partagent un secret commun permettant de déverrouiller le système antidémarrage. L’attaque par relais permet de déjouer ce protocole en relayant la communication : un pirate se trouve près de la voiture et l’autre près de la carte et par un leurre technologique ils font croire aux deux parties qu’elles sont à proximité. Tous les systèmes embarqués qui communiquent sans contact (carte bancaire, carte d’accès …) sont vulnérables à cette attaque.\n\n\n\nSource : Image : Martial Régereau [CC BY-SA 3.0], via Wikimedia Commons\n\n\n\n\nQCM",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 8 - Interfaces homme-machine et robotique",
      "Cours"
    ]
  },
  {
    "objectID": "27_ihm/ihm_cours.html#objets-connectés",
    "href": "27_ihm/ihm_cours.html#objets-connectés",
    "title": "Cours",
    "section": "Objets connectés",
    "text": "Objets connectés\n\nInternet des objets\n\n\n\n\n\n\nDéfinition\n\n\n\nUn objet connecté est un système informatique embarqué disposant d’une connexion à un réseau local ou à L’Internet.\nLes Interfaces Homme Machine des objets connectés sont souvent des applications Web disponibles sur Smartphone.\n\n\n\n\n\nSource : Yassine Haddab Université de Montpellier\n\n\nAvec la baisse des coûts des microcontrôleurs et des puces Wifi, les objets connectés se multiplient. Actuellement, il existe plus d’objets que d’humains connectés à Internet et leur nombre va augmenter fortement dans les prochaines années avec la baisse de coût des puces. On parle d’IOT pour Internet Of Things pour désigner l’ensemble des objets connectés à l’Internet.\nOn estime à 50 milliards le nombre d’objets connectés en 2020.\n\n\nFiabilité et sécurité\nLes objets connectés permettent d’ajouter de l’intelligence dans notre environnement à tous les niveaux : le corps (mes indicateurs de santé, ma nourriture), la maison(appareils, système de chauffage), les réseaux (électrique, de circulation), les transports (véhicules autonomes), la prévention des risques (incendies) … De plus la collaboration entre objets connectés, leur connexion à des bases de données en ligne, augmente considérablement leur puissance même si chaque objet a des ressources matérielles limitées.\nNéanmoins, les vulnérabilités des systèmes embarqués sont amplifiées s’ils sont connectés.\nLa cyberattaque d’un serveur DNS majeur par des milliers de caméras de surveillance transformées en bots, a gravement perturbé Internet en octobre 2016. La prise de contrôle à distance par des hackers de la Jeep Cherokee en 2015 ou des failles détectées dans des stimulateurs cardiaques sont des exemples parmi bien d’autres illustrant le fait que la révolution de l’internet des objets ne pourra se faire sans des progrès sur le plan de leur sécurité.\nEnfin la moisson de données personnelles que peuvent collecter des objets connectés comme les assistants personnels proposés par les GAFAM doit absolument être contrôlée.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 8 - Interfaces homme-machine et robotique",
      "Cours"
    ]
  },
  {
    "objectID": "26_gloutons/gloutons_exos.html",
    "href": "26_gloutons/gloutons_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Fiche d’exercices sur Capytale : Cliquer ici !",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices"
    ]
  },
  {
    "objectID": "26_gloutons/exos_gloutons_CORR.html",
    "href": "26_gloutons/exos_gloutons_CORR.html",
    "title": "Exercice 1 : problème du rendu de monnaie",
    "section": "",
    "text": "!!! info le problème Un achat en espèces se traduit par un échange de pièces et de billets. Dans la zone euro, le système en vigueur, en mettant de côté les centimes d’euros, met à disposition des pièces ou billets de 1 €, 2 €, 5 €, 10 €, 20 €, 50 €, 100 €, 200 €, 500 €. Le problème du rendu de monnaie s’énonce alors de la façon suivante : en supposant que nous avons à notre disposition un nombre illimité de ces pièces ou billets, comment rendre une somme donnée de façon optimale, c’est-à-dire avec le nombre minimal de pièces ou billets ? !!!\nQuestion 1 : Supposons que la somme à rendre est de 7 €. Faire la liste de toutes les façons de rendre une telle somme. Quelle est la façon optimale ?\n\n7 = 5 + 2 = 5 + 1 + 1 = 2 + 2 + 2 + 1 = 2 + 2 + 1 + 1 + 1 = 2 + 1 + 1+ 1 + 1 + 1 = 1 + 1 + 1 + 1 + 1 + 1 +1\n\nLa solution optimale est 7 = 5 + 2 : on n'utilise que deux pièces\n\nSans s’en rendre compte, tout individu met généralement en œuvre un algorithme glouton. Il choisit d’abord la pièce ou le billet de valeur maximale qu’il peut rendre, sans rendre trop évidemment ! Puis il réitère cela tant qu’il reste quelque chose à rendre.\nQuestion 2 : Appliquer cette méthode pour déterminer la façon optimale de rendre 463 €.\n\n463 = 200 + 200 + 50 + 10 + 2 + 1\n\nPour mettre en œuvre cet algorithme glouton en Python, on définit tout d’abord le système de monnaie via une liste contenant les valeurs des pièces et billets du système par valeurs décroissantes. Pour le système européen, on écrit par exemple l’instruction suivante.\n\nsysteme_monnaie_europeen = [500,200,100,50,20,10,5,2,1]\n\nOn utilise également une variable de type entier somme_a_rendre initialement égale à la somme à rendre.\nL’algorithme consiste alors à parcourir la liste précédente de gauche à droite. Pour chaque élément de cette liste, on vérifie qu’il est bien plus petit que la somme à rendre, auquel cas on le soustrait de la somme à rendre et on le stocke dans la liste des pièces et billets à rendre, sinon on passe à l’élément suivant. On s’arrête enfin lorsque la somme à rendre est égale à zéro.\nNous mettons l’ensemble du code dans une fonction qui prend pour arguments la somme à rendre et le système de monnaie, puis renvoie la liste des pièces ou billets à rendre.\n\ndef rendu(somme_a_rendre, systeme_monnaie):\n    liste_pieces = [] # liste des pièces à rendre\n    i = 0 # indice de la pièce à rendre dans la liste systeme_monnaie\n    while somme_a_rendre &gt; 0: # tant qu'il reste quelque chose à rendre\n        valeur = systeme_monnaie[i] # valeur de la pièce à rendre\n        if valeur &gt; somme_a_rendre: # la pièce a une valeur trop élevée\n            i += 1 # on avance alors dans la liste\n        else: # la pièce peut être rendue\n            liste_pieces.append(valeur) # on ajoute la pièce dans la liste des pièces à rendre\n            somme_a_rendre = somme_a_rendre - valeur # on met à jour la somme à rendre\n    return liste_pieces\n\nQuestion 3 : Compléter les deux lignes en pointillés du code précédent, puis exécuter les cellules ci-dessous pour tester le code.\n\nrendu(7,systeme_monnaie_europeen)\n\n[5, 2]\n\n\n\nrendu(463,systeme_monnaie_europeen)\n\n[200, 200, 50, 10, 2, 1]\n\n\n\nExercice 2 : Problème du sac à dos\nOn dispose d’objets ayant chacun une masse et une valeur en euros, et d’un sac ne pouvant supporter plus d’une certaine masse. Il s’agit alors de remplir le sac en maximisant la valeur totale des objets et sans dépasser la masse maximale. Ce problème, malgré sa simplicité, est un problème majeur d’optimisation.\nSupposons que l’on dispose d’un sac de contenance maximale 30 kg et quatre objets A, B, C et D dont les caractéristiques sont les suivantes :\n\n\n\nObjet\nA\nB\nC\nD\n\n\n\n\nMasse\n13 kg\n12 kg\n8 kg\n10 kg\n\n\nValeur\n70 €\n40 €\n30 €\n30 €\n\n\n\nQuestion 4 : Calculer ci-dessous la liste des rapports Valeurs/Masse \\(\\frac{v_i}{m_i}\\), appelés efficacité de chaque objet. L’algorithme glouton que nous proposons consiste alors à classer les objets dans l’ordre décroissant de leur efficacité. On remplit ensuite le sac en prenant les objets un à un dans cet ordre, tant que le sac peut encore les contenir. Déterminer la combinaison d’objets fournie par cet algorithme. Quel est la valeur totale de cette combinaison ?\n\nA : 70/13 = 5.4\nB : 40/12 = 3.3\nC : 30/8 = 3.75\nD : 30/10 = 3\n\nClassement : A &gt; C &gt; B &gt; D\n\nOn choisit l'objet A de masse 13 kg, la sac peut encore contenir 30 - 13 = 17 kg.\nOn choisit l'objet C de masse 8 kg, le sac peut encore contenir 17 - 8 = 9 kg.\nLes objets B et D sont trop lourds, c'est terminé.\nLa valeur totale de cette combinaison (A, C) est égale à 100 €.\n\nPour mettre en œuvre l’algorithme glouton que nous venons d’étudier pour le problème du sac à dos, nous créons tout d’abord une variable Max contenant la capacité maximale (en kilogrammes) du sac. Nous créons ensuite trois listes liste_noms, liste_masses et liste_valeurs qui contiennent respectivement les noms, masses et valeurs de chacun des objets.\nConsidérons un sac de contenance maximale 10 kg et des objets dont les caractéristiques sont les suivantes :\n\n\n\nObjet\nA\nB\nC\nD\nE\nF\n\n\n\n\nMasse\n7 kg\n6 kg\n4 kg\n3 kg\n2 kg\n1 kg\n\n\nValeur\n9100 €\n6000 €\n4800 €\n2700 €\n2800 €\n200 e\n\n\n\nNous écrivons alors les instructions suivantes :\n\nMax = 10 # contenance maximale du sac\nliste_noms = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"] # liste des noms des objets\nliste_masses = [7,6,4,3,2,1] # liste des masses des objets\nliste_valeurs = [9100,6000,4800,2700,2800,200] # liste des valeurs des objets\n\nQuestion 5 : Créer une liste L dont le i-ème élément est une liste contenant l’efficacité du i-ème élément, son nom, sa masse et sa valeur. Vérifier que L contient bien ce que l’on veut.\n\nL = [[liste_valeurs[i]/liste_masses[i], liste_noms[i], liste_masses[i], liste_valeurs[i]] for i in range(len(liste_noms))]\nprint(L)\n\n[[1300.0, 'A', 7, 9100], [1000.0, 'B', 6, 6000], [1200.0, 'C', 4, 4800], [900.0, 'D', 3, 2700], [1400.0, 'E', 2, 2800], [200.0, 'F', 1, 200]]\n\n\nQuestion 6 : Exécuter la cellule ci-dessous pour trier la liste de l’objet le plus “efficace” à l’objet le moins “efficace”.\n\nL_triee=sorted(L,reverse=True)\nprint(L_triee)\n\n[[1400.0, 'E', 2, 2800], [1300.0, 'A', 7, 9100], [1200.0, 'C', 4, 4800], [1000.0, 'B', 6, 6000], [900.0, 'D', 3, 2700], [200.0, 'F', 1, 200]]\n\n\nQuestion 7 : Le code ci-dessous met en œuvre l’algorithme glouton. Compléter les lignes en pointillés.\n\nliste_objets = [] # liste des noms des objets rangés dans le sac\nSomme_masses = 0 # somme des masses des objets déjà rangés\nfor i in range(len(L_triee)):\n    if Max &gt;= Somme_masses : # l'objet d'indice i peut être rangé\n        liste_objets.append(L_triee[i][1]) # on range l'objet d'indice i\n        Somme_masses += L_triee[i][2] # on met à jour la somme des masses\n\nQuestion 8: : En déduire la combinaison fournie par l’algorithme glouton et la masse totale de cette combinaison.\n\nprint(liste_objets)\n\n['E', 'A', 'C']\n\n\nQuestion 9 : Modifier le code précédent afin de déterminer également la valeur totale de la combinaison trouvée.\n\nliste_objets = [] # liste des noms des objets rangés dans le sac\nSomme_masses = 0 # somme des masses des objets déjà rangés\nvaleur_totale = 0\nfor i in range(len(L_triee)):\n    if Max &gt;= Somme_masses : # l'objet d'indice i peut être rangé\n        liste_objets.append(L_triee[i][1]) # on range l'objet d'indice i\n        Somme_masses += L_triee[i][2] # on met à jour la somme des masses\n        valeur_totale = valeur_totale + L_triee[i][3]\n\nprint(\"Liste des objets dans le sac : \", liste_objets)\nprint(\"Valeur totale de la combinaison trouvée : \", valeur_totale)\n\nListe des objets dans le sac :  ['E', 'A', 'C']\nValeur totale de la combinaison trouvée :  16700"
  },
  {
    "objectID": "25_kppv/KNN-TP.html",
    "href": "25_kppv/KNN-TP.html",
    "title": "TP : Reconnaissance optique de chiffres",
    "section": "",
    "text": "Ce TP sur Capytale : https://capytale2.ac-paris.fr/web/c/946e-3650247",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "TP : Reconnaissance optique de chiffres"
    ]
  },
  {
    "objectID": "25_kppv/KNN-TP.html#chargement-et-visualisation-des-jeux-de-données",
    "href": "25_kppv/KNN-TP.html#chargement-et-visualisation-des-jeux-de-données",
    "title": "TP : Reconnaissance optique de chiffres",
    "section": "1. Chargement et visualisation des jeux de données",
    "text": "1. Chargement et visualisation des jeux de données\nLa librairie python scikit-learn contient de nombreux algorithmes d’intelligence artificielle, ainsi que des bases de données d’exemples classiques.\nEn particulier, le jeu de données digits contient un ensemble de 1797 chiffres de 0 à 9 manuscrits, sous la forme d’images de 8 X 8 pixels\n\nfrom sklearn.datasets import load_digits\n\nEnregistrons le dataset dans une variable digits.\nNous avons bien 1797 éléments\n\ndigits = load_digits()\nprint(digits.keys()) # affichage des clés du dataset\nprint(len(digits.data)) # affichage du nombre d'images\n\ndict_keys(['data', 'target', 'frame', 'feature_names', 'target_names', 'images', 'DESCR'])\n1797\n\n\nChaque images est une liste de 8 X 8 pixels soit 64 valeurs comprises entre 0 et 16 (niveaux de gris).\n\n# Une liste de liste servant à l'affichage d'une image\nprint(digits.images[1])\n\n[[ 0.  0.  0. 12. 13.  5.  0.  0.]\n [ 0.  0.  0. 11. 16.  9.  0.  0.]\n [ 0.  0.  3. 15. 16.  6.  0.  0.]\n [ 0.  7. 15. 16. 16.  2.  0.  0.]\n [ 0.  0.  1. 16. 16.  3.  0.  0.]\n [ 0.  0.  1. 16. 16.  6.  0.  0.]\n [ 0.  0.  1. 16. 16.  6.  0.  0.]\n [ 0.  0.  0. 11. 16. 10.  0.  0.]]\n\n\n\nVisualisons une image\nLe code ci-dessous permet de visualiser quatre images associées dans la base au chiffre 3.\n\nimport matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(nrows=2, ncols=2, figsize=(8, 6))\n\naxs[0, 0].imshow(digits.images[3], cmap='gray')\naxs[0, 1].imshow(digits.images[13], cmap='gray')\naxs[1, 0].imshow(digits.images[23], cmap='gray')\naxs[1, 1].imshow(digits.images[45], cmap='gray')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\nDécoupons le jeu de données ‘digits’ en deux partie :\n\n[0-1700] pour les valeurs dont la classe est connue (données d’entraînement).\n[1701-1797] pour les valeurs à tester (dont on veut prédire la classe).\n\nChaque ensemble de données est représentée sous la forme d’un tableau d’entiers correspondants aux indices des images dans la base digits.\n\nimages_connues = [i for i in range(1700)]\nimages_inconnues = [i for i in range(1700, 1798)]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "TP : Reconnaissance optique de chiffres"
    ]
  },
  {
    "objectID": "25_kppv/KNN-TP.html#mise-en-oeuvre-de-lalgorithme-des-knn",
    "href": "25_kppv/KNN-TP.html#mise-en-oeuvre-de-lalgorithme-des-knn",
    "title": "TP : Reconnaissance optique de chiffres",
    "section": "2. Mise en oeuvre de l’algorithme des KNN",
    "text": "2. Mise en oeuvre de l’algorithme des KNN\n\n2.1 La distance entre deux images\nPour calculer la distance entre deux images, nous allons utiliser la distance euclidienne. Compléter la fonction distEuclide ci-dessous :\n\nles paramètres de la fonction seront deux listes de même taille\n\nRappel : distance euclidienne\n\\[d(x,y) = \\sqrt{\\sum_{i=0}^{n} (yi - xi)^2}\\]\n\nfrom math import sqrt\n\ndef distEuclide(elt1:list, elt2:list)-&gt;float:\n    \"\"\"\n    Renvoie la distance entre deux listes\n    \"\"\"\n    distance = 0\n    for i in range(...):\n        distance += ...\n    distance = ...\n    return distance\n\n\n\n2.2 Liste des distances\nCompléter ci-dessous la fonction calculeDistances prend en argument une liste image_inconnue, de taille 8x8, et qui retourne la liste des distances euclidiennes entre l’image inconnue et toutes les autres connues (on utilisera la variable globale images_connues définie plus haut). distances est une liste de dictionnaires de la forme :\n[{'image_connue': 1, 'distance': 12.0}, {'image_connue': 2, 'distance': 15.0}, ...]\n\ndef calculeDistances(image_inconnue:list) -&gt;list:\n    \"\"\"\n    Calcule les distances entre l'image inconnue et toutes les autres connues\n    \"\"\"\n    distances = []\n    for i in range(len(images_connues)):\n        distance = distEuclide(..., digits.data[images_connues[i]])\n        distances.append({\"image\": ..., \"distance\": ...})\n    return distances\n\n\n\n2.3 Liste des \\(k\\) plus proches voisins.\nConsidérons un entier \\(k&gt;3\\). Compléter la fonction ci-dessous qui retourne la liste de \\(k\\) plus proches voisins de l’image représentée par image_inconnue.\n\ndef cleDeTri(dico:dict)-&gt;float:\n    \"\"\"\n    Retourne la distance de l'élément du dictionnaire\n    \"\"\"\n    return dico[\"distance\"]\n\ndef plusProchesVoisins(image_inconnue:list, k: int) -&gt;list:\n    \"\"\"\n    Retourne le tableau des k plus proches voisins\n\n    image_inconnue : liste de 8x8 pixels de l'image inconnue\n\n    retourne : liste de dictionnaires des k plus proches voisins \n    \"\"\"\n    # on calcule les distances entre l'image inconnue et les images connues\n    distances = ...\n    # on trie les distances par ordre croissant\n    distances_triees = ...\n    # on retourne la liste des k plus proches voisins\n    voisins = ...\n    return voisins\n\n\n\n2.4 Prédiction de la classe de l’image inconnue\nCompléter la fonction ci-dessous qui retourne la classe la plus fréquente parmi les \\(k\\) plus proches voisins.\n\ndef prediction(image_inconnue:list, k:int) -&gt;int:\n    \"\"\"\n    Prédit le chiffre associé à l'image inconnue\n    \"\"\"\n    # On récupère les k plus proches voisins\n    voisins = ...\n    # On récupère les chiffres des voisins\n    chiffres_voisins = []\n    for voisin in voisins:\n        chiffres_voisins.append(digits.target[voisin[\"image\"]])\n    # On détermine le chiffre le plus fréquent parmi les chiffres des voisins\n    prediction = max(set(chiffres_voisins), key=chiffres_voisins.count)\n    return ...\n\nTestons cette fonction avec la première image inconnue qui a pour indice images_inconnues[0] dans la base digits (soit 1700).\n\n# image inconnue d'indice 1700 dans la base\nprint(\"Tableau de l'image inconnue : \", digits.images[images_inconnues[0]])\n# on applique l'algorithme KNN avec 7 voisins\nchiffrePredit = prediction(digits.data[images_inconnues[0]], 7)\nprint(\"Je prédis que l'image est un : \", chiffrePredit)\nprint(\"L'image est en réalité un : \", digits.target[images_inconnues[0]])\nif chiffrePredit == digits.target[images_inconnues[0]]:\n    print(\"La prédiction est correcte : je suis un très bon algorithme !\")\n\n# représentation graphique de l'image testée\nplt.gray()\nplt.matshow(digits.images[images_inconnues[0]])\nplt.show()\n\nVous pouvez modifier le code précédent pour tester d’autres images en remplaçant l’indice 0 par un autre indice inférieur à 97. Vous pouvez aussi tester l’algorithme avec d’autres valeurs de k.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "TP : Reconnaissance optique de chiffres"
    ]
  },
  {
    "objectID": "25_kppv/KNN-TP.html#testez-maintenant-votre-écriture",
    "href": "25_kppv/KNN-TP.html#testez-maintenant-votre-écriture",
    "title": "TP : Reconnaissance optique de chiffres",
    "section": "3. Testez maintenant votre écriture",
    "text": "3. Testez maintenant votre écriture\n\n3.1 Une feuille à carreaux et un crayon !\n\nSur une feuille à carreaux, dessinez un cadre de 8 X 8\nEcrivez le chiffre de votre choix\nManuellement, indiquez les niveaux de couleurs pour chaques cases\n\nComment indiquer un niveau ?\n\nSi votre trait de stylo ne se trouve pas dans une case -&gt; valeur = 0\nSi votre trait se trouve entièrement (au centre de) dans la case -&gt; valeur = 16\nSi votre trait se trouve un peu (+/-) dans la case -&gt; 0 &lt; valeur &lt; 16\n\nUn exemple :\n\n\nk = 7\n\n# Remplacez cette liste par la votre !\ninconnue = [0., 0., 0., 0., 3., 3., 0., 0., \\\n            0., 0.,16.,15.,14.,11., 0., 0., \\\n            0., 0., 0., 0.,16., 7., 0., 0., \\\n            0., 0., 5.,16.,16., 8., 0., 0., \\\n            0., 0., 0., 0.,16., 5., 0., 0., \\\n            0., 0., 0., 0., 0.,16., 0., 0., \\\n            0., 0.,16.,16.,16.,16., 8., 0., \\\n            0., 0., 0., 0., 0., 0., 0., 0.]\n\n\n\n3.2 comparez votre chiffre manuscrit à l’image créee.\nEst ce que cela ressemble ?\n\n# Tracé de l'image manuscrite numérisée\nmonChiffre = [inconnue[i:i + 8] for i in range(0, len(inconnue), 8)]\nprint(inconnue)\nplt.gray()\nplt.matshow(monChiffre)\nplt.show()\n\nVous pouvez maintenant faire reconnaître votre chiffre par l’algorithme KNN :\n\n#Exécutez ce programme pour lancer la reconnaissance\n\nif len(inconnue) != 8*8 :\n    print(f\"Dimensions incorrectes de l'image ! votre image doit faire 8x8 et elle fait {len(inconnue)} pixels !\")\n\nelse:\n    # on applique l'algorithme KNN avec 7 voisins\n        chiffrePredit = prediction(inconnue, 7)\nprint(\"Je prédis que l'image est un : \", chiffrePredit)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "TP : Reconnaissance optique de chiffres"
    ]
  },
  {
    "objectID": "24_protocoles/index.html",
    "href": "24_protocoles/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nTransmission de données dans un réseau. Protocoles de communication. Architecture d’un réseau\nMettre en évidence l’intérêt du découpage des données en paquets et de leur encapsulation. Dérouler le fonctionnement d’un protocole simple de récupération de perte de paquets (bit alterné). Simuler ou mettre en oeuvre un réseau.\nLe protocole peut être expliqué et simulé en mode débranché. Le lien est fait avec ce qui a été vu en classe de seconde sur le protocole TCP/IP. Le rôle des différents constituants du réseau local de l’établissement est présenté."
  },
  {
    "objectID": "24_protocoles/index.html#points-traités-dans-cette-séquence",
    "href": "24_protocoles/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nTransmission de données dans un réseau. Protocoles de communication. Architecture d’un réseau\nMettre en évidence l’intérêt du découpage des données en paquets et de leur encapsulation. Dérouler le fonctionnement d’un protocole simple de récupération de perte de paquets (bit alterné). Simuler ou mettre en oeuvre un réseau.\nLe protocole peut être expliqué et simulé en mode débranché. Le lien est fait avec ce qui a été vu en classe de seconde sur le protocole TCP/IP. Le rôle des différents constituants du réseau local de l’établissement est présenté."
  },
  {
    "objectID": "23_reseaux/reseaux_cours.html",
    "href": "23_reseaux/reseaux_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Ce cours a pour but de présenter la constitution classique d’un réseau et les équipements associés. La partie relative aux protocoles utilisés lors des échanges entre deux machines est détaillée dans le cours suivant.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 6 - Réseaux",
      "Cours"
    ]
  },
  {
    "objectID": "23_reseaux/reseaux_cours.html#premier-réseau-local",
    "href": "23_reseaux/reseaux_cours.html#premier-réseau-local",
    "title": "Cours",
    "section": "1. Premier réseau local",
    "text": "1. Premier réseau local\nAu sein du logiciel Filius, créons le réseau local ci-dessous :\n\nTestons le ping de la machine 192.168.0.1 vers la machine 192.168.0.3.\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\n\n\n\n\n1.1. La carte réseau et son adresse MAC\nChaque ordinateur sur le réseau dispose d’une adresse MAC (Media Access Control), qui est une valeur unique attribuée à sa carte réseau (Ethernet, Wifi, 4G, 5G, …) lors de sa fabrication en usine.\nCette adresse est codée sur 48 bits, présentés sous la forme de 6 octets en hexadécimal. Exemple : fc:aa:14:75:45:a5\nLes trois premiers octets correspondent au code du fabricant.\nUn site comme https://www.macvendorlookup.com/ vous permet de retrouver le fabricant d’une adresse MAC quelconque.\n\n\n1.2. Switch, hub, quelle différence ?\n\nAu sein d’un hub Ethernet (de moins en moins vendus), il n’y a aucune analyse des données qui transitent : il s’agit simplement d’un dédoublement des fils de cuivre (tout comme une multiprise électrique). L’intégralité des messages est donc envoyée à l’intégralité des ordinateurs du réseau, même s’ils ne sont pas concernés.\n\n\n\nAu sein d’un switch Ethernet, une analyse est effectuée sur la trame qui est à distribuer. Lors d’un branchement d’un nouvel ordinateur sur le switch, celui-ci récupère son adresse MAC, ce qui lui permet de trier les messages et de ne les distribuer qu’au bon destinataire.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 6 - Réseaux",
      "Cours"
    ]
  },
  {
    "objectID": "23_reseaux/reseaux_cours.html#un-deuxième-sous-réseau",
    "href": "23_reseaux/reseaux_cours.html#un-deuxième-sous-réseau",
    "title": "Cours",
    "section": "2. Un deuxième sous-réseau",
    "text": "2. Un deuxième sous-réseau\nRajoutons un deuxième sous-réseau de la manière suivante (penser à bien renommer les switchs).\n\nComment relier ces deux sous-réseaux ?\nUne réponse pas si bête : avec un câble entre les deux switchs !\n\nTestons cette hypothèse en essayant d’envoyer un ping à la machine 192.168.1.2 depuis la machine 192.168.0.1.\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\nCela ne marche pas. L’ordinateur refuse d’envoyer le ping vers la machine 192.168.1.2.\n(nous le verrons plus loin : car elle n’est pas dans son sous-réseau)\n\n\n\nTemporairement, renommons la machine 192.168.1.2 en 192.168.0.33. Testons à nouveau le ping depuis la machine 192.168.0.1.\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\nCela marche. Les paquets sont bien acheminés.\n\n\n\nDans la deuxième situation, les machines sont considérées comme faisant partie du même sous-réseau. Dans la première situation, elles sont considérées comme faisant partie de deux sous-réseaux différents. Mais comment est-ce déterminé ? C’est ce que nous allons voir dans la suite.\n\n2.1. Notion de masque de sous-réseau\nDans Filius, lors de l’attribution de l’adresse IP à une machine, une ligne nous permet de spécifier le masque de sous-réseau (appelé simplement « Masque » dans Filius). C’est ce masque qui va permettre de déterminer si une machine appartient à un sous-réseau ou non, en fonction de son adresse IP.\n\n\n2.1.1 Explication basique\n\nSi le masque est 255.255.255.0, toutes les machines partageant les mêmes trois premiers nombres de leur adresse IP appartiendront au même sous-réseau. Comme ceci est le réglage par défaut de Filius, cela explique pourquoi 192.168.0.33 et 192.168.0.1 sont sur le même sous-réseau, et pourquoi 192.168.1.2 et 192.168.0.1 ne sont pas sur le même sous-réseau.\n\nDans cette configuration, 256 machines peuvent donc appartenir au même sous-réseau (ce n’est pas tout à fait le cas, car les adresses finissant par 0 ou par 255 sont réservées).\n\nSi le masque est 255.255.0.0, toutes les machines partageant les mêmes deux premiers nombres de leur adresse IP appartiendront au même sous-réseau.\n\nDans cette configuration, 65 536 machines peuvent être dans le même sous-réseau. (car 256^2=65536)\nExercice\n\nRenommons 192.168.0.33 en 192.168.1.2 et modifions son masque en 255.255.0.0.\nModifions aussi le masque de 192.168.0.1 en 255.255.0.0.\nTestons le ping de 192.168.0.1 vers 192.168.1.2.\n\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\nCela marche. Les deux machines appartiennent maintenant au même sous-réseau.\n\n\n\n\n\n2.1.2 Explication avancée\nLorsqu’une machine A veut envoyer un message à une machine B, elle doit déterminer si cette machine :\n\nappartient au même sous-réseau : auquel cas le message est envoyé directement via un ou plusieurs switchs.\nn’appartient pas au même sous-réseau : auquel cas le message doit d’abord transiter par un routeur (voir 3.)\n\nQuelle opération permet de distinguer cette appartenance à un même sous-réseau ?\nAppelons IP_A et IP_B les adresses IP respectives des machines A et B.\nAppelons M le masque de sous-réseau.\nNommons & l’opérateur de conjonction entre nombres binaires : il s’agit d’un ET bit à bit.\n\n\n\n\n\n\nPropriété\n\n\n\nA et B appartiennent au même sous-réseau ⇔ IP_A & M = IP_B & M\n\n\nExemple : considérons trois machines A, B, C d’IP respectives 192.168.129.10, 192.168.135.200 et 192.168.145.1, configurées avec un masque de sous-réseau égal à 255.255.248.0.\n\n\n\n\nmachine A\nmachine B\nmachine C\n\n\n\n\nIP\n192.168.129.10\n192.168.135.200\n192.168.145.1\n\n\nM\n255.255.248.0\n255.255.248.0\n255.255.248.0\n\n\nIP & M\n192.168.128.0\n192.168.128.0\n192.168.144.0\n\n\n\nRègles de calcul pour le ET bit à bit :\n\npour tout octet x, x & 255 = x et x & 0 = 0.\n129 & 248 s’écrit en binaire 10000001 & 11111000 qui vaut 10000000, soit 128 en décimal.\n\nConclusion : les machines A et B sont sous le même sous-réseau, mais pas la machine C.\n\n\n2.1.3 Cohérence entre les deux explications\nLorsqu’un masque de sous-réseau est égal à 255.255.255.0, l’opération de conjonction & avec chaque IP ne laissera intacts que les 3 premiers octets, le dernier sera égal à 0. Donc si deux adresses s’écrivent A.B.C.X et A.B.C.Y, elles appartiendront au même sous-réseau (c’est le cas de 192.168.0.33 et 192.168.0.1).\n\n\n\n2.2 Écriture des masques de sous-réseau : notation CIDR\nD’après ce qui précède, 2 informations sont nécessaires pour déterminer le sous-réseau auquel appartient une machine : son IP et le masque de sous-réseau.\nUne convention de notation permet d’écrire simplement ces deux renseignements : la notation CIDR.\nExemple : Une machine d’IP 192.168.0.33 avec un masque de sous-réseau 255.255.255.0 sera désignée par 192.168.0.33 / 24 en notation CIDR.\nLe suffixe / 24 signifie que le masque de sous-réseau commence par 24 bits consécutifs de valeur 1 : le reste des bits (donc 8 bits) est mis à 0.\nAutrement dit, ce masque vaut 11111111.11111111.11111111.00000000 , soit 255.255.255.0.\nDe la même manière, le suffixe / 16 donnera un masque de 11111111.11111111.00000000.00000000 , soit 255.255.0.0.\nOu encore, un suffixe / 21 donnera un masque de 11111111.11111111.11111000.00000000 , soit 255.255.248.0.\n\n\n2.3 Adresses IP et masques : ce qu’il faut retenir\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLes ordinateurs s’identifient sur les réseaux à l’aide d’une adresse IP (Internet Protocol).\nSuivant la norme IPv4, les adresses IP sont encodées sur 4 octets : on parle d’IPv4.\nChaque octet pouvant varier de la valeur (décimale) 0 à 255, cela signifie que les adresses IP théoriquement possibles vont de 0.0.0.0 à 255.255.255.255.\nIl y a donc \\(256^4=4 294 967 296\\) adresses possibles. On a longtemps cru que ce nombre serait suffisant. Ce n’est plus le cas, on est donc en train de passer sur des adresses à 6 octets (en hexadécimal) : voir la norme IPv6.\n\n\n\nExemple\n\n\n\nimage",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 6 - Réseaux",
      "Cours"
    ]
  },
  {
    "objectID": "23_reseaux/reseaux_cours.html#un-vrai-réseau-contenant-deux-sous-réseaux-distincts-la-nécessité-dun-routeur",
    "href": "23_reseaux/reseaux_cours.html#un-vrai-réseau-contenant-deux-sous-réseaux-distincts-la-nécessité-dun-routeur",
    "title": "Cours",
    "section": "3. Un vrai réseau contenant deux sous-réseaux distincts : la nécessité d’un routeur",
    "text": "3. Un vrai réseau contenant deux sous-réseaux distincts : la nécessité d’un routeur\nNotre solution initiale (relier les deux switchs par un câble pour unifier les deux sous-réseaux) n’est pas viable à l’échelle d’un réseau planétaire.\nPour que les machines de deux réseaux différents puissent être connectées, on va utiliser un dispositif équipé de deux cartes réseaux, situé à cheval entre les deux sous-réseaux. Cet équipement de réseau est appelé routeur ou passerelle.\n\n\n3.1 Principe de fonctionnement\nImaginons que la machine 192.168.0.1 / 24 veuille communiquer avec la machine 172.16.52.3 / 24.\nL’observation du masque de sous-réseau de la machine 192.168.0.1 / 24 nous apprend qu’elle ne peut communiquer qu’avec les adresses de la forme 192.168.0.X / 24, où X est un nombre entre 0 et 255.\nLes 3 étapes du routage :\n\nLorsque qu’une machine A veut envoyer un message à une machine B, elle va tout d’abord vérifier si cette machine appartient à son réseau local. Si c’est le cas, le message est envoyé par l’intermédiaire du switch qui relie les deux machines.\nSi la machine B n’est pas trouvée sur le réseau local de la machine A, le message va être acheminé vers le routeur, par l’intermédiaire de son adresse de passerelle (qui est bien une adresse appartenant au sous-réseau de A).\nDe là, le routeur va regarder si la machine B appartient au deuxième sous-réseau auquel il est connecté. Si c’est le cas, le message est distribué, sinon, le routeur va donner le message à un autre routeur auquel il est connecté et va le charger de distribuer ce message : c’est le procédé (complexe) de routage qui sera abordé en classe de Terminale.\n\nDans notre exemple, l’adresse 172.16.52.3 n’est pas dans le sous-réseau de 192.168.0.1. Le message va donc transiter par le routeur.\n\n\n\n3.2 Illustration avec Filius\n\nRajoutons un routeur entre le SwitchA et le SwitchB. \nConfiguration du routeur :\n\nL’interface reliée au Switch A doit avoir une adresse du sous-réseau A. On donne souvent une adresse finissant par 254, qui est en quelque sorte la dernière adresse du réseau (en effet l’adresse en 255 est appelée adresse de broadcast, utilisée pour envoyer un ping en une seule fois à l’intégralité d’un sous-réseau).\n\nOn donne donc l’adresse 192.168.0.254 pour l’interface reliée au Switch A, et 192.168.1.254 pour l’interface reliée au Switch B.\n\n\n\nDans l’onglet général, sélectionner « Routage automatique ».\nAinsi configuré notre routeur peut jouer le rôle de passerelle entre les deux sous-réseaux.\n\n\n\n\n\n\n\n\nRésultat du ping\n\n\n\n\n\n\nCela ne marche pas. La carte réseau refuse d’envoyer les paquets, car elle ne sait pas où les envoyer.\n\n\n\nPourquoi cet échec ? Parce que nous devons dire à chaque machine qu’une passerelle est maintenant disponible pour pouvoir sortir de son propre sous-réseau. Il faut donc aller sur la machine 192.168.0.1 et lui donner l’adresse de sa passerelle, qui est 192.168.0.254.\n\nAttention, il faut faire de même pour 192.168.1.2 (avec la bonne passerelle…)\nTestons à nouveau le ping… Cette fois cela marche.\nPlus intéressant : effectuons un traceroute entre 192.168.0.1 et 192.168.1.2.\n\nOn constate que la machine 192.168.1.2 est atteignable en deux sauts depuis 192.168.0.1, en passant par la passerelle 192.168.0.254\nCas d’un réseau domestique\nChez vous, la box de votre opérateur joue simultanément le rôle de switch et de routeur :\n\nswitch, car elle répartit la connexion entre les différents dispositifs (ordinateurs branchés en ethernet, smartphone en wifi, tv connectée…)\nrouteur, car elle fait le lien entre ce sous-réseau domestique (les appareils de votre maison) et le réseau internet.\n\n\nL’image ci-dessous présente le résultat de la commande ipconfig sous Windows. On y retrouve l’adresse IP locale 192.168.9.103, le masque de sous-réseau 255.255.255.0 et l’adresse de la passerelle 192.168.9.1.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 6 - Réseaux",
      "Cours"
    ]
  },
  {
    "objectID": "22_tables/tables_quiz.html",
    "href": "22_tables/tables_quiz.html",
    "title": "Quiz : Données en tables",
    "section": "",
    "text": "Dans la plupart des fichiers CSV, que contient la première ligne ?\n\nRéponse A : des notes concernant la table de données\nRéponse B : les sources des données\nRéponse C : les descripteurs des champs de la table de données\nRéponse D : l’auteur de la table de données\n\nLaquelle de ces affirmations est vraie ?\n\nRéponse A : on ne peut accéder au contenu d’un fichier CSV que par l’intermédiaire d’un programme Python\nRéponse B : CSV est un format de chiffrement des données\nRéponse C : le format CSV a été conçu pour assurer la confidentialité d’une partie du code d’un programme\nRéponse D : les fichiers CSV sont composés de données séparées par des caractères comme des virgules\n\nQu’est-ce que le format de fichier CSV ?\n\nRéponse A : un format de fichier mis au point par Microsoft pour Excel\nRéponse B : un format de fichier pour décrire une base de données\nRéponse C : un format de fichier où les données sont séparées par un caractère tel qu’une virgule\nRéponse D : un format de fichier décrivant une page Web\n\nOn considère l’extraction suivante d’une base de données des départements français. Cette extraction a ensuite été sauvegardée dans un fichier texte.\n\"1\",\"01\",\"Ain\",\"AIN\",\"ain\",\"A500\"\n\"2\",\"02\",\"Aisne\",\"AISNE\",\"aisne\",\"A250\"\n\"3\",\"03\",\"Allier\",\"ALLIER\",\"allier\",\"A460\"\n\"4\",\"04\",\"Alpes-de-Haute-Provence\",\"ALPES-DE-HAUTE-PROVENCE\",\"alpes-de-haute-provence\",\"A412316152\"\n\"5\",\"05\",\"Hautes-Alpes\",\"HAUTES-ALPES\",\"hautes-alpes\",\"H32412\"\nOn considère le code suivant :\nimport csv\n\nf = open('departements.csv', mode='r', encoding='UTF-8', newline='')\nlesLignes = csv.reader(f)\nfor uneLigne in lesLignes:\n    print(uneLigne[3])\nf.close()\nQue va produire l’exécution de ce code ?\n\nRéponse A : L’affichage de la troisième colonne à savoir le nom du département avec une majuscule initiale\nRéponse B : L’affichage de tout le contenu du fichier\nRéponse C : L’affichage du nombre total de départements figurant dans le fichier\nRéponse D : L’affichage de la quatrième colonne, à savoir le nom du département tout en majuscules\n\nOn dispose du fichier 'info.csv' donné ci-dessous :\nnom, prenom, naissance, deces\nlovelace, ada, 1815, 1852\nvon neumann, john, 1903, 1957\nturing, alan, 1912, 1954\nmccarthy, john, 1927, 2011\nfloyd, robert, 1936, 2001\nLe programme ci-dessous nous permet de créer un tableau à partir de ce fichier.\nfile = open(\"info.csv\", \"r\")\nfirstLine = file.readline()  # chargement de la ligne d'entête\ntableau = [line.split(',') for line in file]  # chargement des données\nLes index des lignes de ce tableau vont :\n\nRéponse A : de 0 à 3\nRéponse B : de 1 à 4\nRéponse C : de 0 à 4\nRéponse D : de 0 à 5\n\nQuelle expression Python permet d’accéder au numéro de téléphone de Tournesol, sachant que le répertoire a été défini par l’affectation suivante :\nrepertoire = [{'nom': 'Dupont', 'tel': '5234'},\n          {'nom': 'Tournesol', 'tel': '5248'},\n          {'nom': 'Dupond', 'tel': '3452'}]\n\nRéponse A : repertoire['Tournesol']\nRéponse B : repertoire['tel'][1]\nRéponse C : repertoire[1]['tel']\nRéponse D : repertoire['Tournesol'][tel]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz : Données en tables"
    ]
  },
  {
    "objectID": "22_tables/tables_cours.html",
    "href": "22_tables/tables_cours.html",
    "title": "Traitements de données en tables (cours)",
    "section": "",
    "text": "Ce cours dans Capytale\n\n\n\nCliquer ici",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Traitements de données en tables (cours)"
    ]
  },
  {
    "objectID": "22_tables/tables_cours.html#table-de-données-et-indexation",
    "href": "22_tables/tables_cours.html#table-de-données-et-indexation",
    "title": "Traitements de données en tables (cours)",
    "section": "1. Table de données et indexation",
    "text": "1. Table de données et indexation\n\n1.1. Vocabulaire\n\n\n\n\n\n\nDéfinition\n\n\n\nDes données, numériques ou non, sont souvent représentées sous forme de tableaux, ou tables.\nVocabulaire :\n\nUne table, représentée sous forme de tableau, est une collection d’éléments qui sont les lignes du tableau.\nChaque élément de la table, ou ligne de sa représentation sous forme de tableau, s’appelle un enregistrement.\n\nTous les enregistrements d’une même table sont des p-uplets nommés qui partagent les mêmes descripteurs, appelés aussi attributs. Dans une représentation de la table sous forme de tableau, chaque attribut correspond à une colonne. Chaque attribut est caractérisé par son type et son domaine de valeurs (les valeurs que peut prendre cet attribut).\n\nDans une représentation sous forme de tableau, les descripteurs ou attributs sont en général placés comme en-tête de colonnes sur la première ligne.\n\n\n\n\n\n\ntableur\n\n\n\n\n\n\n\n\nExemple\n\n\n\nLa table représentée ci-dessus est affichée dans un tableur. Nous voyons les 20 premiers enregistrements de cette table qui rassemble des données sur tous les établissements scolaires primaires et secondaires dans le Cantal (source : https://www.data.gouv.fr/fr/).\nLes attributs de cette table sont :\n\nle code UAI (Unité Administrative Immatriculée) avec un domaine de valeurs particulier ;\nle nom avec pour domaine de valeur les chaînes de caractères ;\nle statut avec pour domaine de valeur les deux chaînes {“Public”, “Privé”} ;\nle codepostal avec un domaine de valeurs particulier ;\nla commune avec pour domaine de valeur les chaînes de caractères ;\nla latitude et la longitude avec pour domaine de valeur les flottants.\n\n\n\n\n\n1.2. Échange de table de données avec un fichier CSV\nPour échanger des données tabulaires entre les programmes qui doivent les manipuler, on les exporte puis les importe sous la forme de fichiers textes, c’est-à-dire lisibles par l’être humain.\nAfin d’assurer l’interopérabilité entre différents programmes, un fichier doit respecter un format normalisé.\nL’un des formats les plus répandus pour l’échange de données tabulaires est le format CSV pour Comma Separated Values :\n\nun fichier CSV est un fichier texte donc éditable avec un éditeur de textes comme Notepad++. On peut aussi l’éditer dans un tableur ;\nchaque ligne du fichier correspond à un enregistrement de la table ;\npour un enregistrement donné, les valeurs des différents attributs sont séparées en champs par un délimiteur qui est en général l’un des symboles , ou ; ou : ;\nla première ligne contient en général les noms des attributs.\n\nVoici la même table que celle qui est affichée dans un tableur ci-dessus, au format CSV :\n\n\netablissements.csv\n\ncode,nom,statut,codepostal,commune,latitude,longitude\n0150424E,Ecole maternelle de La Fontaine,Public,15000,AURILLAC,44.93215113696133,2.4472797795526975\n0150426G,Ecole élémentaire La Jordanne,Public,15000,AURILLAC,44.91746484780829,2.4412899019318455\n0150713U,Ecole élémentaire Belbex,Public,15000,AURILLAC,44.91692385174704,2.420740047835959\n0150669W,Ecole élémentaire de Canteloube,Public,15000,AURILLAC,44.90604342702414,2.4320205660195438\n0150695Z,Ecole élémentaire Paul Doumer,Public,15000,AURILLAC,44.92315413405051,2.4369699098202613\n0150708N,Collège privé Gerbert,Privé,15000,AURILLAC,44.915101259869516,2.4353907452880663\n0150082H,Ecole élémentaire privée Externat de L'Enfant-Jésus,Privé,15000,AURILLAC,44.925334485056936,2.4395702526084304\n0150430L,Ecole élémentaire Le Palais,Public,15000,AURILLAC,44.92790494767797,2.44295019912506\n0150431M,Ecole élémentaire Jean-Baptiste Rames,Public,15000,AURILLAC,44.92587579761087,2.443909493077494\n0150639N,Collège Jeanne de La Treilhe,Public,15000,AURILLAC,44.931332705102776,2.446920262863509\n0150340N,Ecole élémentaire Tivoli,Public,15000,AURILLAC,44.91458511629758,2.437120525044205\n0150420A,Ecole élémentaire des Frères Delmas,Public,15000,AURILLAC,44.93257502395094,2.448510197138493\n0150427H,Ecole élémentaire Les Alouettes,Public,15000,AURILLAC,44.931185754042616,2.4377296545614717\n0150760V,Lycée Polyvalent privé Gerbert,Privé,15000,AURILLAC,44.91492261677949,2.435849985504045\n0150761W,Section d'enseignement professionnel du Lycée privé Gerbert,Privé,15000,AURILLAC,44.91510125343173,2.435389478195114\n0150773J,Ecole élementaire privée La Calandreta del Vernhat,Privé,15000,AURILLAC,44.90477730883497,2.434630577068397\n0150006A,Lycée polyvalent Monnet-Mermoz - Lycée des métiers des sciences et techniques appliquées à l'industrie et aux services,Public,15005,AURILLAC CEDEX,44.93647192501501,2.4525295902159927\n0150036H,Section d'enseignement professionnel du Lycée Monnet-Mermoz,Public,15005,AURILLAC CEDEX,44.93588796606886,2.451329778620416\n0150646W,Lycée général Emile Duclaux,Public,15005,AURILLAC CEDEX,44.927782859640786,2.439440592922277\n\nOn observe que le délimiteur de champ est le symbole , et que les champs peuvent contenir des espaces.\nDans un tel jeu de données, il peut y avoir des champs vides dans certains enregistrements et il se peut aussi que le nombre de champs pour un ne corresponde pas au nombre d’attributs ! Pour traiter un tel fichier avec un programme, il faut d’abord analyser sa structure, ses particularités et prévoir d’éventuelles irrégularités dans les données (absence, erreurs de type, de saisie, corruption du fichier …). Le contrôle de la validité des données doit donc être une composante du programme de traitement : recherche de doublons, tests de cohérence.\n\n\n1.3. Manipulation de fichiers CSV en Python\n\n\n\n\n\n\nDéfinition\n\n\n\nL’indexation de table est la création d’une structure de données à partir d’une table de données.\nL’indexation d’une table extraite d’un fichier CSV peut se faire vers une structure de données du langage Python : tableau de tableaux ou (mieux) tableau de dictionnaires.\n\n\nDans cette section, on considère le fichier CSV, educ_cantal.csv, contenant les enregistrements des établissements scolaires primaires et secondaires dans le Cantal.\nPrésentons deux méthodes de lecture de fichiers CSV qui utilisent les outils standards de Python.\nOn fait les hypothèses suivantes : la première ligne du fichier contient les attributs et on connaît le délimiteur, ici le symbole ,.\n\n\nAvec un tableau de tableaux\n\nLecture\n\nOn peut extraire les attributs et la table contenus dans le fichier educ_cantal.csv avec le code ci-dessous :\n\n# ouverture du fichier en mode lecture\nfichier = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')\n# extraction de la ligne des attributs\nattributs = fichier.readline().rstrip().split(',')\n# extraction des autres lignes\ntable = [ligne.rstrip().split(',') for ligne in fichier]\n# fermeture du fichier\nfichier.close()\n\nLa fonction open permet de créer un objet fichier qu’on peut parcourir ligne par ligne avec un curseur : d’abord la première ligne avec fichier.readline() puis les lignes suivantes en itérant sur fichier. Il est important de préciser l’encodage du fichier, par défaut c’est celui du système d’exploitation.\nChaque ligne est une chaîne de caractères découpée en liste de champs selon le délimiteur passé en paramètre à la méthode split. Le caractère de saut de lignes a d’abord été supprimé avec la méthode rstrip.\nOn récupère ainsi les attributs comme un tableau de type list et la table comme un tableau d’enregistrements qui sont eux-mêmes des tableaux. Notons que toutes les valeurs sont des chaînes de caractères et qu’il faudra convertir certaines pour les traiter !\n\nprint(attributs)\nprint(table[18])\nprint(table[:2])\n\n['code', 'nom', 'statut', 'codepostal', 'id_commune', 'latitude', 'longitude']\n['0150030B', 'Lycée polyvalent de Haute Auvergne', 'Public', '15101', '187', '45.0352036275507', '3.0819798437208243']\n[['0150001V', 'Collège Maurice Peschaud', 'Public', '15160', '1', '45.230605740493495', '2.9353501250960568'], ['0150005Z', 'Collège La Jordanne', 'Public', '15005', '14', '44.92112535663867', '2.4404905355487023']]\n\n\n\nÉcriture\n\nOn peut ensuite recopier les attributs et la table dans un autre fichier educ_cantal_copie.csv avec le code ci-dessous :\n\ng = open('educ_cantal_copie.csv', mode='w', encoding='utf8', newline='') # ouverture du fichier en mode écriture\npremiere_ligne = ','.join(attributs) + '\\n'\ng.write(premiere_ligne)\nfor enregistrement in table:\n    g.write(','.join(enregistrement) + '\\n')\ng.close()\n\nLa méthode join permet de concaténer les éléments d’un tableau de chaînes de caractères avec un délimiteur.\n\nAvec ces méthodes, une table est donc représentée par un tableau de tableaux. On accède à un enregistrement par son index dans la table et à la valeur d’un attribut par son index dans le tableau des attributs (séparé de la table). C’est incommode et le code produit est peu lisible. Ainsi, pour accéder à l’adresse mail du premier enregistrement il faut saisir table[0][2]. On aimerait écrire table[0]['email']. Pour cela, chaque enregistrement devrait être un p-uplet nommé que nous représenterons par dictionnaire avec pour clefs les attributs de la table. C’est possible en utilisant le module csv.\n\n\n\nAvec un tableau de dictionnaires\nLe module csv est disponible dans la bibliothèque standard et peut donc être utilisé sans installation spécifique. À partir de la table contenue dans le même fichier CSV 'educ_cantal.csv', ce module permet de créer une structure de données d’un accès plus facile.\n\nLecture\n\nLe code ci-dessous permet d’extraire directement la table d’un fichier CSV dans une structure de données qui est un tableau de dictionnaires : chaque enregistrement est un dictionnaire dont les clefs sont les attributs listés sur la première ligne du fichier.\nRemarque : pour les versions de Python 3.6 et 3.7 uniquement, les dictionnaires renvoyés sont spécifiques, de type OrderedDict, et on prendra soin de les convertir en dictionnaires standard avec dict en entrant : table = [dict(enregistrement) for ...].\n\nimport csv\n\nf = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')\nreader = csv.DictReader(f, delimiter=',')  # création d'un objet reader\ntable = [enregistrement for enregistrement in reader]\nf.close()\n\nLa structure de données représentant la table est un tableau de dictionnaires : l’accès aux enregistrements se fait par index et à leurs attributs par clef : très efficace (coût constant) et code lisible. Notons que toutes les valeurs restent des chaînes de caractères et qu’il faudra convertir certaines pour les traiter !\n\n# premier enregistrement de type dictionnaire\nprint(table[18])\n# tableu de dictionnaires : extrait\nprint(table[:2])\n# nombre d'enregistrements\nprint(len(table))\n# accès facile aux valeurs des attributs par clefs\nprint(table[18][\"nom\"])\n\n{'code': '0150030B', 'nom': 'Lycée polyvalent de Haute Auvergne', 'statut': 'Public', 'codepostal': '15101', 'id_commune': '187', 'latitude': '45.0352036275507', 'longitude': '3.0819798437208243'}\n[{'code': '0150001V', 'nom': 'Collège Maurice Peschaud', 'statut': 'Public', 'codepostal': '15160', 'id_commune': '1', 'latitude': '45.230605740493495', 'longitude': '2.9353501250960568'}, {'code': '0150005Z', 'nom': 'Collège La Jordanne', 'statut': 'Public', 'codepostal': '15005', 'id_commune': '14', 'latitude': '44.92112535663867', 'longitude': '2.4404905355487023'}]\n203\nLycée polyvalent de Haute Auvergne\n\n\n\nÉcriture\n\nL’écriture d’un tableau de dictionnaires partageant les mêmes clefs sous forme de table dans un fichier CSV, s’effectue de façon symétrique à travers un objet DictWriter. À titre, d’exemple, on recopie la table extraite précédemment dans un autre fichier CSV. Depuis Python 3.7, le parcours des clefs d’un dictionnaire est garanti dans le même ordre que celui d’insertion donc on peut récupérer la liste des attributs avec list(table[0].keys())\n\ng = open('educ_cantal_copie2.csv', mode='w', encoding='utf8', newline='')\nattributs = list(table[0].keys())\nwriter = csv.DictWriter(g, delimiter=',', fieldnames=attributs)  # création de l'objet writer\nwriter.writeheader()  # écriture des attributs\nfor enregistrement in table:\n    writer.writerow(enregistrement)  # écriture des enregistrements\ng.close()\n\n\nRemarque\n\nLe module csv permet aussi d’extraire une table d’un fichier CSV sous forme de tableau de tableaux comme dans la méthode précédente. Le découpage des lignes/enregistrements selon le délimiteur est intégré ce qui simplifie le code.\n\nf = open('educ_cantal.csv', mode='r', encoding='utf8', newline='')\nreader = csv.reader(f, delimiter=',')\ntable = [ligne for ligne in reader]\nf.close()",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Traitements de données en tables (cours)"
    ]
  },
  {
    "objectID": "22_tables/tables_cours.html#recherche-dans-une-table",
    "href": "22_tables/tables_cours.html#recherche-dans-une-table",
    "title": "Traitements de données en tables (cours)",
    "section": "2. Recherche dans une table",
    "text": "2. Recherche dans une table\nPour accéder aux données, il faut les rechercher et les regrouper suivant différents critères.\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLorsqu’on souhaite accéder à un ou plusieurs enregistrements vérifiant un critère, on réalise une sélection.\nLorsqu’on souhaite accéder à toutes les données d’une colonne on réalise une projection.\n\n\n\n\nExemple de sélection\nSupposons qu’on dispose d’une table enregistrée dans une liste de dictionnaires :\n\nTable1 = [\n    {'Nom': 'Joe', 'Anglais': '17', 'Info': '18', 'Maths': '16'},\n    {'Nom': 'Zoé', 'Anglais': '15', 'Info': '17', 'Maths': '19'},\n    {'Nom': 'Max', 'Anglais': '19', 'Info': '13', 'Maths': '14'},\n    {'Nom': 'Bob', 'Anglais': '12', 'Info': '16', 'Maths': '10'}\n]\n\nOn souhaite extraire la liste des enregistrements des élèves ayant eu au moins 16 en maths.\nOn peut le faire “à la main” :\n\nau_moins_16_en_maths = []\nfor enregistrement in Table1:\n    if int(enregistrement['Maths']) &gt;= 16:\n        au_moins_16_en_maths.append(enregistrement)\n\nLe résultat est encore une table :\n\nau_moins_16_en_maths\n\n[{'Nom': 'Joe', 'Anglais': '17', 'Info': '18', 'Maths': '16'},\n {'Nom': 'Zoé', 'Anglais': '15', 'Info': '17', 'Maths': '19'}]\n\n\nOn peut le faire avec une liste en compréhension :\n\nau_moins_16_en_maths = [enre for enre in Table1 if int(enre['Maths']) &gt;= 16]\n\nLe résultat est identique.\n\n\nExemple de projection\nCette fois, on souhaite récupérer toutes les valeurs pour un champ donné, par exemple toutes les notes de mathématiques.\nL’approche est similaire, on crée une liste, on parcourt la table et on ajoute à la liste tous les éléments qui nous intéressent.\n\nà la main :\n\n\nnotes_maths = []\nfor enregistrement in Table1:\n    notes_maths.append(enregistrement['Maths'])\n\n\npar compréhension :\n\n\nnotes_maths = [enre['Maths'] for enre in Table1]\n\nDans les deux cas le résultat est la liste [‘16’, ‘19’, ‘14’, ‘10’].\n\n\n\n\n\n\nExercices\n\n\n\n\nAdapter la sélection afin de récupérer tous les enregistrements des élèves dont le nom comporte un “o”.\nProjeter afin de construire la liste des noms puis celle des paires de notes d’info et de maths :\n[(18, 16), (17, 19), (13, 14), (16, 10)]\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nAvec une boucle :\n\n\nnom_avec_o = []\nfor enregistrement in Table1:\n    if 'o' in enregistrement['Nom']:\n        nom_avec_o.append(enregistrement)\n\nEn compréhension :\n\nnom_avec_o = [enre for enre in Table1 if 'o' in enre['Nom']]\n\n\nListe des noms :\n\n\n# avec une boucle\nliste_noms = []\nfor enregistrement in Table1:\n    liste_noms.append(enregistrement['Nom'])\n\n# avec une liste en compréhension\nliste_noms = [enre['Nom'] for enre in Table1]\n\npaires info/maths\n\n# avec une boucle\nliste_paires = []\nfor enregistrement in Table1:\n    liste_paires.append((enregistrement['Info'], enregistrement['Maths']))\n\n# avec une liste en compréhension\nliste_paires = [(enre['Info'], enre['Maths']) for enre in Table1]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Traitements de données en tables (cours)"
    ]
  },
  {
    "objectID": "22_tables/tables_cours.html#tri-dune-table",
    "href": "22_tables/tables_cours.html#tri-dune-table",
    "title": "Traitements de données en tables (cours)",
    "section": "3. Tri d’une table",
    "text": "3. Tri d’une table\n\n3.1. Tri d’une table selon une colonne\nIl s’agit ici de trier les données d’une table selon un des attributs de la table, c’est-à-dire selon une colonne. Il faut bien sûr pour cela que les données de cet attribut soient “triables”, c’est-à-dire qu’un ordre puisse être défini sur ces données. Pour des données numériques, on peut penser à l’ordre croissant ou à l’ordre décroissant. Pour des données textuelles, à l’ordre alphabétique. On peut aussi vouloir trier les données selon plusieurs champs.\nNous allons pour cela utiliser la fonction Python sorted qui s’applique à un objet de type list et qui renvoie une nouvelle list triée. Outre la table à trier, cette fonction peut prendre deux arguments nommés facultatifs :\n\nreverse = True pour un tri dans l’ordre inverse ;\nkey = ... pour préciser selon quel critère une liste doit être triée.\n\nQuelques exemples :\n\nma_liste = [10, 3, 71, 96]\nprint(sorted(ma_liste))\nprint(sorted(ma_liste, reverse=True))\n\nmes_couples = [('a', 3), ('d', 2), ('c', 5), ('b', 1)]\nprint(sorted(mes_couples))     # tuples triés selon leur premier élément (par défaut)\n\ndef y(couple):    # on définit une fonction qui retourne le second élément d'un tuple\n    return couple[1]\n\nprint(sorted(mes_couples, key=y)) # tuples triés selon leur second élément\n\n[3, 10, 71, 96]\n[96, 71, 10, 3]\n[('a', 3), ('b', 1), ('c', 5), ('d', 2)]\n[('b', 1), ('d', 2), ('a', 3), ('c', 5)]\n\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention, sorted ne renvoie qu’une copie superficielle du tableau ! Si ses éléments sont des références et c’est le cas de l’implémentation des tables de données sous forme de tableaux de dictionnaires, il faut effectuer une copie profonde du tableau avec la fonction deepcopy du module copy pour obtenir une vraie copie triée du tableau initial : sorted(deepcopy(tab), key = clef_tri).\n\n\n\n\n3.2. Tri suivant plusieurs colonnes\nConsidérons la table suivante :\n\ntable = [{'élève' : 'guido', 'langage' : 'python', 'note' : 19},\n         {'élève' : 'monty', 'langage' : 'python', 'note' : 20},\n         {'élève' : 'brian', 'langage' : 'c', 'note' : 20}]\n\nOn souhaite trier en fonction du langage dans l’ordre alphabétique, puis de la note dans l’ordre croissant. La fonction donnée en argument key doit alors retourner la couple ordonné des deux attributs voulus :\n\ndef cle_langage_note(enre):\n    return (enre['langage'], enre['note'])\n\nsorted(table, key = cle_langage_note)\n\n[{'élève': 'brian', 'langage': 'c', 'note': 20},\n {'élève': 'guido', 'langage': 'python', 'note': 19},\n {'élève': 'monty', 'langage': 'python', 'note': 20}]\n\n\nSi l’on souhaite trier dans l’ordre croissant suivant l’attribut langage et décroissant suivant l’attribut note, on procède en deux étapes :\n\ndef cle_langage(enre):\n    return enre['langage']\n\ndef cle_note(enre):\n    return enre['note']\n\ntable_temp = sorted(table, key = cle_langage)\nsorted(table_temp, key = cle_note, reverse = True)\n\n[{'élève': 'brian', 'langage': 'c', 'note': 20},\n {'élève': 'monty', 'langage': 'python', 'note': 20},\n {'élève': 'guido', 'langage': 'python', 'note': 19}]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Traitements de données en tables (cours)"
    ]
  },
  {
    "objectID": "22_tables/tables_cours.html#fusion-de-deux-tables",
    "href": "22_tables/tables_cours.html#fusion-de-deux-tables",
    "title": "Traitements de données en tables (cours)",
    "section": "4. Fusion de deux tables",
    "text": "4. Fusion de deux tables\nIl est courant de travailler avec plusieurs tables de données. Nous avons alors parfois besoin de rassembler deux tables en une seule ou encore de construire une nouvelle table à partir de certains attributs de tables existantes.\n\n4.1. Fusion de deux tables de même structure\nLe cas le plus simple est lorsque nous disposons de deux tables, par exemple sous la forme de tableaux de dictionnaires, qui possèdent exactement les mêmes attributs.\nUne simple concaténation des tableaux permet cette fusion, en prenant garde néanmoins :\n\nà ne pas conserver deux fois la définition des descripteurs ;\nà éviter les doublons : cas d’un enregistrement qui se trouverait dans les deux tables initiales.\n\nSous l’hypothèse qu’il n’y a pas de doublons, le code ci-dessous procède à cette fusion :\n\ndef fusion_tables(table1: list, table2: list) -&gt; list:\n    \"\"\"table 1 et table 2 ont les mêmes descripteurs\n    il n'y a pas de doublons\"\"\"\n    fusion = deepcopy(table1)\n    for enreg in table2[1:]:    # on élimine la première ligne (descripteurs)\n        fusion.append(deepcopy(enreg))\n    return fusion\n\n\n\n4.2. Fusion de deux tables pour un même attribut\nOn veut fusionner deux tables selon un attribut commun. On va sélectionner dans chaque table la ligne ayant la même valeur pour l’attribut choisi.\nReprenons le tableau Table1 des exemples précédents :\n\n\n\nNom\nAnglais\nInfo\nMaths\n\n\n\n\nJoe\n17\n18\n16\n\n\nZoé\n15\n17\n19\n\n\nMax\n19\n13\n14\n\n\n\nDéfinissons une seconde table, Table2 donnant l’âge et le courriel de certains élèves :\n\n\n\nNom\nAge\nCourriel\n\n\n\n\nJoe\n16\njoe@info.fr\n\n\nZoé\n15\nzoe@info.fr\n\n\n\nOn voudrait regrouper les données des deux tables. Elles ont l’attribut Nom en commun. On veut obtenir la table suivante :\n\n\n\nNom\nAge\nCourriel\nAnglais\nInfo\nMaths\n\n\n\n\nJoe\n16\njoe@info.fr\n17\n18\n16\n\n\nZoé\n15\nzoe@info.fr\n15\n17\n19\n\n\n\nOn choisit d’exclure la ligne concernant Max car il n’est pas présent dans la seconde table.\n\n\n\n\n\n\nDéfinition\n\n\n\nEn informatique, la jointure est l’opération permettant d’associer plusieurs tables par le biais d’un lien logique de données entre les différentes tables, le lien étant défini par une condition. Le résultat de l’opération est une nouvelle table.\n\n\nLa jointure s’obtient avec deux boucles imbriquées : on parcourt tous les couples constitués d’enregistrements de la première puis de la seconde table et on filtre à l’aide d’une instruction conditionnelle.\n\nfrom copy import deepcopy\n\nTable1 = [{'Nom': 'Joe', 'Anglais': '17', 'Info': '18', 'Maths': '16'},\n          {'Nom': 'Zoé', 'Anglais': '15', 'Info': '17', 'Maths': '19'},\n          {'Nom': 'Max', 'Anglais': '19', 'Info': '13', 'Maths': '14'},\n          {'Nom': 'Bob', 'Anglais': '12', 'Info': '16', 'Maths': '10'}]\n\nTable2 = [{'Nom': 'Joe', 'Age': 16, 'Couriel': 'joe@info.fr'},\n          {'Nom': 'Zoé', 'Age': 15, 'Couriel': 'zoe@info.fr'}]\n\n\ndef jointure_selon_attribut_commun(t1: list, t2: list, attr: str) -&gt; list:\n    \"\"\"Effectue la jointure entre les tables t1 et t2 selon l'attribut commun attr\"\"\"\n    jointure = []\n    for item1 in t1:\n        for item2 in t2:\n            if item1[attr] == item2[attr]:\n                # définition d'une ligne de la nouvelle table reprenant le contenu de la ligne en cours de t1\n                new_line = deepcopy(item1)\n                # boucle pour ajouter les champs de la ligne de t2 autres que attr\n                for cle in item2:\n                    if cle != attr:\n                        new_line[cle] = item2[cle]\n                # ajout de la nouvelle ligne à la nouvelle table\n                jointure.append(new_line)\n    return jointure\n\n\nprint(jointure_selon_attribut_commun(Table2, Table1, 'Nom'))\n\n[{'Nom': 'Joe', 'Age': 16, 'Couriel': 'joe@info.fr', 'Anglais': '17', 'Info': '18', 'Maths': '16'}, {'Nom': 'Zoé', 'Age': 15, 'Couriel': 'zoe@info.fr', 'Anglais': '15', 'Info': '17', 'Maths': '19'}]\n\n\nRemarque : dans la fonction ci-dessus, on suppose que le nom des attributs est toujours une chaîne de caractères.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Traitements de données en tables (cours)"
    ]
  },
  {
    "objectID": "21_client-serveur/TP_forms.html",
    "href": "21_client-serveur/TP_forms.html",
    "title": "T.P. Formulaires",
    "section": "",
    "text": "Ce T. P. est constitué de deux exercices à réaliser dans Replit.\nÀ chaque fois, le code JavaScript doit être complété afin que la page web interactive se comporte comme attendu.\nPour un bon rendu de la page web, il faut l’ouvrir dans un autre onglet du navigateur.\nExercice 1 : Couleurs - https://replit.com/team/premiere-nsi/TP-Couleurs\nExercice 2 : Températures - https://replit.com/team/premiere-nsi/TP-Temperature"
  },
  {
    "objectID": "21_client-serveur/georisques/projet_georisques.html",
    "href": "21_client-serveur/georisques/projet_georisques.html",
    "title": "Projet : Risques naturels",
    "section": "",
    "text": "L’objectif de ce projet est de produire une page web interactive répondant aux exigences suivantes :\n\nLa page affiche une carte géographique interactive de la France (utilisation d’OpenStreetMap).\nUn clic sur la carte permet de choisir un lieu et de récupérer ses coordonnées géographiques.\nUn script interroge alors le service gouvernemental des géorisques (https://www.georisques.gouv.fr) et affiche la liste des risques naturels recensés dans un rayon de 1000 mètres."
  },
  {
    "objectID": "21_client-serveur/cours_forms.html",
    "href": "21_client-serveur/cours_forms.html",
    "title": "Cours : formulaires",
    "section": "",
    "text": "Les formulaires Web sont l’un des principaux points d’interaction entre un utilisateur et un site Web. Les formulaires permettent aux utilisateurs de saisir des données, qui sont généralement envoyées à un serveur Web pour traitement et stockage, ou utilisées côté client pour mettre à jour immédiatement l’interface d’une manière ou d’une autre (par exemple, ajouter un autre élément à une liste, ou afficher ou masquer une fonctionnalité de l’interface utilisateur).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours : formulaires"
    ]
  },
  {
    "objectID": "21_client-serveur/cours_forms.html#de-nouveaux-éléments-html",
    "href": "21_client-serveur/cours_forms.html#de-nouveaux-éléments-html",
    "title": "Cours : formulaires",
    "section": "1. De nouveaux éléments HTML",
    "text": "1. De nouveaux éléments HTML\nLa création de formulaire repose sur l’utilisation de nouveaux éléments HTML, parmi lesquels :\n\n&lt;form&gt; : élément qui contient tous les autres éléments de formulaire.\n&lt;input&gt; : zone de texte où l’utilisateur peut écrire un texte court. Cet élément possède un attribut particulier nommé type qui modifie beaucoup son comportement. Par exemple, type = \"email\" obligera l’utilisateur à entrer une adresse mail bien formatée. Voir cette page pour découvrir d’autres valeurs possibles de l’attribut type.\n&lt;button&gt; : bouton cliquable qui, dans le cadre des formulaires, peuvent avoir l’attribut type=\"submit\" pour servir à envoyer les données du formulaire, ou type=\"reset\" pour servir à vider tous les champs du formulaire.\n\nIl existe bien d’autres éléments de formulaire, il n’est pas question d’en faire une liste complète ici. Voir les ressources supplémentaires en bas de page pour en savoir plus.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours : formulaires"
    ]
  },
  {
    "objectID": "21_client-serveur/cours_forms.html#fonctionnement-dun-formulaire",
    "href": "21_client-serveur/cours_forms.html#fonctionnement-dun-formulaire",
    "title": "Cours : formulaires",
    "section": "2. Fonctionnement d’un formulaire",
    "text": "2. Fonctionnement d’un formulaire\nPour comprendre le fonctionnement d’un formulaire, il faut se souvenir de l’architecture client/serveur déjà évoquée.\n\n\n\nArchitecture client - serveur\n\n\nLe formulaire, permet de transmettre des informations à un serveur. Ces informations sont envoyées par le client (le navigateur) lorsque le bouton de type submit est cliqué.\nComme nous l’avons vu dans l’activité, les attributs action et method de l’élément &lt;form&gt; définissent le fonctionnement du formulaire :\n\naction a pour valeur l’URL du fichier auquel sera envoyé le formulaire. Ce fichier est un programme écrit dans un langage de script comme PHP ou Python, qui va prendre en entrée les paramètres du formulaire transmis par le client, les traiter et générer la page Web en HTML qui lui sera renvoyée.\nmethod peut prendre deux valeurs GET ou POST (en minuscule ou majuscule), ce sont les deux modes de transmission des paramètres du formulaire qui sont deux méthodes distinctes du protocole HTTP :\n\navec la méthode GET , les données du formulaire sont assemblées dans une chaîne de paires nom/valeur séparées par le symbole & qui est ajoutée à la fin de l’URL après le délimiteur ?.\navec la méthode POST les données du formulaire sont toujours transmises dans le corps de la requête. Les données n’apparaissent donc pas dans l’URL.\n\n\n\n\n\n\n\n\n\nDifférences entre les méthodes GET et POST\n\n\n\nCaractéristiques de la méthode GET :\n\nToutes les informations transmises, le sont en clair dans l’URL. Celle-ci est limitée en taille donc la méthode GET ne peut pas être utilisée pour transmettre des informations trop longues.\nUne requête GET est constituée uniquement d’un entête, elle n’a pas de corps.\nElle ne modifie pas l’état du serveur, elle est utilisée uniquement pour demander une ressource. Un exemple classique d’utilisation est la formulation d’une requête à l’aide du formulaire d’un moteur de recherche. L’URL générée peut être utilisée plusieurs fois et conservée comme marque-page.\n\nCaractéristiques de la méthode POST :\n\nLes données sont transmises dans le corps de la requête, il n’y a pas de restriction de taille. Elles peuvent être de tout type : textes, binaires…\nLes données n’apparaissent pas dans l’URL, néanmoins, si le protocole HTTP est employé sans chiffrement, il suffit d’intercepter la requête pour accéder aux données en clair.\nLes données envoyées peuvent modifier l’état du serveur. Par exemple, les requêtes POST sont utilisées pour les modifications de bases de données sur le serveur (achats, réservation, transfert de fichiers …). Par conséquent, si on veut renvoyer les données d’un formulaire, un message en popup avertit que ce nouvel envoi peut modifier l’état du serveur.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours : formulaires"
    ]
  },
  {
    "objectID": "21_client-serveur/cours_forms.html#pour-aller-plus-loin",
    "href": "21_client-serveur/cours_forms.html#pour-aller-plus-loin",
    "title": "Cours : formulaires",
    "section": "3. Pour aller plus loin",
    "text": "3. Pour aller plus loin\n\nW3Schools : référence de tous les éléments HTML de formulaire avec des exemples interactifs.\nLe site MDN web docs de Mozilla est une fois de plus une très bonne référence.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours : formulaires"
    ]
  },
  {
    "objectID": "21_client-serveur/client-serveur_cours.html",
    "href": "21_client-serveur/client-serveur_cours.html",
    "title": "Cours",
    "section": "",
    "text": "logo HTTP\nHTTP signifie HyperText Transfer Protocol : avec le langage HTML et les adresses web (URL), ce protocole est l’une des trois fondations du World Wide Web.\nHTTP est un protocole servant à transmettre des documents hypermédias, comme HTML. Il a été conçu pour la communication entre les navigateurs web et les serveurs web, mais peut également être utilisé à d’autres fins. Il suit le modèle classique client-serveur : un client ouvre une connexion, effectue une requête et attend jusqu’à recevoir une réponse. Il s’agit aussi d’un protocole sans état, ce qui signifie que le serveur ne conserve aucune donnée (on parle d’état) entre deux requêtes.\nUn protocole est tout simplement un ensemble de règles. Dans un contexte réseau, un protocole est un ensemble de règles qui régissent les échanges de données.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "21_client-serveur/client-serveur_cours.html#architecture-client-serveur-et-http",
    "href": "21_client-serveur/client-serveur_cours.html#architecture-client-serveur-et-http",
    "title": "Cours",
    "section": "1. Architecture client-serveur et HTTP",
    "text": "1. Architecture client-serveur et HTTP\nDe façon schématique, Internet fonctionne selon le modèle d’architecture client-serveur.\n\nle client envoie des requêtes (des demandes) et attend une réponse ; la requête, par exemple, peut consister à demander le chargement d’une page web ;\nle serveur reçoit les requêtes et envoie une réponse ; par exemple, il envoie la page HTML ou encore un message spécifique si la page demandée n’existe pas.\n\nRemarquons que le serveur reçoit simultanément des requêtes de plusieurs clients.\n\n\n\nArchitecture client - serveur\n\n\nLe protocole HTTP est donc l’ensemble des règles qui permettent le dialogue entre le serveur et les clients.\n\n\n\n\n\n\nRemarque\n\n\n\nEn réalité le client et le serveur sont des logiciels et non des ordinateurs. On appelle cependant couramment serveur la machine sur laquelle tourne le programme serveur et client la machine sur laquelle tourne le programme client.\nDans le cadre de ce cours le client est le navigateur internet. \n\n\nPar défaut, le protocole HTTP n’est pas sécurisé, les données (texte de la requête et réponse) circulent donc de façon ouverte dans le réseau. Il peut cependant être sécurisé en utilisant un protocole de cryptage SSL ou TLS et il s’appelle dans ce cas HTTPS.\n\n\n\n\n\n\nRemarque\n\n\n\nEn réalité, le client est également connecté à plusieurs serveurs. Un document complet est construit à partir de différents sous-documents qui sont récupérés, par exemple du texte, des descriptions de mise en page, des images, des vidéos, des scripts et bien plus. Ces différents éléments proviennent souvent de différents serveurs.\n\nAutre simplification effectuée dans ce cours : en réalité, plusieurs machines se trouvent sur le chemin de l’information entre le client et le serveur. Ces machines sont désignées de façon générique sous le terme proxies. Celles-ci exécutent différentes opérations et agissent comme passerelles ou comme caches.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "21_client-serveur/client-serveur_cours.html#requêtes-et-réponses",
    "href": "21_client-serveur/client-serveur_cours.html#requêtes-et-réponses",
    "title": "Cours",
    "section": "2. Requêtes et réponses",
    "text": "2. Requêtes et réponses\nCôté client, le navigateur envoie une requête initiale pour récupérer le document HTML depuis la page. Ensuite, il analyse le fichier et récupère les requêtes additionnelles qui correspondent aux scripts, aux informations de mise en page (CSS) et les sous-ressources contenues dans la page (généralement des images et des vidéos). Le navigateur web assemble alors ces ressources pour présenter un document complet à l’utilisateur : c’est la page web. Les scripts exécutés par le navigateur peuvent permettre de récupérer plus de ressources par la suite afin de mettre à jour la page web.\nUne page web est un document hypertexte. Cela signifie que certaines parties sont des liens qui peuvent être activés (généralement avec un clic de souris) afin de récupérer une nouvelle page web, permettant à l’utilisateur de diriger son agent utilisateur et de naviguer sur le Web. Le navigateur traduit ces instructions en requêtes HTTP et interprète les réponses HTTP pour présenter une réponse claire à l’utilisateur.\nCôté serveur, le serveur sert (envoie) le document demandé par le client. Bien qu’on présente virtuellement le serveur comme un seul ordinateur, en réalité, il peut s’agir d’un ensemble de serveurs se répartissant la charge (load balancing) ou d’une architecture logicielle complexe qui interroge d’autres serveurs (par exemple un cache, un serveur de base de données, serveur d’e-commerce…), qui génèrent totalement ou partiellement le document à la demande.\nD’une part, un serveur n’est pas nécessairement une machine unique et d’autre part, plusieurs serveurs peuvent être hébergés sur une même machine.\n\nAnatomie d’une requête\nVoici un exemple de requête :\n\n\n\nRequête HTTP\n\n\nOn trouve les éléments suivants :\n\nla méthode HTTP, ici GET. On utilisera aussi la méthode POST avec les formulaires ;\nle chemin de la ressource : ce chemin est calculé par le navigateur à partir de l’URL ;\nla version du protocole HTTP/1.1 ou HTTP/2.\nles en-têtes optionnels qui transmettent des informations supplémentaires pour les serveurs ;\n\nConsidérons la page web mapageweb.html suivante, hébergée en ligne à cette adresse. :\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt; Ma page web &lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p id=\"p1\"&gt;Bonjour&lt;/p&gt;\n    &lt;p id=\"p2\"&gt;Bonsoir&lt;/p&gt;\n    &lt;p id=\"p3\"&gt;Au revoir !&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\nLorsque cette page est chargée dans le navigateur, les outils de développement (F12, puis onglet Réseau) permettent de visualiser les requêtes envoyées :\n\nNous voyons qu’en fait deux requêtes ont été envoyées, car le navigateur charge automatiquement l’icône du site.\n\n\nAnatomie d’une réponse\nVoici un exemple de réponse :\n\n\n\nréponse HTTP\n\n\nOn trouve les éléments suivants :\n\nla version du protocole ;\nun code de statut, qui indique si la requête a réussi ou non. Les plus courants sont 200 (ok), 404 (not found), 500 (Internal Server Error). La liste complète est disponible ici.\nun message de statut qui est une description rapide, informelle, du code de statut ;\nles en-têtes HTTP, comme pour les requêtes ;\néventuellement un corps contenant la ressource récupérée.\n\nDans l’exemple du chargement de la page mapageweb.html suivante, hébergée en ligne à cette adresse, voici la réponse du serveur :\nHTTP/1.1 200 OK\nAccept-Ranges: bytes\nConnection: keep-alive\nContent-Length: 170\nContent-Type: text/html\nDate: Thu, 03 Nov 2022 10:25:22 GMT\nLast-Modified: Thu, 03 Nov 2022 09:46:27 GMT\nServer: o2switch-PowerBoost-v3\n\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt; Ma page web &lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p id=\"p1\"&gt;Bonjour&lt;/p&gt;\n    &lt;p id=\"p2\"&gt;Bonsoir&lt;/p&gt;\n    &lt;p id=\"p3\"&gt;Au revoir !&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "21_client-serveur/client-serveur_cours.html#pour-aller-plus-loin",
    "href": "21_client-serveur/client-serveur_cours.html#pour-aller-plus-loin",
    "title": "Cours",
    "section": "3. Pour aller plus loin",
    "text": "3. Pour aller plus loin\n\nExcellente ressource pour tout savoir sur HTTP : MDN Web Docs de Mozilla. Cerise sur le gâteau : le site est disponible en français.\nPlus difficile, mais très complet (se limiter à la partie 1) : le cours de Pierre Giraud. Attention, seule la version en ligne est gratuite !",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "20_js/js_cours.html",
    "href": "20_js/js_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Les scripts JavaScript permettent des interactions entre l’utilisateur et une page web à partir d’éléments graphiques inclus dans la page et de l’interception d’événements auxquels sont associés des fonctions.\nJavaScript (souvent abrégé en « JS ») est un langage de script léger principalement connu comme le langage de script des pages web. Mais il est aussi utilisé dans de nombreux environnements extérieurs aux navigateurs web. Le code JavaScript est interprété à la volée par le navigateur internet.\nJavaScript a été créé en 1995 par Brendan Eich et intégré au navigateur web Netscape Navigator 2.0. L’implémentation concurrente de JavaScript par Microsoft dans Internet Explorer jusqu’à sa version 9 se nommait JScript, tandis que celle d’Adobe Systems se nommait ActionScript. JavaScript a été standardisé sous le nom d’ECMAScript en juin 1997 par Ecma International dans le standard ECMA-262. La version en vigueur de ce standard depuis juin 2022 est la 13e édition.\nJavaScript ne doit pas être confondu avec le langage de programmation Java. Java et JavaScript sont deux marques déposées par Oracle dans de nombreux pays, mais ces deux langages de programmation ont chacun une syntaxe, une sémantique et des usages différents.\nNous reparlerons plus en détail dans une autre partie du cours des notions de client, serveur et de la façon dont ils communiquent entre eux.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "20_js/js_cours.html#éléments-de-base-du-langage",
    "href": "20_js/js_cours.html#éléments-de-base-du-langage",
    "title": "Cours",
    "section": "1. Éléments de base du langage",
    "text": "1. Éléments de base du langage\nIl ne s’agit pas ici de donner une description complète du langage JavaScript, mais de fournir quelques repères qui pourront être complétés en consultant les ressources données en bas de cette page.\nJavaScript est, comme Python, un langage à typage dynamique : il n’est pas nécessaire de déclarer le type des variables à leur création.\nLa création d’une variable doit cependant être déclarée à l’aide de l’instruction let ou de l’instruction var. La différence entre ces deux instructions est leur portée : let définit une variable locale, limitée à un bloc ; var définit une variable globale.\nlet ma_variable = \"toto\"\nLes blocs d’instruction sont délimités par des accolades alors qu’en Python ils le sont par l’indentation. Cette dernière n’a donc pas de sens en JavaScript, mais elle peut être quand même utilisée pour rendre le texte plus lisible. La fin d’une ligne d’instructions est matérialisée par un point virgule ;.\nLes commentaires sont précédés de //.\nOpérateurs de base\n\n\n\nOpérateurs\nDescription\n\n\n\n\n=\naffectation\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n**\npuissance\n\n\n== ou ===\négalité\n\n\n!= ou !===\ndifférence\n\n\n&&\net logique\n\n\n||\nou logique\n\n\n!\nnégation logique\n\n\n\nFonctions\nLes fonctions sont définies par l’instruction function.\nfunction f(x) {\n    return 2 * x ** 2 + 5;\n}\nStructures conditionnelles\nfunction juge(x) {\n    if (x &gt; 10){\n        console.log(\"Tu as la moyenne.\");\n    }\n    else {\n        console.log(\"Tu n'as pas la moyenne.\");\n    }\n}\n\n\n\n\n\n\nRemarque\n\n\n\nLa fonction console.log() permet d’afficher des éléments dans la console JavaScript visible dans les outils de développement du navigateur.\n\n\nBoucles\nlet str = '';\n\nfor (let i = 0; i &lt; 9; i++) {\n  str = str + i;\n}\n\nconsole.log(str);\n// sortie attendue : \"012345678\"\nlet n = 0;\n\nwhile (n &lt; 3) {\n  n++;\n}\n\nconsole.log(n);\n// sortie attendue : 3",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "20_js/js_cours.html#interaction-avec-la-page-web",
    "href": "20_js/js_cours.html#interaction-avec-la-page-web",
    "title": "Cours",
    "section": "2. Interaction avec la page web",
    "text": "2. Interaction avec la page web\nDu point de vue de JavaScript, la page web est un arbre HTML (voir le cours précédent).\nLa page web dans son ensemble est représentée par l’objet document.\nPour accéder aux éléments HTML, il existe plusieurs solutions : par leur classe CSS, par leur nom, mais le plus simple est l’accès par leur identifiant, en utilisant getElementById.\nUne fois un élément HTML sélectionné, son contenu est représenté par innerHTMLet il peut être modifié.\nOn peut aussi accéder aux et modifier les différentes règles CSS en utilisant une syntaxe du type `element.style.regle = …’.\nToutes ces instructions sont illustrées par l’exemple ci-dessous. La page web étant chargée dans le navigateur, on peut entrer les instructions JavaScript ligne par ligne dans la console.\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt; Ma page web &lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p id=\"p1\"&gt;Bonjour&lt;/p&gt;\n    &lt;p id=\"p2\"&gt;Bonsoir&lt;/p&gt;\n    &lt;p id=\"p3\"&gt;Au revoir !&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n// sélection de premier paragraphe et remplacement de son contenu\nlet para = document.getElementById(\"p1\");\npara.innerHTML = \"Hello !\";\n\n// sélection du second paragraphe et application de style\nlet paragra = document.getElementById(\"p3\");\nparagra.style.color = \"red\";\nparagra.style.textAlign = \"center\";",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "20_js/js_cours.html#programmation-événementielle",
    "href": "20_js/js_cours.html#programmation-événementielle",
    "title": "Cours",
    "section": "3. Programmation événementielle",
    "text": "3. Programmation événementielle\n\n\n\n\n\n\nProgrammation événementielle\n\n\n\nJavaScript utilise la programmation événementielle dans laquelle l’exécution d’actions est déclenchée automatiquement lorsqu’un événement survient. Un événement correspond en général à un changement d’état dans le contexte du programme, ou bien à une intervention explicite de l’utilisateur (ou d’un système externe). La programmation événementielle est souvent utilisée dans les cas suivants :\n\nLa programmation d’automates (systèmes de régulation par exemple). Par exemple : température &lt; 20 → déclencher chauffage ;\nLa programmation d’interface graphique. En effet, chaque action de l’utilisateur (clic souris, etc.) peut être vue comme un événement.\n\nLe programme sera principalement défini par ses réactions aux différents événements qui peuvent se produire, c’est-à-dire des changements d’état de variable (par exemple l’incrémentation d’une liste), un déplacement ou un clic de souris, une saisie au clavier…\n\n\nDe nombreux types d’événements peuvent être détectés, par exemple :\n\nonload : la page web est chargée ;\nonkeypress : une touche est pressée ;\nonclick : clic gauche sur un élément ;\nonmouseover : le pointeur de la souris passe sur un élément.\n\nUne liste complète est disponible sur le site W3Schools.\nPour associer une fonction à un événement, on ajoute un attribut portant le nom de cet événement à l’élément HTML considéré.\nPar exemple, dans le code ci-dessous, la fonction maFonction() sera exécutée dès que la page aura été chargée dans le navigateur.\n &lt;body onload=\"maFonction()\"&gt; \nLe code JavaScript de maFonction étant quant à lui situé dans un fichier de script séparé déclaré dans la section &lt;head&gt;de la page HTML.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "20_js/js_cours.html#ressources-pour-aller-plus-loin",
    "href": "20_js/js_cours.html#ressources-pour-aller-plus-loin",
    "title": "Cours",
    "section": "4. Ressources pour aller plus loin",
    "text": "4. Ressources pour aller plus loin\nDe très nombreuses ressources existent pour apprendre JavaScript.\n\nExcellente ressource pour apprendre le HTML, le CSS et JavaScript : MDN Web Docs de Mozilla. Cerise sur le gâteau : le site est disponible en français.\nIncontournable, mais en anglais, les tutoriels de w3Schools.\nPlus difficile, mais très complet : le cours de Pierre Giraud. Attention, seule la version en ligne est gratuite !",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "20_js/acti3_Javascript.html#partie-1---observation-dune-page-web-interactive",
    "href": "20_js/acti3_Javascript.html#partie-1---observation-dune-page-web-interactive",
    "title": "Activité : Page Web interactive avec Javascript",
    "section": "Partie 1 - Observation d’une page web interactive",
    "text": "Partie 1 - Observation d’une page web interactive\n\nOuvrir la page web qui va nous servir d’exemple, en cliquant sur ce lien.\nTester et observer les différentes interactivités présentes sur la page. Quels éléments HTML permettent d’interagir avec la page ?\nOuvrir le code source de la page et repérer parmi les éléments HTML présents ceux qui possèdent un attribut de la forme “on…()”. Ces attributs définissent la fonction JavaScript qui doit être exécutée lorsque l’événement indiqué survient. Noter le nom de chacune de ces fonctions ainsi que l’élément auquel elles sont associées.\nMais où se trouve le code de ces fonctions ? Observer le contenu de l’élément &lt;head&gt;: une ligne faisant référence à un fichier de script JavaScript a été ajoutée :\n&lt;script src=\"acti3.js\"&gt;&lt;/script&gt;\nOuvrir ce fichier. Il contient la définition des fonctions déclenchées par les événements.\nRépondre aux questions suivantes :\n\nComment fait-on des commentaires en JavaScript ?\nQuel mot-clef est utilisé pour définir une variable ?\nQuelle instruction correspond à l’instruction Python def?\nQuelle instruction correspond à l’instruction Python str()?\n\nOn trouve dans le code deux lignes console.log(...). Cette instruction permet d’écrire dans la console JavaScript. Celle-ci apparaît dans les outils de développement accessibles en pressant la touche F12 (onglet Console). Ouvrir cette console, cliquer plusieurs fois sur les boutons qui font changer les couleurs d’arrière-plan et observer ce qui apparaît dans la console.\n\n\n\n\n\n\n\nLe trio HTML/CSS/JS\n\n\n\nUne page web interactive utilisant JavaScript sera donc rendue dans le navigateur à partir du code contenu dans trois fichiers distincts :\n\nle fichier HTML pour la structure du document et son contenu ;\nle fichier CSS pour le style ;\nle fichier JavaScript pour la définition des algorithmes et la gestion des événements.\n\nLe code JavaScript peut modifier le contenu des éléments HTML et les règles CSS. \n\n\n\n\n\n\n\n\nAttention !\n\n\n\nLe code JavaScript est exécuté sur l’ordinateur client, par le navigateur. Toute modification faite sur le client (avec les outils de développement par exemple) sera perdue si la page est rechargée. Le serveur va en effet alors renvoyer la page initiale.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Page Web interactive avec Javascript"
    ]
  },
  {
    "objectID": "20_js/acti3_Javascript.html#partie-2---création-dune-page-web-interactive",
    "href": "20_js/acti3_Javascript.html#partie-2---création-dune-page-web-interactive",
    "title": "Activité : Page Web interactive avec Javascript",
    "section": "Partie 2 - Création d’une page web interactive",
    "text": "Partie 2 - Création d’une page web interactive\nDans cette partie, vous devez créer une page web, au format HTML, contenant du texte et une image, associée à une feuille de style de votre choix.\nVous devez ensuite créer un fichier script.js et le lier à votre page HTML.\nL’objectif est d’insérer dans votre page HTML un bouton “Mode jour/Mode nuit” qui changera les couleurs de la page à chaque clic : passage d’un thème clair à un thème sombre et vice versa.\nCe travail est à faire dans Capytale en cliquant ici.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Page Web interactive avec Javascript"
    ]
  },
  {
    "objectID": "19_css/css_cours.html",
    "href": "19_css/css_cours.html",
    "title": "Cours",
    "section": "",
    "text": "logo CSS\nLe principe du couple HTML/CSS est de bien séparer la définition du contenu d’une page Web de la définition de son apparence.\nCe langage est apparu au milieu des années 1990 et les règles CSS sont couramment utilisées et reconnues par les navigateurs depuis le début des années 2000.\nL’un des objectifs majeurs des CSS est de permettre la mise en forme en dehors du code HTML. Il est par exemple possible de ne décrire que la structure d’un document en HTML, et de décrire toute la présentation dans une feuille de style CSS séparée. Les styles sont appliqués au dernier moment, dans le navigateur web des visiteurs qui consultent le document. Cette séparation fournit un certain nombre de bénéfices, permettant d’améliorer l’accessibilité, de changer plus facilement de présentation, et de réduire la complexité de l’architecture d’un document.\nAinsi, les avantages des feuilles de style sont multiples :",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "19_css/css_cours.html#structure-dune-règle-css",
    "href": "19_css/css_cours.html#structure-dune-règle-css",
    "title": "Cours",
    "section": "1. Structure d’une règle CSS",
    "text": "1. Structure d’une règle CSS\nCSS est un langage basé sur des règles — on définit des règles de styles destinées à des éléments ou des groupes d’éléments particuliers dans la page. Par exemple, « Je veux que le titre principal de ma page s’affiche en rouge en gros caractères. »\nDans le code suivant, une règle CSS élémentaire réalise cette mise en forme :\nh1 {\n  color: red;\n  font-size: 5em;\n}\n\nLa règle commence par un sélecteur, l’élément HTML mis en forme. Ici, le style s’applique aux titres de niveau 1 (&lt;h1&gt;).\nSuivent une paire d’accolades { } à l’intérieur desquelles on trouve une ou plusieurs déclarations, sous la forme d’une paire propriété: valeur. Chaque paire précise une propriété de l’élément sélectionné, suivie de la valeur choisie pour cette propriété ; la propriété et la valeur sont séparées par deux points. Chaque déclaration se termine par un point-virgule. À chaque propriété définie par CSS correspondent différentes valeurs possibles. Dans l’exemple, la propriété color peut prendre différentes valeurs. La propriété font-size accepte différentes tailles comme valeurs.\nUne feuille de style CSS est constituée d’une succession de telles règles :\nh1 {\n  color: red;\n  font-size: 5em;\n}\n\np {\n  color: black;\n}\nLe lien entre le fichier HTML et la feuille de style CSS est fait dans le fichier HTML en insérant un élément &lt;link&gt; dans la section &lt;head&gt; de la page :\n&lt;link rel=\"stylesheet\" href=\"styles.css\"&gt;\nUne même feuille de style peut ainsi servir à plusieurs fichiers HTML.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "19_css/css_cours.html#différents-types-de-sélecteurs",
    "href": "19_css/css_cours.html#différents-types-de-sélecteurs",
    "title": "Cours",
    "section": "2. Différents types de sélecteurs",
    "text": "2. Différents types de sélecteurs\nLe sélecteur peut être :\n\nle nom d’une balise : toutes les balises de ce type sont alors affectées par la règle CSS ;\nplusieurs noms de balise séparés par une virgule pour sélectionner toutes les balises de tous ces types ;\nun identifiant précédé du symbole # pour sélectionner l’unique élément HTML possédant cet identifiant ;\n#mon-id {\nbackground-color: black;\n}\nune classe précédée d’un point .pour sélectionner tous les éléments HTML possédant cette classe ;\n.ma_classe {\nbackground-color: black;\n}\n\nBeaucoup d’autres possibilités existent, se reporter aux ressources indiquées en bas de page pour approfondir.\nCitons juste un exemple de pseudo-classe : la règle ci-dessous ne s’appliquera par exemple aux liens (balise &lt;a&gt;) que lorsque la souris les survolera :\na:hover {\n    color: blue;\n}",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "19_css/css_cours.html#les-grands-types-de-mise-en-forme",
    "href": "19_css/css_cours.html#les-grands-types-de-mise-en-forme",
    "title": "Cours",
    "section": "3. Les grands types de mise en forme",
    "text": "3. Les grands types de mise en forme\nLes règles CSS permettent en particulier :\n\nLa mise en forme basique du texte : couleur, taille, alignement, police de caractères, …\nLa mise en forme globale des paragraphes et des différents blocs de contenu à travers le modèle de boîte.\nL’alignement des images, des divers éléments.\n\nPlus précisément, la notion de modèle de boîte est importante à comprendre.\nEn CSS, tout élément est contenu dans une boîte.\nPour une boîte de type bloc, toute la largeur disponible est utilisée et il est possible de définir des marges :\n\nextérieures avec les propriétés margin, margin-left, margin-top, etc.\nintérieures avec les propriétés padding, padding-left, padding-top, etc.\n\nLes boîtes peuvent aussi recevoir une bordure grâce à la propriété border.\nLes éléments HTML &lt;a&gt;, &lt;span&gt;, &lt;em&gt; et &lt;strong&gt; sont des éléments qui s’affichent “en ligne” par défaut. Pour leur attribuer des propriétés d’éléments de type bloc, on peut utiliser la propriété display: block;.\nLa figure ci-dessous illustre la différence entre les propriétés margin et padding.\n\n\n\nmodèle de boîtes",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "19_css/css_cours.html#utilisation-des-outils-de-développement-du-navigateur",
    "href": "19_css/css_cours.html#utilisation-des-outils-de-développement-du-navigateur",
    "title": "Cours",
    "section": "4. Utilisation des outils de développement du navigateur",
    "text": "4. Utilisation des outils de développement du navigateur\nLes navigateurs modernes possèdent une fonctionnalité bien utile : les outils de développement, usuellement activés en appuyant sur la touche F12.\n\n\n\noutils de développement\n\n\nOn peut, à partir de cet outil, modifier les règles CSS du document afficher et voir de manière interactive les effets produits. Cet outil sera également utile pour l’utilisation de scripts Javascript dans la page Web.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "19_css/css_cours.html#ressources-pour-approfondir",
    "href": "19_css/css_cours.html#ressources-pour-approfondir",
    "title": "Cours",
    "section": "5. Ressources pour approfondir",
    "text": "5. Ressources pour approfondir\nPour aller plus loin avec le langage CSS :\n\nExcellente ressource pour apprendre le HTML, le CSS et JavaScript : MDN Web Docs de Mozilla. Cerise sur le gâteau : le site est disponible en français.\nIncontournable, mais en anglais, les tutoriels de w3Schools.\nLe cours classique, gratuit et en français du site OpenClassroom.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "18_html/ref_HTML.html",
    "href": "18_html/ref_HTML.html",
    "title": "Référence des principales balises HTML",
    "section": "",
    "text": "Cette page répertorie les éléments HTML principaux, qui sont créés à l’aide de balises. Ils sont regroupés par fonction pour vous aider à trouver facilement ce que vous avez en tête.\nPour une liste complète, reportez-vous au site de Mozilla (excellente ressource en français). Les informations de cette page sont extraites de ce site.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Référence des principales balises HTML"
    ]
  },
  {
    "objectID": "18_html/ref_HTML.html#racine-principale",
    "href": "18_html/ref_HTML.html#racine-principale",
    "title": "Référence des principales balises HTML",
    "section": "Racine principale",
    "text": "Racine principale\n\n\n\n\n\n\nPrincipales balises HTML\n\n\n\n\n\n\n\n\n\n\nBalise\nDescription\n\n\n\n\n&lt;html&gt;\nL’élément HTML &lt;html&gt; représente la racine d’un document HTML. Tout autre élément du document doit être un descendant de cet élément.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Référence des principales balises HTML"
    ]
  },
  {
    "objectID": "18_html/ref_HTML.html#métadonnées",
    "href": "18_html/ref_HTML.html#métadonnées",
    "title": "Référence des principales balises HTML",
    "section": "Métadonnées",
    "text": "Métadonnées\nLes métadonnées contiennent des informations à propos de la page. Elles comprennent des informations sur les styles, les scripts et les données qui aident les programmes (moteur de recherche, navigateurs, etc.) à utiliser et à rendre la page. Les métadonnées relatives aux styles et aux scripts peuvent être définies dans la page ou renvoyer à un autre fichier contenant ces informations.\n\n\n\n\n\n\nPrincipales balises HTML\n\n\n\n\n\n\n\n\n\n\nBalise\nDescription\n\n\n\n\n&lt;head&gt;\nL’élément HTML &lt;head&gt; fournit des informations générales (métadonnées) sur le document, incluant son titre et des liens ou des définitions vers des scripts et feuilles de style.\n\n\n&lt;link&gt;\nL’élément HTML &lt;link&gt; définit la relation entre le document courant et une ressource externe. Cet élément peut être utilisé pour définir un lien vers une feuille de style, vers les icônes utilisées en barre de titre ou comme icône d’application sur les appareils mobiles.\n\n\n&lt;style&gt;\nL’élément HTML &lt;style&gt; contient des informations de mise en forme pour un document ou une partie d’un document. Par défaut, les instructions de mise en forme écrites dans cet élément sont écrites en CSS.\n\n\n&lt;title&gt;\nL’élément &lt;title&gt; définit le titre du document (qui est affiché dans la barre de titre du navigateur ou dans l’onglet de la page). Cet élément ne peut contenir que du texte, les balises qu’il contiendrait seraient ignorées.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Référence des principales balises HTML"
    ]
  },
  {
    "objectID": "18_html/ref_HTML.html#structure-du-document",
    "href": "18_html/ref_HTML.html#structure-du-document",
    "title": "Référence des principales balises HTML",
    "section": "Structure du document",
    "text": "Structure du document\nOrganiser le contenu d’une page en différentes sections permet d’avoir une structure logique au sein d’un document. Grâce à ces éléments, on peut créer un plan pour la page, ajouter des titres pour identifier les sections et également gérer un en-tête et un bas de page.\nOn remarquera que, en dehors des balises de titres, ces éléments HTML ne modifient pas du tout la mise en forme du texte qu’elles contiennent. Ce sont des balises sémantiques : elles servent à donner du sens au contenu, pour le rédacteur de la page. Elles guident aussi l’indexation de la page par les moteurs de recherche.\n\n\n\n\n\n\nPrincipales balises HTML\n\n\n\n\n\n\n\n\n\n\nBalise\nDescription\n\n\n\n\n&lt;body&gt;\nL’élément HTML &lt;body&gt; représente le contenu principal du document HTML. Il ne peut y avoir qu’un élément &lt;body&gt; par document.\n\n\n&lt;header&gt;\nL’élément HTML &lt;header&gt; représente du contenu introductif, généralement un groupe de contenu introductif ou de contenu aidant à la navigation. Il peut contenir des éléments de titre, mais aussi d’autres éléments tels qu’un logo, un formulaire de recherche, le nom d’auteur, etc.\n\n\n&lt;footer&gt;\nL’élément HTML &lt;footer&gt; représente le pied de page de la section ou de la racine de sectionnement la plus proche. Un élément &lt;footer&gt; contient habituellement des informations sur l’autrice ou l’auteur de la section, les données relatives au droit d’auteur ou les liens vers d’autres documents en relation.\n\n\n&lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt;\nLes éléments &lt;h1&gt; à &lt;h6&gt; représentent six niveaux de titres dans un document, &lt;h1&gt; est le plus important et &lt;h6&gt; est le moins important. Un élément de titre décrit brièvement le sujet de la section qu’il introduit.\n\n\n&lt;main&gt;\nL’élément HTML &lt;main&gt; représente le contenu majoritaire du body du document. Le contenu principal de la zone est constitué de contenu directement en relation, ou qui étend le sujet principal du document.\n\n\n&lt;nav&gt;\nL’élément HTML &lt;nav&gt; représente une section d’une page ayant des liens vers d’autres pages ou des fragments de cette page. Autrement dit, c’est une section destinée à la navigation dans un document.\n\n\n&lt;section&gt;\nL’élément HTML &lt;section&gt; représente une section générique d’un document, par exemple un groupe de contenu thématique. Une section commence généralement avec un titre.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Référence des principales balises HTML"
    ]
  },
  {
    "objectID": "18_html/ref_HTML.html#contenu-textuel",
    "href": "18_html/ref_HTML.html#contenu-textuel",
    "title": "Référence des principales balises HTML",
    "section": "Contenu textuel",
    "text": "Contenu textuel\nLe contenu HTML textuel permet d’organiser des blocs ou des sections de contenu entre la balise ouvrante &lt;body&gt; et la balise fermante &lt;/body&gt;. Ces éléments sont cruciaux pour l’accessibilité et le référencement, car ils permettent d’identifier le sens du contenu.\n\n\n\n\n\n\nPrincipales balises HTML\n\n\n\n\n\n\n\n\n\n\nBalise\nDescription\n\n\n\n\n&lt;blockquote&gt;\nL’élément HTML &lt;blockquote&gt; indique que le texte contenu dans l’élément est une citation longue. Le texte est généralement affiché avec une indentation. Une URL indiquant la source de la citation peut être donnée grâce à l’attribut cite tandis qu’un texte représentant la source peut être donné via l’élément &lt;cite&gt;.\n\n\n&lt;dd&gt;\nL’élément HTML &lt;dd&gt; fournit la description, la définition ou la valeur du terme précédent &lt;dt&gt; dans une liste de description &lt;dl&gt;.\n\n\n&lt;div&gt;\nL’élément HTML &lt;div&gt; est le conteneur générique de contenu. Il n’a aucun effet sur le contenu ou la mise en page tant qu’il n’est pas mis en forme d’une manière quelconque à l’aide de CSS.\n\n\n&lt;dl&gt;\nL’élément HTML &lt;dl&gt; représente une liste de descriptions sous la forme d’une liste de paires associant des termes (fournis par des éléments &lt;dt&gt;) et leurs descriptions ou définitions (fournies par des éléments &lt;dd&gt;). On utilisera par exemple cet élément pour implémenter un glossaire.\n\n\n&lt;dt&gt;\nL’élément HTML &lt;dt&gt; identifie un terme dans une liste de définitions ou de descriptions. Cet élément n’apparaît qu’en tant qu’élément enfant d’un élément &lt;dl&gt; et est généralement suivi d’un élément &lt;dd&gt;. Plusieurs éléments &lt;dt&gt; qui se suivent indiqueront qu’ils partagent la définition/description fournie par le prochain élément &lt;dd&gt;.\n\n\n&lt;li&gt;\nL’élément HTML &lt;li&gt; est utilisé pour représenter un élément dans une liste. Il doit être contenu dans un élément parent : une liste ordonnée &lt;ol&gt;, une liste non ordonnée &lt;ul&gt; ou un menu &lt;menu&gt;. Dans les menus et les listes non ordonnées, les éléments de liste sont habituellement affichés en utilisant des puces. Dans les listes ordonnées, ils sont habituellement affichés avec compteur croissant à gauche, tel qu’un nombre ou une lettre.\n\n\n&lt;menu&gt;\nL’élément HTML &lt;menu&gt; est une alternative sémantique à &lt;ul&gt;, mais est traité par les navigateurs, et en termes d’accessibilité comme un élément &lt;ul&gt;. Il représente une liste d’éléments non-ordonnée (chaque élément de la liste étant représenté par un élément &lt;li&gt;).\n\n\n&lt;ol&gt;\nL’élément HTML &lt;ol&gt; représente une liste ordonnée. Les éléments d’une telle liste sont généralement affichés avec un indicateur ordinal pouvant prendre la forme de nombres, de lettres, de chiffres romains ou de points. La mise en forme de la numérotation n’est pas utilisée dans la description HTML mais dans la feuille de style CSS associée grâce à la propriété list-style-type.\n\n\n&lt;p&gt;\nL’élément HTML &lt;p&gt; représente un paragraphe de texte. Les paragraphes sont généralement représentés comme des blocs et séparés par un espace vertical, leur première ligne est également parfois indentée. Les paragraphes sont des éléments blocs.\n\n\n&lt;pre&gt;\nL’élément HTML &lt;pre&gt; représente du texte préformaté, généralement écrit avec une police à chasse fixe. Le texte est affiché tel quel, les espaces utilisés dans le document HTML seront retranscrits.\n\n\n&lt;ul&gt;\nL’élément HTML &lt;ul&gt; représente une liste d’éléments sans ordre particulier. Il est souvent représenté par une liste à puces.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Référence des principales balises HTML"
    ]
  },
  {
    "objectID": "18_html/ref_HTML.html#sémantique-du-texte-en-ligne",
    "href": "18_html/ref_HTML.html#sémantique-du-texte-en-ligne",
    "title": "Référence des principales balises HTML",
    "section": "Sémantique du texte en ligne",
    "text": "Sémantique du texte en ligne\nLes éléments pour le texte en ligne peuvent être utilisés pour définir la signification, la structure ou la mise en forme d’un terme, d’une ligne ou d’un fragment de texte.\n\n\n\n\n\n\nPrincipales balises HTML\n\n\n\n\n\n\n\n\n\n\nBalise\nDescription\n\n\n\n\n&lt;a&gt;\nL’élément HTML &lt;a&gt; (pour ancre ou anchor en anglais), avec son attribut href, crée un lien hypertexte vers des pages web, des fichiers, des adresses e-mail, des emplacements se trouvant dans la même page, ou tout ce qu’une URL peut adresser. Le contenu de chaque élément &lt;a&gt; doit indiquer la destination du lien. Si l’attribut href est présent, appuyer sur la touche entrée en se concentrant sur l’élément &lt;a&gt; l’activera.\n\n\n&lt;abbr&gt;\nL’élément HTML &lt;abbr&gt; (abréviation en français) représente une abréviation ou un acronyme ; l’attribut facultatif title peut fournir une explication ou une description de l’abréviation. S’il est présent, title doit contenir cette description complète et rien d’autre.\n\n\n&lt;br&gt;\nL’élément HTML &lt;br&gt; crée un saut de ligne (un retour chariot) dans le texte. Il s’avère utile lorsque les sauts de ligne ont une importance (par exemple lorsqu’on écrit une adresse ou un poème).\n\n\n&lt;cite&gt;\nL’élément &lt;cite&gt; contient le titre d’une œuvre telle qu’un livre, une chanson, un film, une sculpture… Cet élément doit inclure le titre de l’œuvre.\n\n\n&lt;code&gt;\nL’élément HTML &lt;code&gt; représente un court fragment de code machine. Par défaut, l’agent utilisateur utilise une police à chasse fixe (monospace) afin d’afficher le texte contenu dans cet élément.\n\n\n&lt;em&gt;\nL’élément HTML &lt;em&gt; (pour emphase) est utilisé afin de marquer un texte sur lequel on veut insister. Les éléments &lt;em&gt; peuvent être imbriqués, chaque degré d’imbrication indiquant un degré d’insistance plus élevé.\n\n\n&lt;i&gt;\nL’élément HTML &lt;i&gt; représente un morceau de texte qui se différencie du texte principal. Cela peut par exemple être le cas pour des termes techniques, des phrases dans une langue étrangère ou encore l’expression des pensées d’un personnage. Le contenu de cet élément est généralement affiché en italique.\n\n\n&lt;kbd&gt;\nL’élément HTML &lt;kbd&gt; représente une plage de texte en ligne indiquant la saisie de texte par l’utilisateur à partir d’un clavier, d’une saisie vocale ou de tout autre dispositif de saisie de texte. Par convention, le user agent rend par défaut le contenu d’un élément &lt;kbd&gt; en utilisant sa police monospace, bien que cela ne soit pas requis par le standard HTML.\n\n\n&lt;mark&gt;\nL’élément HTML &lt;mark&gt; représente un texte marqué ou surligné à cause de sa pertinence dans le contexte. Il peut par exemple être utilisé afin d’indiquer les correspondances d’un mot-clé recherché au sein d’un document.\n\n\n&lt;s&gt;\nL’élément HTML &lt;s&gt; permet d’afficher du texte qui est barré, car il n’est plus pertinent ou, car il est obsolète. &lt;s&gt; ne doit pas être employé pour indiquer des éditions dans un document .\n\n\n&lt;small&gt;\nL’élément HTML &lt;small&gt; permet de représenter des commentaires ou des textes à écrire en petits caractères (des clause d’un contrat, des mentions relatives au droit d’auteur, etc.) quelle que soit la présentation.\n\n\n&lt;span&gt;\nL’élément HTML &lt;span&gt; est un conteneur générique en ligne (inline) pour les contenus phrasés. Il ne représente rien de particulier. Il peut être utilisé pour grouper des éléments afin de les mettre en forme (grâce aux attributs class ou id et aux règles CSS) ou parce qu’ils partagent certaines valeurs d’attribut comme lang. Il doit uniquement être utilisé lorsque aucun autre élément sémantique n’est approprié. &lt;span&gt; est très proche de l’élément &lt;div&gt;, mais l’élément &lt;div&gt; est un élément de bloc, alors que &lt;span&gt; est un élément en ligne.\n\n\n&lt;strong&gt;\nL’élément HTML &lt;strong&gt; indique que le texte a une importance particulière ou un certain sérieux, voire un caractère urgent. Cela se traduit généralement par un affichage en gras.\n\n\n&lt;sub&gt;\nL’élément HTML &lt;sub&gt; est utilisé, pour des raisons typographiques, afin d’afficher du texte en indice (sous la ligne de base et généralement plus petit) par rapport au bloc de texte environnant.\n\n\n&lt;sup&gt;\nL’élément HTML &lt;sup&gt; est utilisé, pour des raisons typographiques, afin d’afficher du texte en exposant (plus haut et généralement plus petit) par rapport au bloc de texte environnant.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Référence des principales balises HTML"
    ]
  },
  {
    "objectID": "18_html/ref_HTML.html#images-et-médias",
    "href": "18_html/ref_HTML.html#images-et-médias",
    "title": "Référence des principales balises HTML",
    "section": "Images et médias",
    "text": "Images et médias\nHTML prend en charge différents fichiers multimédias pour les images, les fichiers audio et vidéo.\n\n\n\n\n\n\nPrincipales balises HTML\n\n\n\n\n\n\n\n\n\n\nBalise\nDescription\n\n\n\n\n&lt;area&gt;\nL’élément HTML &lt;area&gt; définit une zone particulière d’une image et peut lui associer un [lien hypertexte]. Cet élément n’est utilisé qu’au sein d’un élément &lt;map&gt;.\n\n\n&lt;audio&gt;\nL’élément HTML &lt;audio&gt; est utilisé afin d’intégrer un contenu sonore dans un document. Il peut contenir une ou plusieurs sources audio représentées avec l’attribut src ou l’élément &lt;source&gt; : le navigateur choisira celle qui convient le mieux.\n\n\n&lt;img&gt;\nL’élément HTML &lt;img&gt; permet d’intégrer une image dans un document.\n\n\n&lt;map&gt;\nL’élément HTML &lt;map&gt; est utilisé avec des éléments &lt;area&gt; afin de définir une image cliquable divisée en régions.\n\n\n&lt;video&gt;\nL’élément HTML &lt;video&gt; intègre un contenu vidéo dans un document.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Référence des principales balises HTML"
    ]
  },
  {
    "objectID": "18_html/ref_HTML.html#contenu-embarqué",
    "href": "18_html/ref_HTML.html#contenu-embarqué",
    "title": "Référence des principales balises HTML",
    "section": "Contenu embarqué",
    "text": "Contenu embarqué\nEn plus du contenu multimédia, un document HTML peut embarquer d’autres contenus (bien que les interactions soient plutôt limitées).\n\n\n\n\n\n\nPrincipales balises HTML\n\n\n\n\n\n\n\n\n\n\nBalise\nDescription\n\n\n\n\n&lt;embed&gt;\nL’élément HTML &lt;embed&gt; permet d’intégrer du contenu externe à cet endroit dans le document (par exemple un fichier PDF).\n\n\n&lt;iframe&gt;\nL’élément HTML &lt;iframe&gt; représente un contexte de navigation imbriqué qui permet en fait d’obtenir une page HTML intégrée dans la page courante. Souvent utilisé pour intégrer une vidéo provenant d’une plateforme de streaming.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Référence des principales balises HTML"
    ]
  },
  {
    "objectID": "18_html/ref_HTML.html#élément-interactif",
    "href": "18_html/ref_HTML.html#élément-interactif",
    "title": "Référence des principales balises HTML",
    "section": "Élément interactif",
    "text": "Élément interactif\nPour finir voici une dernière balise utile :\n\n\n\n\n\n\nPrincipales balises HTML\n\n\n\n\n\n\n\n\n\n\nBalise\nDescription\n\n\n\n\n&lt;details&gt;\nL ’élément HTML &lt;details&gt; est utilisé comme un outil permettant de révéler une information. Un résumé ou un intitulé peuvent être fournis grâce à un élément &lt;summary&gt;.\n\n\n&lt;summary&gt;\nL ’élément HTML &lt;summary&gt; représente une boîte permettant de révéler le contenu d ’un résumé ou d ’une légende pour le contenu d ’un élément details. En cliquant sur l ’élément &lt;summary&gt;, on passe de l ’état affiché à l ’état masqué (et vice versa) de l ’élément &lt;details&gt; parent.\n\n\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\n\n\nLes balises concernant les tableaux ne sont pas répertoriées ici. Voir le site de Mozilla en cas de besoin.\nLes balises concernant les formulaires et les scripts seront étudiées plus tard au cours de la séquence.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Référence des principales balises HTML"
    ]
  },
  {
    "objectID": "18_html/html_cours.html",
    "href": "18_html/html_cours.html",
    "title": "Cours",
    "section": "",
    "text": "HTML signifie « HyperText Markup Language » que l’on peut traduire par « langage de balises pour l’hypertexte ». Il est utilisé afin de créer et de représenter le contenu d’une page web et sa structure. D’autres technologies sont utilisées avec HTML pour décrire la présentation d’une page (CSS) et/ou ses fonctionnalités interactives (JavaScript).\nL’« hypertexte » désigne les liens qui relient les pages web entre elles, que ce soit au sein d’un même site web ou entre différents sites web. Les liens sont un aspect fondamental du Web. Ce sont eux qui forment cette « toile » (ce mot est traduit par web en anglais).\nLe langage HTML utilise des « balises » pour annoter du texte, des images et d’autres contenus afin de les afficher dans un navigateur web. Les balises possèdent des noms réservés tels que &lt;head&gt;, &lt;title&gt;, &lt;body&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;section&gt;, &lt;p&gt;, &lt;div&gt;, &lt;span&gt;, &lt;img&gt;, &lt;audio&gt;, &lt;ul&gt;, &lt;ol&gt;, &lt;li&gt; et bien d’autres.\nEn HTML, les balises sont insensibles à la casse et peuvent aussi bien être écrites en minuscules, en majuscules, voire avec un mélange des deux. Autrement dit, la balise &lt;title&gt; pourrait très bien être écrite comme &lt;Title&gt;, &lt;TiTle&gt; ou d’une autre façon.\nLe langage HTML a vu le jour en 1991 et fut créé à partir d’un autre langage de description appelé SGML par l’informaticien Tim Berners-Lee et ses équipes.\nPlusieurs évolutions du langage ont ensuite été développées. Depuis 2014, la version HTML5 est la version officiellement recommandée pour la rédaction de pages Web.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "18_html/html_cours.html#notion-de-balise",
    "href": "18_html/html_cours.html#notion-de-balise",
    "title": "Cours",
    "section": "1. Notion de balise",
    "text": "1. Notion de balise\nUne balise HTML possède la structure suivante :\n&lt;p&gt;Mon chat est très grincheux&lt;/p&gt;\n\nLes composants principaux de notre élément sont :\n\nLa balise ouvrante : celle-ci se compose du nom de l’élément (ici « p »), entre deux chevrons. Cela indique le début de l’élément, soit l’endroit à partir duquel celui-ci prend effet. Pour notre exemple, cela indique le début du paragraphe.\nLa balise fermante : ici on a également des chevrons et le nom de l’élément, auxquels on ajoute une barre oblique avant le nom de l’élément. Cela indique la fin de l’élément. Pour notre exemple, cela indique la fin du paragraphe. Oublier la balise fermante est une erreur courante de débutant et peut conduire à de curieux résultats.\nLe contenu : C’est le contenu de l’élément. Ici, c’est simplement du texte.\nL’élément : Il est composé de la balise ouvrante, de la balise fermante et du contenu.\n\nLes éléments peuvent être imbriqués les uns dans les autres :\n&lt;p&gt;Mon chat est &lt;strong&gt;très&lt;/strong&gt; grincheux.&lt;/p&gt;\nToutefois, il faut faire attention à ce que les éléments soient bien imbriqués les uns dans les autres. Dans l’exemple précédent, on ouvre l’élément &lt;p&gt;, puis l’élément &lt;strong&gt;. Nous devrons donc fermer l’élément &lt;strong&gt; d’abord, puis l’élément &lt;p&gt;. Le code suivant est incorrect :\n&lt;p&gt;Mon chat est &lt;strong&gt;très grincheux.&lt;/p&gt;&lt;/strong&gt;\nLes éléments doivent être ouverts et fermés correctement de façon à ce qu’ils soient clairement à l’intérieur ou à l’extérieur les uns des autres. S’ils se chevauchent, le navigateur essaiera de choisir la meilleure option, qui ne sera peut-être pas ce que vous vouliez dire et pourrait conduire à des résultats inattendus. Donc ne le faites pas !\n\n\n\n\n\n\nRemarque\n\n\n\nCertains éléments sont vides : ils ne nécessitent pas de balise fermante.\nLes plus fréquents sont :\n\nL’élément &lt;img /&gt; :\n&lt;img src=\"chat.png\" alt=\"Image de chat\" /&gt;\nCet élément contient deux attributs mais les balises ouvrantes &lt;img&gt; et fermante &lt;/img&gt; sont remplacées par une balise auto-fermante &lt;img /&gt; et il n’y a aucun contenu interne. En effet, l’élément image n’embarque pas de contenu, son but est d’intégrer une image dans la page HTML, à l’endroit où l’élément est placé.\nL’attribut src indique le chemin vers le fichier de l’image et l’attribut alt contient un texte alternatif, texte descriptif de l’image à l’intention des utilisateurs qui ne peuvent pas voir l’image.\nL’élément &lt;br&gt; : pour créer un saut de ligne dans le texte.\nLes éléments &lt;link&gt; et &lt;meta&gt; présents dans l’élément &lt;head&gt; en début de fichier.\n\nPour toutes ces balises auto-fermantes, la barre oblique avant le dernier chevron &gt;est optionnelle.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "18_html/html_cours.html#attributs-dune-balise",
    "href": "18_html/html_cours.html#attributs-dune-balise",
    "title": "Cours",
    "section": "2. Attributs d’une balise",
    "text": "2. Attributs d’une balise\nLes balises HTML peuvent être dotées d’attributs définis à l’intérieur de la balise ouvrante.\nNous avons déjà vu que la balise &lt;img&gt;, par exemple, possédait un attribut src=... désignant le chemin ou l’adresse de l’image à afficher.\nCertains attributs sont spécifiques à des balises particulières, d’autres sont des attributs universels : ils peuvent s’appliquer à toute balise. En particulier, les attributs suivants seront souvent utilisés :\n\nclass=... : une ou plusieurs classes, séparées par des espaces, qui permettent de catégoriser l’élément pour pouvoir le manipuler dans une feuille de style CSS ou un script JavaScript.\nid=... : un identifiant, unique au sein de tout le document, pour un élément. Il doit permettre d’identifier cet élément lorsqu’on crée un lien vers lui et/ou lorsqu’on le manipule avec des scripts ou avec CSS.\n\n\n\n\n\n\n\nAttention !\n\n\n\n\nPlusieurs éléments HTML peuvent appartenir à une même classe : cela permet par exemple de leur appliquer le même style CSS.\nUn identifiant, par contre, est unique : deux éléments HTML ne doivent pas avoir le même identifiant.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "18_html/html_cours.html#structure-générale-du-fichier-html",
    "href": "18_html/html_cours.html#structure-générale-du-fichier-html",
    "title": "Cours",
    "section": "3. Structure générale du fichier HTML",
    "text": "3. Structure générale du fichier HTML\nLa structure globale d’une page HTML est toujours la même (l’indentation est utilisée pour la lisibilité du code, mais elle n’est pas nécessaire):\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Ma page de test&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"chat.png\" alt=\"Mon chat\"&gt;\n    &lt;p&gt;Voici la photo de mon chat &lt;strong&gt;Félix&lt;/strong&gt;.&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\nNous y trouvons :\n\n&lt;!DOCTYPE html&gt; — le doctype. Au début de HTML, dans les années 1991-1992, les doctypes étaient utilisés pour faire référence à des ensembles de règles qu’on pouvait utiliser pour dire qu’un document était du HTML « valide » et détecter les erreurs de balisage. Cependant, ceux-ci ne sont plus utilisés aujourd’hui et sont juste présents pour s’assurer que la page puisse fonctionner y compris sur les anciens navigateurs. C’est tout ce qu’il y a à savoir à propos des doctypes.\n&lt;html&gt;&lt;/html&gt; — l’élément &lt;html&gt;. Cet élément encadre tout le contenu de la page. Cet élément est parfois appelé l’élément racine.\n&lt;head&gt;&lt;/head&gt; — l’élément &lt;head&gt;. Cet élément est utilisé comme un conteneur pour toutes les choses qui font partie de la page HTML, mais qui ne sont pas du contenu affiché. C’est dans cet élément qu’on mettra des mots-clés, une description de la page qui apparaîtra sur les moteurs de recherche, les liens vers les fichiers CSS à utiliser pour la mise en forme, les déclarations des jeux de caractères à utiliser et ainsi de suite.\n&lt;body&gt;&lt;/body&gt; — l’élément &lt;body&gt;. Cet élément est celui qui contient tout le contenu que vous souhaitez afficher pour qu’il soit vu par les visiteurs : cela peut être du texte, des images, des vidéos, des jeux, des pistes audio jouables, et ainsi de suite.\n\nCette structure peut être représentée sous forme d’arbre. Chaque élément \\(B\\) situé dans un élément \\(A\\) est considéré comme le fils de cet élément \\(A\\).\nVoici l’arbre représentant le fichier HTML ci-dessus :\n\n\n\n\n\ngraph TB\n    A[html] --&gt; B[head]\n    A --&gt; C[body]\n    B --&gt; D[meta]\n    B --&gt; E[title]\n    C --&gt; F[img]\n    C --&gt; G[p]\n    G --&gt; H[strong]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "18_html/html_cours.html#ressources-pour-approfondir",
    "href": "18_html/html_cours.html#ressources-pour-approfondir",
    "title": "Cours",
    "section": "3. Ressources pour approfondir",
    "text": "3. Ressources pour approfondir\n\nExcellente ressource pour apprendre le HTML, le CSS et JavaScript : MDN Web Docs de Mozilla. Cerise sur le gâteau : le site est disponible en français.\nIncontournable, mais en anglais, les tutoriels de w3Schools.\nLe cours classique, gratuit et en français du site OpenClassroom.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Cours"
    ]
  },
  {
    "objectID": "17_recherche/recherche_exos.html",
    "href": "17_recherche/recherche_exos.html",
    "title": "Exercices - Recherche dichotomique",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices - Recherche dichotomique"
    ]
  },
  {
    "objectID": "17_recherche/recherche_exos.html#t.p.-bilan-et-compléments",
    "href": "17_recherche/recherche_exos.html#t.p.-bilan-et-compléments",
    "title": "Exercices - Recherche dichotomique",
    "section": " T.P. : Bilan et compléments",
    "text": "T.P. : Bilan et compléments\n\n\n\n\n\n\nImportant\n\n\n\nNotebook Capytale pour ce T.P. : Capytale \nCe T.P. est à faire dans Capytale en suivant le lien ci-dessus.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices - Recherche dichotomique"
    ]
  },
  {
    "objectID": "17_recherche/index.html",
    "href": "17_recherche/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "17_recherche/index.html#points-traités-dans-cette-séquence",
    "href": "17_recherche/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "16_tris/tris_cours.html",
    "href": "16_tris/tris_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Dans cette partie du cours, nous allons étudier deux algorithmes de tris : le tri par insertion et le tri par sélection.\nÉtant donné un tableau de nombres, l’objectif est d’écrire une fonction qui renvoie un tableau contenant les mêmes nombres mais dans l’ordre croissant.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "16_tris/tris_cours.html#tri-par-insertion",
    "href": "16_tris/tris_cours.html#tri-par-insertion",
    "title": "Cours",
    "section": "1. Tri par insertion",
    "text": "1. Tri par insertion\n\nLe principe\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\nEn commençant par le deuxième élément du tableau :\n\nOn compare l’élément courant avec l’élément précédent.\nSi l’élément courant est plus petit, on échange les deux éléments.\nOn continue à comparer et échanger l’élément courant avec les éléments précédents jusqu’à ce que l’élément courant soit plus grand que l’élément précédent.\n\n\n\n\n\n\n\n\nExemple : Soit à trier le tableau \\([5,2,7,3]\\).\n\nOn commence par le deuxième élément du tableau, c’est-à-dire l’élément 2. On compare l’élément 2 avec l’élément 5. L’élément 2 est plus petit que l’élément 5, on échange les deux éléments. Le tableau est donc \\([2,5,7,3]\\).\nOn continue avec l’élément 7. L’élément 7 est plus grand que l’élément 5, on ne fait rien.\nOn continue avec l’élément 3. L’élément 3 est plus petit que l’élément 7, on échange les deux éléments. Le tableau est donc \\([2,5,3,7]\\). On continue à comparer et échanger l’élément 3 avec les éléments précédents jusqu’à ce que l’élément 3 soit plus grand que l’élément 5. Le tableau est donc \\([2,3,5,7]\\). L’algorithme est terminé. Le tableau est trié.\n\n\n\nProgrammation\n\ndef tri_insertion(tableau: list) -&gt; list:\n    \"\"\"Trie en place par insertion le tableau passé en paramètre.\"\"\"\n1    for i in range(1, len(tableau)):\n2        j = i\n3        while j &gt; 0 and tableau[j] &lt; tableau[j-1]:\n4            tableau[j], tableau[j-1] = tableau[j-1], tableau[j]\n5            j -= 1\n    return tableau\n\n\n1\n\nOn commence à l’indice 1 qui correspond au deuxième élément du tableau.\n\n2\n\nOn stocke l’indice courant dans une variable j pour pouvoir le modifier.\n\n3\n\nTant que l’indice courant est supérieur à 0 et que l’élément courant est plus petit que l’élément précédent, on échange les deux éléments.\n\n4\n\nOn échange les deux éléments.\n\n5\n\nL’élément courant est maintenant l’élément précédent, on décrémente donc l’indice courant.\n\n\n\n\nTest de l’algorithme :\n\ntri_insertion([5, 2, 4, 6, 1, 3])\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nPreuve de terminaison\nMontrons que l’algorithme se termine.\nD’une part, il est certain que la boucle for, boucle bornée par nature, se termine. D’autre part, la boucle while se termine aussi. La variable j est un variant de boucle. À chaque itération, sa valeur diminue de 1 : elle finit donc toujours par atteindre 0.\nLa terminaison de l’algorithme est donc prouvée.\n\n\nPreuve de correction\nMontrons que l’algorithme trie bien le tableau.\nPour cela, considérons la propriété suivante : à chaque itération, le sous-tableau composé des i premiers éléments est trié. Montrons que cette propriété est un invariant de boucle.\n\nInitialisation : au début de l’algorithme, le sous-tableau composé uniquement du premier élément est trié.\nConservation : supposons que le le sous-tableau composé des i premiers éléments est trié : \\([e_0, e_1, \\ldots, e_{i-1}]\\) avec \\(e_0\\leqslant e_1\\leqslant \\ldots \\leqslant e_{i-1}\\). L’algorithme considère alors l’élément \\(e_i\\) et le compare avec les éléments précédents. Si \\(e_i\\) est plus petit que \\(e_{i-1}\\), on échange les deux éléments. On continue alors à comparer \\(e_i\\) avec les éléments précédents jusqu’à ce que \\(e_i\\) soit plus grand que l’élément précédent. Le sous-tableau composé des i+1 premiers éléments est alors trié.\nConclusion : à la fin de l’algorithme i a la valeur n-1 ce qui correspond à l’indice du dernier élément du tableau. Le sous-tableau composé des n premiers éléments est donc trié. Or, n est le nombre d’éléments du tableau, donc le tableau entier est trié.\n\nLa correction de l’algorithme est donc prouvée.\n\n\nComplexité\nOn recherche la complexité dans le pire des cas. Le pire des cas est le cas où le tableau de départ est rangé dans l’ordre décroissant.\nNotons \\(n\\) la taille du tableau de départ.\nLa boucle for comporte \\(n-1\\) itérations.\nDans le cas où le tableau de départ est rangé dans l’ordre décroissant, la boucle while comporte 1 opération, puis 2, puis 3, etc. jusqu’à \\(n-1\\) opérations pour la dernière itération. On obtient donc la somme suivante pour le nombre total d’opérations :\n\\[1+2+3+\\ldots+(n-1)=\\frac{n(n-1)}{2}\\]\nSachant que \\(\\frac{n(n-1)}{2} = \\frac{n^2-n}{2}\\), il s’agit donc d’une complexité quadratique, en \\(\\mathcal{O}(n^2)\\).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "16_tris/tris_cours.html#tri-par-sélection",
    "href": "16_tris/tris_cours.html#tri-par-sélection",
    "title": "Cours",
    "section": "2. Tri par sélection",
    "text": "2. Tri par sélection\n\n\n\n\n\n\nLe principe\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\nEn commençant par le premier élément du tableau :\n\nOn recherche le plus petit élément parmi les éléments suivants du tableau.\nOn échange l’élément courant avec le plus petit élément.\n\n\n\nExemple : Soit à trier le tableau \\([5,2,3,7]\\).\n\nOn commence par le premier élément, 5. On recherche le plus petit élément parmi les éléments suivants du tableau, c’est-à-dire 2. On échange 5 et 2 : le tableau est maintenant \\([2,5,3,7]\\).\nL’élément courant est maintenant le deuxième du tableau, c’est donc encore 5. On recherche le plus petit élément parmi les éléments suivants du tableau, c’est-à-dire 3. On échange 5 et 3 : le tableau est maintenant \\([2,3,5,7]\\).\nL’élément courant est maintenant le troisième du tableau, c’est donc encore 5. On recherche le plus petit élément parmi les éléments suivants du tableau, mais aucun n’est plus petit que 5. On ne fait donc rien.\nL’élément courant est maintenant le dernier du tableau, c’est donc 7. On ne fait donc rien et le tableau est trié.\n\n\n\nProgrammation\n\ndef tri_selection(tableau: list) -&gt; list:\n    \"\"\"Trie en place par sélection le tableau passé en paramètre.\"\"\"\n1    for i in range(len(tableau)):\n2        min = i\n3        for j in range(i+1, len(tableau)):\n4            if tableau[j] &lt; tableau[min]:\n                min = j\n5        tableau[i], tableau[min] = tableau[min], tableau[i]\n    return tableau\n\n\n1\n\nOn commence à l’indice 0 qui correspond au premier élément du tableau.\n\n2\n\nOn stocke l’indice courant dans une variable min pour pouvoir le modifier.\n\n3\n\nOn parcourt le tableau à partir de l’indice i+1 jusqu’à la fin.\n\n4\n\nSi l’élément courant est plus petit que l’élément stocké dans min, on met à jour min.\n\n5\n\nOn échange les deux éléments.\n\n\n\n\nTest de l’algorithme :\n\ntri_selection([5, 2, 4, 6, 1, 3])\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nPreuve de terminaison\nL’algorithme se termine puisqu’il comporte deux boucles for qui sont toutes deux bornées par nature.\n\n\nPreuve de correction\nMontrons que l’algorithme trie bien le tableau.\nPour cela, considérons la propriété suivante : à chaque itération, le sous-tableau composé des i premiers éléments est trié. Montrons que cette propriété est un invariant de boucle.\n\nInitialisation : au début de l’algorithme, le sous-tableau composé uniquement du premier élément est trié.\nConservation : supposons que le le sous-tableau composé des i premiers éléments est trié : \\([e_0, e_1, \\ldots, e_{i-1}]\\) avec \\(e_0\\leqslant e_1\\leqslant \\ldots \\leqslant e_{i-1}\\). Par construction, tous les éléments suivants sont supérieurs à \\(e_{i-1}\\). L’algorithme considère alors l’élément \\(e_i\\) et le compare avec les éléments suivants. Si un élément est plus petit que \\(e_i\\), on échange les deux éléments. Le sous-tableau composé des i+1 premiers éléments est alors trié.\nConslusion : à la fin de l’algorithme i a la valeur n-1 ce qui correspond à l’indice du dernier élément du tableau. Le sous-tableau composé des n premiers éléments est donc trié. Or, n est le nombre d’éléments du tableau, donc le tableau entier est trié.\n\nLa correction de l’algorithme est donc prouvée.\n\n\nComplexité\nOn recherche la complexité dans le pire des cas. Le pire des cas est le cas où le tableau de départ est rangé dans l’ordre décroissant.\nNotons \\(n\\) la taille du tableau de départ.\nLa boucle for i comporte \\(n-1\\) itérations. La boucle for j comporte \\(n-1\\) itérations pour la première itération, puis \\(n-2\\) itérations pour la seconde itération, etc. jusqu’à 1 opération pour la dernière itération. On obtient donc la somme suivante pour le nombre total d’opérations :\n\\[n-1+(n-2)+(n-3)+\\ldots+1=\\frac{n(n-1)}{2}\\]\nSachant que \\(\\frac{n(n-1)}{2} = \\frac{n^2-n}{2}\\), il s’agit donc d’une complexité quadratique, en \\(\\mathcal{O}(n^2)\\).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "16_tris/tris_cours.html#observation-expérimentale-de-la-complexité",
    "href": "16_tris/tris_cours.html#observation-expérimentale-de-la-complexité",
    "title": "Cours",
    "section": "3. Observation expérimentale de la complexité",
    "text": "3. Observation expérimentale de la complexité\n\nTri par insertion\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps = []\n# on applique le tri dans le pire des cas : tableau trié dans l'ordre décroissant\nfor n in tailles:\n    temps.append(timeit.timeit(\n        \"tri_insertion([n-k for k in range(n)])\",\n        globals=globals(),\n        number=1\n    ))\nplt.plot(tailles, temps)\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nTri par sélection\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps = []\n# on applique le tri dans le pire des cas : tableau trié dans l'ordre décroissant\nfor n in tailles:\n    temps.append(timeit.timeit(\n        \"tri_selection([n-k for k in range(n)])\",\n        globals=globals(),\n        number=1\n    ))\nplt.plot(tailles, temps)\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.show()\n\n\n\n\n\n\n\n\nDans les deux cas, la forme grossièrement parabolique de la courbe est caractéristique de la complexité quadratique.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "16_tris/tris_cours.html#compléments",
    "href": "16_tris/tris_cours.html#compléments",
    "title": "Cours",
    "section": "Compléments",
    "text": "Compléments\nSur le site interstices.info un article très complet sur les algorithmes de tri, avec des animations pour mieux comprendre.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "14_algo/index.html",
    "href": "14_algo/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "14_algo/index.html#points-traités-dans-cette-séquence",
    "href": "14_algo/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "14_algo/algo_cours.html",
    "href": "14_algo/algo_cours.html",
    "title": "Cours",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "14_algo/algo_cours.html#introduction",
    "href": "14_algo/algo_cours.html#introduction",
    "title": "Cours",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "14_algo/algo_cours.html#terminaison-dun-algorithme",
    "href": "14_algo/algo_cours.html#terminaison-dun-algorithme",
    "title": "Cours",
    "section": "2. Terminaison d’un algorithme",
    "text": "2. Terminaison d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la terminaison d’un algorithme, c’est prouver que l’algorithme se termine dans tous les cas. C’est notamment très important lorsque l’algorithme comporte des boucles conditionnelles.\n\n\nPrenons comme exemple l’algorithme suivant qui calcule la puissance entière d’un nombre :\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nComment justifier que cet algorithme se termine dans tous les cas ? Cela revient à montrer que la boucle conditionnelle while compteur &lt; n se termine après un nombre fini d’itérations. Pour cela, on utilise un variant de boucle : c’est une valeur qui évolue à chaque itération de la boucle et qui permet de prouver que celle-ci se termine.\nDans notre exemple, on peut choisir comme variant de boucle la valeur de la variable \\(compteur\\). En effet, cette variable est initialisée à 0 et est incrémentée de 1 à chaque itération. Après \\(n\\) itérations, la condition de sortie de boucle sera donc vraie et la boucle se terminera.\nLa terminaison de l’algorithme est donc démontrée.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "14_algo/algo_cours.html#correction-dun-algorithme",
    "href": "14_algo/algo_cours.html#correction-dun-algorithme",
    "title": "Cours",
    "section": "3. Correction d’un algorithme",
    "text": "3. Correction d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la correction d’un algorithme, c’est prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\n\n\nConsidérons à nouveau l’algorithme de calcul de puissance entière. Comment prouver que cet algorithme calcule bien la puissance entière d’un nombre ?\nOn utilise pour cela un invariant de boucle : c’est une propriété qui est vraie avant et après chaque itération de la boucle, et qui doit permettre de prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\nDans notre exemple de calcul de puissance entière, on peut choisir comme invariant de boucle la propriété suivante : \\[p=x^{compteur}\\]\n\n\n\n\n\n\nPour prouver q’une propriété est un invariant de boucle…\n\n\n\nIl faut démontrer :\n\nInitialisation : la propriété est vraie avant le premier passage dans la boucle\nConservation : si la propriété est vraie avant une itération, alors elle sera aussi vraie après cette itération.\nConclusion : une fois la boucle terminée, la propriété est vraie.\n\n\n\nCette méthode de raisonnement est appelée raisonnement par récurrence et est très utilisée en mathématiques (au programme en spécialité mathématiques de terminale).\nDans notre exemple, on a :\n\nInitialisation : La propriété est vraie avec les valeurs initiales des variables car \\(x^0=1\\) et \\(p=1\\).\nConservation : Si nous avons \\(p=x^{compteur}\\) avant une itération, alors nous avons \\(x^{compteur+1}=x^{compteur}\\times x = p\\times x\\). le passage dans la boucle augmente \\(compteur\\) de 1 et remplace \\(p\\) par \\(p\\times x\\). Après l’itération, la propriété \\(p=x^{compteur}\\) est donc encore vraie.\nConclusion : En sortie de boucle, on a donc \\(p=x^{compteur}\\). Or on a aussi l’égalité \\(compteur = n\\) qui a provoqué la sortie de boucle. Finalement, nous avons donc \\(p=x^n\\), ce qui prouve que l’algorithme effectue bien l’opération attendue.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "14_algo/algo_cours.html#complexité",
    "href": "14_algo/algo_cours.html#complexité",
    "title": "Cours",
    "section": "4. Complexité",
    "text": "4. Complexité\nLa durée d’exécution d’un programme traduisant un algorithme donné va dépendre des performances de la machine sur laquelle le programme est exécuté, mais aussi du nombre d’instructions élémentaires mobilisées lors de son exécution. Une partie de ce temps d’exécution provient donc de la façon dont l’algorithme est écrit et non de la façon dont il est programmé.\nOn parle de complexité temporelle d’un algorithme (et non d’un programme) pour mesurer l’efficacité intrinsèque de l’algorithme. Dans la pratique, il s’agit de compter le nombre d’opérations élémentaires (affectations, comparaisons, calculs arithmétiques, …) effectuées par l’algorithme.\nLa complexité en temps d’un algorithme dépend :\n\nde la taille des données passées en paramètres : plus ces données seront volumineuses, plus il faudra d’opérations élémentaires pour les traiter. On notera \\(n\\) le nombre de données à traiter.\nde la donnée en elle-même, de la façon dont sont réparties les différentes valeurs qui la constituent. Par exemple, si on effectue une recherche séquentielle d’un élément dans une liste non triée, on parcourt un par un les éléments jusqu’à trouver, ou pas, celui recherché. Ce parcours peut s’arrêter dès le début si le premier élément est “le bon”. Mais on peut également être amené à parcourir la liste en entier si l’élément cherché est en dernière position, ou même n’y figure pas.\n\nCette remarque conduit à préciser la définition de la complexité en temps. On peut en effet distinguer deux formes de complexité en temps :\n\nla complexité dans le meilleur des cas : c’est la situation la plus favorable, par exemple : recherche d’un élément situé à la première position d’une liste ;\nla complexité dans le pire des cas : c’est la situation la plus défavorable, par exemple : recherche d’un élément dans une liste alors qu’il n’y figure pas.\n\nOn calculera le plus souvent la complexité dans le pire des cas, car elle est la plus pertinente. Il vaut mieux en effet toujours envisager le pire.\n\nOrdres de grandeurs\nPour comparer des algorithmes, il n’est pas nécessaire de calculer la valeur exacte de la complexité, mais seulement un ordre de grandeur asymptotique, noté en mathématiques \\(\\mathcal{O}\\) (notation “grand O”). La définition rigoureuse de cette notation n’est pas au programme de NSI. Il faut cependant en avoir une idée intuitive : dire que la complexité d’un algorithme est en \\(\\mathcal{O}(n^2)\\), par exemple, signifie que cette complexité croît, lorsque \\(n\\) devient grand, de la même façon que la fonction carré. Plus précisément, elle est majorée par une fonction du type \\(c\\times n^2\\), où \\(c\\) est un réel positif.\nLes classes de complexité à connaître en première, de la meilleure à la pire :\n\n\n\n\n\n\n\n\n\\(\\mathcal{O}\\)\nType de complexité\nExemple\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nconstante\nAccès à une cellule de tableau\n\n\n\\(\\mathcal{O}(n)\\)\nlinéaire\nRecherche du maximum dans un tableau non trié\n\n\n\\(\\mathcal{O}(n^2)\\)\nquadratique\nParcours d’un tableau à deux dimensions\n\n\n\\(\\mathcal{O}(n^3)\\)\ncubique\nParcours d’un tableau à trois dimensions\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nReprenons l’algorithme du calcul de la puissance d’un nombre.\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nNous comptons la complexité en termes d’opérations arithmétiques : additions et multiplications. À chaque passage dans la boucle, nous avons deux opérations et la boucle est parcourue \\(n\\) fois . Nous avons donc au total une complexité de \\(2n\\) opérations arithmétiques, donc une complexité en \\(\\mathcal{O}(n)\\), linéaire.\n\n\n\nVisualisation graphique du temps d’exécution\nEn utilisant le module timeit comme expliqué dans cet article, on peut visualiser graphiquement le temps d’exécution de l’algorithme en fonction de la taille des données.\n\nimport matplotlib.pyplot as plt\nimport timeit\n\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\n\nabscisses = [k for k in range(0, 20, 1)]\nordonnees = []\nfor n in abscisses:\n    ordonnees.append(timeit.timeit('puissance(2, n)', number=100, globals=globals()))\n\nfig, ax = plt.subplots()\nax.set_xlabel('n')\nax.set_ylabel('temps (s)')\nplt.plot(abscisses, ordonnees, 'r')\nplt.show()\n\n\n\n\n\n\n\n\nLa courbe obtenue est proche d’une droite, ce qui est cohérent avec la complexité linéaire de l’algorithme.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_exos.html",
    "href": "13_vonNeumann/neumann_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_exos.html#assembleur",
    "href": "13_vonNeumann/neumann_exos.html#assembleur",
    "title": "Exercices",
    "section": "Assembleur",
    "text": "Assembleur",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_exos.html#exercice-2",
    "href": "13_vonNeumann/neumann_exos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\n\nExpliquez brièvement par une phrase, les instructions suivantes :\n\nADD R0, R1, #42\nLDR R5,98\nCMP R4, #18\nBGT 77\nSTR R0,15\nB 100\n\nÉcrire les instructions en assembleur correspondant aux phrases suivantes :\n\n« Additionne la valeur stockée dans le registre R0 et la valeur stockée dans le registre R1, le résultat est stocké dans le registre R5 »\n« Place la valeur stockée à l’adresse mémoire 878 dans le registre R0 »\n« Place le contenu du registre R0 en mémoire vive à l’adresse 124 »\n« La prochaine instruction à exécuter se situe en mémoire vive à l’adresse 478 »\n« Si la valeur stockée dans le registre R0 est égale 42 alors la prochaine instruction à exécuter se situe à l’adresse mémoire 85 »",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_exos.html#exercice-3",
    "href": "13_vonNeumann/neumann_exos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\nOn considère le programme Python donné à la fin du cours et sa traduction en Python.\nx = 4\ny = 8\nif x == 10:\n    y = 9\nelse :\n    x=x+1\nz=6\net voici maintenant voici son équivalent en assembleur :\n\n\nAssembleur\n\nMOV R0, #4\nSTR R0,30\nMOV R0, #8\nSTR R0,75\nLDR R0,30\nCMP R0, #10\nBNE else\nMOV R0, #9\nSTR R0,75\nB endif\nelse:\nLDR R0,30\nADD R0, R0, #1\nSTR R0,30\nendif:\nMOV R0, #6\nSTR R0,23\nHALT\n\n\nÀ quoi sert la ligne B endif ?\nÀ quoi correspondent les adresses mémoires 23, 75 et 30 ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_exos.html#exercice-4",
    "href": "13_vonNeumann/neumann_exos.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\nLe module dis de Python permet de “désassembler” du code Python, c’est-à-dire d’afficher les instructions machines correspondant à des instructions Python.\n\nEn console interactive, entrer les lignes suivantes et interpréter le résultat.\n&gt;&gt;&gt; import dis\n&gt;&gt;&gt; code = \"\"\"\na = 5\na = a + 3\n\"\"\"\n&gt;&gt;&gt; dis.dis(code)\nRecommencer en remplaçant le code analysé par le code de l’exercice précédent. Expliquer les différences entre l’assembleur Python et l’assembleur utilisé dans l’exercice précédent.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_3.html",
    "href": "13_vonNeumann/neumann_cours_3.html",
    "title": "Cours : Partie 3",
    "section": "",
    "text": "John von Neumann (mathématicien et physicien américano-hongrois 1903-1957) a eu l’idée en 1945 d’utiliser une structure de stockage (mémoire) unique pour les données et les instructions : on parle d’architecture de von Neumann\n\nLa première innovation est la séparation nette entre l’unité de commande, qui organise le flot de séquencement des instructions, et l’unité arithmétique, chargée de l’exécution proprement dite de ces instructions. La seconde innovation, la plus fondamentale, est l’idée du programme enregistré : les instructions, au lieu d’être codées sur un support externe (ruban, cartes, tableau de connexions), sont enregistrées dans la mémoire selon un codage conventionnel. Un compteur ordinal contient l’adresse de l’instruction en cours d’exécution ; il est automatiquement incrémenté après exécution de l’instruction, et explicitement modifié par les instructions de branchement.\nUn emplacement de mémoire peut contenir indifféremment des instructions et des données, et une conséquence majeure (dont toute la portée n’avait probablement pas été perçue à l’époque) est qu’un programme peut être traité comme une donnée par d’autres programmes. Cette idée, présente en germe dans la machine de Turing, trouvait ici sa concrétisation\nPour en savoir plus sur l’aspect historique du modèle, voir cet article du site interstices.\n\n1. Le modèle\nL’architecture de Von Neumann est un modèle d’architecture d’ordinateur dans lequel une unité de stockage (mémoire) unique sert à conserver à la fois les instructions et les données demandées ou produites par le calcul. Les ordinateurs actuels sont tous basés sur des versions améliorées de cette architecture.\nL’architecture de Von Neumann décompose l’ordinateur en 4 parties distinctes :\n\nL’unité arithmétique et logique (UAL ou ALU en anglais) ou unité de traitement : son rôle est d’effectuer les opérations de base ;\nL’unité de contrôle (ou de commande), chargée du « séquençage » des opérations ;\nLa mémoire qui contient à la fois les données et le programme qui indiquera à l’unité de contrôle quels sont les calculs à faire sur ces données ;\nLes dispositifs d’entrée-sortie, qui permettent de communiquer avec le monde extérieur.\n\n\nDe nos jours, le modèle a évolué :\n\n\nLes entrées-sorties, initialement commandées par l’unité centrale, sont depuis le début des années 1960 sous le contrôle de processeurs autonomes (canaux d’entrée-sortie et mécanismes assimilés). Associée à la multiprogrammation (partage de la mémoire entre plusieurs programmes), cette organisation a notamment permis le développement des systèmes en temps partagé.\nLes ordinateurs comportent maintenant des processeurs multiples, qu’il s’agisse d’unités séparées ou de « cœurs » multiples à l’intérieur d’une même puce. Cette organisation permet d’atteindre une puissance globale de calcul élevée sans augmenter la vitesse des processeurs individuels, limitée par les capacités d’évacuation de la chaleur dans des circuits de plus en plus denses.\n\n\n\n2. Le processeur\nDe nos jours, l’unité arithmétique et logique et l’unité de commande sont regroupées au sein d’une même puce : le processeur (CPU : Central Processing Unit).\nLe processeur comporte en réalité schématiquement trois parties :\n\nL’unité arithmétique et logique est chargée de l’exécution de tous les calculs que peut réaliser le microprocesseur ;\nLes registres permettent de mémoriser de l’information (donnée ou instruction) au sein même du CPU, en très petite quantité ;\nL’unité de contrôle (ou de commande) . C’est le coordinateur général qui lit les instructions du programme en mémoire et commande l’UAL pour exécuter ces instructions.\n\n\nLes microprocesseurs sont cadencés par un signal d’horloge (signal oscillant régulier imposant un rythme au transfert entre circuit). Au milieu des années 1980, ce signal avait une fréquence de 4 à 8 MHz. Dans les années 2000, cette fréquence atteint 3 GHz. Plus cette fréquence est élevée, plus le microprocesseur peut exécuter à un rythme élevé les instructions de base des programmes.\n\n\n\n3. La mémoire\nLa mémoire permet de stocker des données et des programmes. Elle se divise entre mémoire volatile donc non permanente (programmes et données en cours de fonctionnement) et mémoire permanente (programmes et données de base de la machine).\nDans la plupart des mémoires, les informations sont classées par adresses : chaque octet est accessible par une adresse unique.\nPour des raisons économiques, les mémoires sont en général divisées en plusieurs familles (les ordres de grandeurs sont indiqués pour donner une idée, mais ils évoluent constamment) :\n\nUne mémoire de masse ou mémoire de stockage (permanente)\nCette mémoire sert à stocker à long terme des grandes quantités d’informations. Les technologies les plus courantes de mémoires de masse sont électromécaniques (disques durs - HDD) ou à semi-conducteurs (SSD, clefs USB, …). Elles visent à obtenir une capacité de stockage élevée à faible coût et ont généralement une vitesse inférieure aux autres mémoires.\nOrdres de grandeur :\n\nCapacité : jusqu’à 10 To (HDD)\nVitesse : jusqu’à 500 Mo/s (SSD)\n\n\nLa mémoire vive ou RAM : Random Access Memory (non permanente)\nEspace principal de stockage du microprocesseur, mais dont le contenu disparaît lors de la mise hors tension de l’ordinateur.\nOrdres de grandeur :\n\nCapacité : jusqu’à 32 Go\nVitesse : jusqu’à 2 Go/s\n\n\nLa mémoire cache\nSert à conserver un court instant des informations fréquemment consultées. Les technologies des mémoires caches visent à accélérer la vitesse des opérations de consultation. Elles ont une très grande vitesse, et un coût élevé pour une faible capacité de stockage. Cette mémoire est intégrée au microprocesseur. Il existe des mémoires caches à différents niveaux (L1, L2, …), qui possèdent des caractéristiques différentes.\nOrdres de grandeur :\n\nCapacité : quelques ko (L1) à quelques Mo (L2)\nVitesse : jusqu’à 5 Go/s\n\n\nLes registres du processeur\nIntégrés au processeur. Ce type de mémoire est très rapide mais aussi très cher et est donc réservé à une très faible quantité de données.\nOrdres de grandeur :\n\nCapacité : quelques dizaines d’octets\nVitesse : jusqu’à 30 Go/s\n\n\n\n\n4. Les bus\nPour que les données circulent entre les différentes parties d’un ordinateur (mémoire, CPU et les entrées/sorties), il existe des systèmes de communication appelés bus (c’est le squelette de l’architecture). Il en existe de 3 grands types :\n\nLe bus d’adresse permet de faire circuler des adresses. Par exemple, l’adresse d’une donnée à aller chercher en mémoire ;\nLe bus de données permet de faire circuler des données ;\nLe bus de contrôle permet de spécifier le type d’action. Par exemple : écriture d’une donnée en mémoire, lecture d’une donnée en mémoire.\n\n\nPour en savoir plus, voir la vidéo “Comment fonctionne un ordinateur ?” dans cet article.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 3"
    ]
  },
  {
    "objectID": "13_vonNeumann/index.html",
    "href": "13_vonNeumann/index.html",
    "title": "Programme",
    "section": "",
    "text": "Exprimer un algorithme dans un langage de programmation a pour but de le rendre exécutable par une machine dans un contexte donné. La découverte de l’architecture des machines et de leur système d’exploitation constitue une étape importante.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nModèle d’architecture séquentielle (von Neumann)\nDistinguer les rôles et les caractéristiques des différents constituants d’une machine. Dérouler l’exécution d’une séquence d’instructions simples du type langage machine.\nLa présentation se limite aux concepts généraux. On distingue les architectures monoprocesseur et les architectures multiprocesseur. Des activités débranchées sont proposées. Les circuits combinatoires réalisent des fonctions booléennes.\n\n\n\nExprimer un algorithme dans un langage de programmation a pour but de le rendre exécutable par une machine dans un contexte donné. La découverte de l’architecture des machines et de leur système d’exploitation constitue une étape importante.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nSystèmes d’exploitation\nIdentifier les fonctions d’un système d’exploitation. Utiliser les commandes de base en ligne de commande. Gérer les droits et permissions d’accès aux fichiers.\nLes différences entre systèmes d’exploitation libres et propriétaires sont évoquées. Les élèves utilisent un système d’exploitation libre. Il ne s’agit pas d’une étude théorique des systèmes d’exploitation."
  },
  {
    "objectID": "13_vonNeumann/index.html#programme",
    "href": "13_vonNeumann/index.html#programme",
    "title": "Programme",
    "section": "",
    "text": "Exprimer un algorithme dans un langage de programmation a pour but de le rendre exécutable par une machine dans un contexte donné. La découverte de l’architecture des machines et de leur système d’exploitation constitue une étape importante.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nModèle d’architecture séquentielle (von Neumann)\nDistinguer les rôles et les caractéristiques des différents constituants d’une machine. Dérouler l’exécution d’une séquence d’instructions simples du type langage machine.\nLa présentation se limite aux concepts généraux. On distingue les architectures monoprocesseur et les architectures multiprocesseur. Des activités débranchées sont proposées. Les circuits combinatoires réalisent des fonctions booléennes.\n\n\n\nExprimer un algorithme dans un langage de programmation a pour but de le rendre exécutable par une machine dans un contexte donné. La découverte de l’architecture des machines et de leur système d’exploitation constitue une étape importante.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nSystèmes d’exploitation\nIdentifier les fonctions d’un système d’exploitation. Utiliser les commandes de base en ligne de commande. Gérer les droits et permissions d’accès aux fichiers.\nLes différences entre systèmes d’exploitation libres et propriétaires sont évoquées. Les élèves utilisent un système d’exploitation libre. Il ne s’agit pas d’une étude théorique des systèmes d’exploitation."
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_1.html",
    "href": "13_vonNeumann/neumann_cours_1.html",
    "title": "Cours : Partie 1",
    "section": "",
    "text": "Ce panorama rapide est issu, à quelques modifications près, du cours de Anthony Juton, Professeur agrégé en Physique appliquée (MOOC NSI : les fondamentaux).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 1"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_1.html#jusquà-1945",
    "href": "13_vonNeumann/neumann_cours_1.html#jusquà-1945",
    "title": "Cours : Partie 1",
    "section": "1. Jusqu’à 1945",
    "text": "1. Jusqu’à 1945\n\nUne première date est la publication par le mathématicien Muhammad Al-Khwârizmî d’une classification des algorithmes existants au 9ème siècle. Le mot algorithme est issu de son nom.\nAu 17ème siècle, le philosophe et scientifique Blaise Pascal développe une machine d’arithmétique capable de faire mécaniquement des additions et soustractions et, par répétition, des multiplications et divisions. On la nomme aujourd’hui pascaline.\nAu 18ème siècle, l’inventeur français Joseph Marie Jacquard automatise les métiers à tisser mécanique. Le motif est codé sous la forme d’une séquence d’instructions décrite par une carte perforée.\nEn 1840, le mathématicien anglais Charles Babbage conçoit une machine à calculer mécanique, à vapeur, dont la séquence d’instruction est fournie par une carte perforée. La machine fonctionnant en décimal est complexe et jamais il ne terminera sa construction. Cependant, c’est pour cette machine, majoritairement théorique, que Ada Lovelace, comtesse anglaise, écrira les premiers programmes informatiques.\nDans les mêmes temps, Georges Boole, mathématicien et philosophe britannique, formalise une algèbre binaire s’appuyant sur deux uniques états, 1 et 0. Elle est nommée depuis algèbre booléenne et, bien adaptée au relais, tubes et transistor, elle simplifiera beaucoup la réalisation de calculateurs.\nEn 1936, Alan Turing, mathématicien britannique, propose un modèle théorique de machine permettant d’exécuter toute opération mathématique calculable à partir de quelques instructions simples, la machine de Turing universelle. Une machine est alors dite Turing-complète si elle permet de faire tout ce que le modèle théorique décrit. Suivent alors plusieurs tentatives de réalisation, d’abord avec des relais mécaniques. Le premier ordinateur Turing-complet serait l’ordinateur électromécanique allemand binaire Zuse 3, détruit pendant la guerre.\nEn 1945, sous la conduite du physicien américain John William Mauchly et de son compatriote ingénieur Presper Eckert, est développée une autre réalisation matérielle Turing-complète, cette fois utilisable durablement. L’ENIAC (Electronic Numerical Integrator And Computer) est financé par l’armée américaine pour résoudre des problèmes de balistique. Contrairement au Z3, il est décimal, ce qui augmente sa complexité, et utilise des tubes à vides, plus rapides que les relais.\nL’ENIAC dispose de 17 000 tubes à vides, consomme 150 kW et est capable de 5000 additions, 357 multiplications ou 38 divisions par seconde. Les tubes étaient peu fiables, un insecte, parmi les premiers bugs informatiques, venant souvent mourir sur un tube brûlant pendant la journée, provoquant sa destruction.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 1"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_1.html#après-1945",
    "href": "13_vonNeumann/neumann_cours_1.html#après-1945",
    "title": "Cours : Partie 1",
    "section": "2. Après 1945",
    "text": "2. Après 1945\n\nEn 1947 commence l’histoire moderne de l’informatique. 3 physiciens américains des laboratoires Bell, William Shockley, John Bardeen, Walter Brattain découvrent l’effet transistor. Dans un semi-conducteur au germanium, un courant électrique permet de contrôler l’ouverture d’un circuit électrique. Il devient alors possible de remplacer les coûteux et peu fiables tubes à vide. Le transistor permet rapidement un bond en avant pour l’informatique, l’électronique, les télécommunications et est à l’origine de la création de l’électronique de puissance. Cette découverte est saluée par l’attribution du prix Nobel de physique en 1956.\nAvec le transistor, complexe à fabriquer, apparaît la différenciation entre concepteur de processeur et développeur de programme.\nDès 1958, la société Fairchild semi-conducteurs, fondée notamment par Gordon Moore pour développer des semi-conducteurs à base de silicium, sort les premiers circuits intégrés regroupant de nombreux transistors gravés sur la même puce de silicium pour assurer des fonctions logiques.\nEn 1968, Gordon Moore encore et 2 associés fondent la société Intel (pour Integrated Electronic) dans la naissante Silicon Valley et en 1971 commercialisent le premier processeur monolithique (sur une seule puce), l’Intel 4004, avec 2300 Transistors. La largeur de grille des transistors, ici 10 µm, caractérise la finesse de gravure des transistors.\nPeu de temps après, Gordon Moore, toujours lui, annonce un doublement du nombre de transistors par circuit intégré tous les 2 ans. C’est la loi de Moore. A la fois anticipation et feuille de route de l’industrie micro-électronique, cette loi continue d’être vérifiée 46 ans après, soit une multiplication par \\(2^23 \\approx 8\\) Millions du nombre de transistors sur une puce.\n1976 marque l’apparition de l’apple 1, rapidement remplacé par l’apple 2. Conçu pour être produits massivement à un prix raisonnable, ils contribuent à la diffusion de l’informatique. L’interface graphique facilitant son utilisation apparaîtra en 1986.\nEn 1981, IBM lance le PC (Personal Computer) basé sur une architecture ouverte qui sera reprise par de nombreux autres constructeurs.\nLe développement des PC avec processeur Intel et dans une moindre mesure des ordinateurs Apple avec processeurs Motorola est tel qu’ils orientent l’évolution des technologies. Les processeurs généralistes progressent rapidement et les investissements pour suivre en terme de fabrication deviennent colossaux. Les autres architectures plus spécialisées comme les machines-langage, optimisés pour un langage, ne peuvent suivre et disparaissent.\nLe millénaire se termine avec la victoire aux échecs du calculateur Deep Blue contre le champion du monde et l’apparition du processeur Intel Pentium 3, comprenant 10 Millions de transistors de largeur de grille 200 nm. Il fonctionne avec une horloge à 1 GHz.\nPour en savoir plus sur l’évolution des ordinateurs, voir cet article.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 1"
    ]
  },
  {
    "objectID": "12_dictionnaires/index.html",
    "href": "12_dictionnaires/index.html",
    "title": "Programme",
    "section": "",
    "text": "À partir des types de base se constituent des types construits, qui sont introduits au fur et à mesure qu’ils sont nécessaires.\nIl s’agit de présenter tour à tour les p-uplets (tuples), les enregistrements qui collectent des valeurs de types différents dans des champs nommés et les tableaux qui permettent un accès calculé direct aux éléments. En pratique, on utilise les appellations de Python, qui peuvent être différentes de celles d’autres langages de programmation.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\np-uplets. p-uplets nommés\nÉcrire une fonction renvoyant un p-uplet de valeurs.\n\n\n\nTableau indexé, tableau donné en compréhension\nLire et modifier les éléments d’un tableau grâce à leurs index. Construire un tableau par compréhension. Utiliser des tableaux de tableaux pour représenter des matrices : notation a [i] [j]. Itérer sur les éléments d’un tableau.\nSeuls les tableaux dont les éléments sont du même type sont présentés. Aucune connaissance des tranches (slices) n’est exigible. L’aspect dynamique des tableaux de Python n’est pas évoqué. Python identifie listes et tableaux. Il n’est pas fait référence aux tableaux de la bibliothèque NumPy.\n\n\nDictionnaires par clés et valeurs\nConstruire une entrée de dictionnaire. Itérer sur les éléments d’un dictionnaire.\nIl est possible de présenter les données EXIF d’une image sous la forme d’un enregistrement. En Python, les p-uplets nommés sont implémentés par des dictionnaires. Utiliser les méthodes keys(), values () et items ()."
  },
  {
    "objectID": "12_dictionnaires/index.html#programme",
    "href": "12_dictionnaires/index.html#programme",
    "title": "Programme",
    "section": "",
    "text": "À partir des types de base se constituent des types construits, qui sont introduits au fur et à mesure qu’ils sont nécessaires.\nIl s’agit de présenter tour à tour les p-uplets (tuples), les enregistrements qui collectent des valeurs de types différents dans des champs nommés et les tableaux qui permettent un accès calculé direct aux éléments. En pratique, on utilise les appellations de Python, qui peuvent être différentes de celles d’autres langages de programmation.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\np-uplets. p-uplets nommés\nÉcrire une fonction renvoyant un p-uplet de valeurs.\n\n\n\nTableau indexé, tableau donné en compréhension\nLire et modifier les éléments d’un tableau grâce à leurs index. Construire un tableau par compréhension. Utiliser des tableaux de tableaux pour représenter des matrices : notation a [i] [j]. Itérer sur les éléments d’un tableau.\nSeuls les tableaux dont les éléments sont du même type sont présentés. Aucune connaissance des tranches (slices) n’est exigible. L’aspect dynamique des tableaux de Python n’est pas évoqué. Python identifie listes et tableaux. Il n’est pas fait référence aux tableaux de la bibliothèque NumPy.\n\n\nDictionnaires par clés et valeurs\nConstruire une entrée de dictionnaire. Itérer sur les éléments d’un dictionnaire.\nIl est possible de présenter les données EXIF d’une image sous la forme d’un enregistrement. En Python, les p-uplets nommés sont implémentés par des dictionnaires. Utiliser les méthodes keys(), values () et items ()."
  },
  {
    "objectID": "12_dictionnaires/dicos.html",
    "href": "12_dictionnaires/dicos.html",
    "title": "Cours",
    "section": "",
    "text": "Tout comme les p-uplets et les tableaux, les dictionnaires sont un type construit de données pouvant contenir plusieurs éléments. Mais à la différence des deux autres structures étudiées, les éléments contenus dans un dictionnaire ne sont pas ordonnés et ils ne sont pas indexés par un entier, mais par une clé qui peut être de différents types.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Cours"
    ]
  },
  {
    "objectID": "12_dictionnaires/dicos.html#définition-et-création-dun-dictionnaire",
    "href": "12_dictionnaires/dicos.html#définition-et-création-dun-dictionnaire",
    "title": "Cours",
    "section": "1. Définition et création d’un dictionnaire",
    "text": "1. Définition et création d’un dictionnaire\n\n\n\n\n\n\nDéfinition\n\n\n\nUn dictionnaire est une collection de paires de la forme clé:valeur.\nEn Python, ils sont implémentés par le type dict et sont délimités par des accolades.\n\n\nOn peut définir un dictionnaire de différentes façons :\n\nen écrivant les couples les uns à la suite des autres, séparés par des virgules, le tout entre accolades.\n\n&gt;&gt;&gt; capitales = {\"France\":\"Paris\", \"Allemagne\":\"Berlin\", \"Italie\":\"Rome\", \"Espagne\":\"Madrid\", \"Suisse\":\"Berne\",\n                \"Luxembourg\":\"Luxembourg\", \"Belgique\":\"Bruxelles\", \"Pays-Bas\":\"Amsterdam\", \"Royaume-Uni\":\"Londres\"}\n&gt;&gt;&gt; type(capitales)\n&lt;class 'dict'&gt;  \n\nen compréhension, comme avec les tableaux.\n\n&gt;&gt;&gt; d = {chr(65+i): i for i in range(26)}\n&gt;&gt;&gt; d\n{'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8, 'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16, 'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24, 'Z': 25}\n\nélément par élément après avoir défini un dictionnaire vide.\n\n&gt;&gt;&gt; superficie = {}\n&gt;&gt;&gt; superficie[\"France\"] = 543940\n&gt;&gt;&gt; superficie[\"Allemagne\"] = 357588\n&gt;&gt;&gt; superficie[\"Espagne\"] = 505992\n&gt;&gt;&gt; superficie\n{'France': 543940, 'Allemagne': 357588, 'Espagne': 505992}\n\n\n\n\n\n\nAttention !\n\n\n\nLes clés et les valeurs peuvent être de différents types, mais avec des restrictions concernant les clés. Celles-ci ne peuvent prendre que des types immuables, c’est-à-dire non modifiables. Un tableau ne pourra par exemple pas servir de clé. Par contre, un tuple le peut s’il ne contient que des éléments eux-mêmes immuables.\nOn utilisera comme clés des éléments du type : str, int, float, tuple.\nUn dictionnaire est un objet variable, il ne peut donc pas servir de clé.\nLes valeurs, par contre, peuvent être de n’importe quel type, y compris des dictionnaires. Dans un même dictionnaire, les différentes clés peuvent être de types différents et les différentes valeurs également.\nUne clé donnée ne peut apparaître qu’une fois dans un dictionnaire. Si une clé existante est à nouveau spécifiée, la nouvelle valeur écrase la précédente.\nPar contre, une même valeur peut apparaître plusieurs fois, associée à des clés différentes.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Cours"
    ]
  },
  {
    "objectID": "12_dictionnaires/dicos.html#manipulation-des-dictionnaires",
    "href": "12_dictionnaires/dicos.html#manipulation-des-dictionnaires",
    "title": "Cours",
    "section": "2. Manipulation des dictionnaires",
    "text": "2. Manipulation des dictionnaires\n\nAccès aux éléments\nOn accède à une valeur en utilisant sa clé comme indice :\n&gt;&gt;&gt; capitales[\"Espagne\"]\n'Madrid'\nL’utilisation d’une clé inexistante renvoie une erreur. Pour éviter cela, on peut aussi utiliser la méthode get() qui va renvoyer None si la clé n’existe pas.\n&gt;&gt;&gt; capitales[\"Autriche\"]\nTraceback (most recent call last):\n  File \"C:\\Users\\fabri\\AppData\\Local\\Programs\\Python\\Python310\\lib\\code.py\", line 90, in runcode\n    exec(code, self.locals)\n  File \"&lt;input&gt;\", line 1, in &lt;module&gt;\nKeyError: 'Autriche'\n&gt;&gt;&gt; capitales.get(\"Autriche\")\n&gt;&gt;&gt; print(capitales.get(\"Autriche\"))\nNone\nLes méthodes keys(), values() et items() permettent respectivement d’accéder à la liste des clés, à la liste des valeurs et à la liste des couples (clés, valeurs).\n&gt;&gt;&gt; capitales.keys()\ndict_keys(['France', 'Allemagne', 'Italie', 'Espagne', 'Suisse', 'Luxembourg', 'Belgique', 'Pays-Bas', 'Royaume-Uni'])\n&gt;&gt;&gt; capitales.values()\ndict_values(['Paris', 'Berlin', 'Rome', 'Madrid', 'Berne', 'Luxembourg', 'Bruxelles', 'Amsterdam', 'Londres'])\n&gt;&gt;&gt; capitales.items()\ndict_items([('France', 'Paris'), ('Allemagne', 'Berlin'), ('Italie', 'Rome'), ('Espagne', 'Madrid'), ('Suisse', 'Berne'), ('Luxembourg', 'Luxembourg'), ('Belgique', 'Bruxelles'), ('Pays-Bas', 'Amsterdam'), ('Royaume-Uni', 'Londres')])\nOn peut tester l’appartenance à un dictionnaire avec le mot clé in :\n&gt;&gt;&gt; \"Uruguay\" in capitales.keys()\nFalse\n&gt;&gt;&gt; \"Berlin\" in capitales.values()\nTrue\n\n\nAutres opérations\n\n\n\n\n\n\nRemarque\n\n\n\n\nComme dit plus haut, les dictionnaires sont des structures modifiables : on peut changer la valeur associée à une clé donnée dans un programme.\nPar contre, on ne peut pas modifier une clé.\n\n\n\nL’instruction del permet de supprimer une valeur désignée par sa clé.\n&gt;&gt;&gt; superficie\n{'France': 543940, 'Allemagne': 357588, 'Espagne': 505992}\n&gt;&gt;&gt; del superficie[\"France\"]\n&gt;&gt;&gt; superficie\n{'Allemagne': 357588, 'Espagne': 505992}\nLa fonction len renvoie le nombre de valeurs contenues dans le dictionnaire.\n&gt;&gt;&gt; len(capitales)\n9\nCopie d’un dictionnaire : Les comportements sont similaires à ceux rencontrés avec les tableaux en particulier si les valeurs sont des tableaux. Il est donc conseillé d’utiliser la fonction deepcopy du module copy pour être certain d’obtenir une “vraie” copie.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Cours"
    ]
  },
  {
    "objectID": "12_dictionnaires/dicos.html#itérer-sur-les-éléments-dun-dictionnaire",
    "href": "12_dictionnaires/dicos.html#itérer-sur-les-éléments-dun-dictionnaire",
    "title": "Cours",
    "section": "3. Itérer sur les éléments d’un dictionnaire",
    "text": "3. Itérer sur les éléments d’un dictionnaire\nOn peut parcourir un dictionnaire à partir de ses clés :\n&gt;&gt;&gt; superficie = {}\n&gt;&gt;&gt; superficie[\"France\"] = 543940\n&gt;&gt;&gt; superficie[\"Allemagne\"] = 357588\n&gt;&gt;&gt; superficie[\"Espagne\"] = 505992\n&gt;&gt;&gt; for pays in superficie.keys():\n        print(pays)\n    \nFrance\nAllemagne\nEspagne\nOn peut parcourir un dictionnaire à partir de ses valeurs :\n&gt;&gt;&gt; for valeur in superficie.values():\n        print(valeur)\n    \n543940\n357588\n505992\nOn peut parcourir un dictionnaire à partir des couples (clé, valeur) :\n&gt;&gt;&gt; for pays, valeur in superficie.items():\n        print(f\"La superficie du pays {pays} est de {valeur} km²\")\n    \nLa superficie du pays France est de 543940 km²\nLa superficie du pays Allemagne est de 357588 km²\nLa superficie du pays Espagne est de 505992 km²\n\n\n\n\n\n\nRemarque importante\n\n\n\nUn gros avantage des dictionnaires est que leur implémentation optimise la recherche d’un élément. Il est beaucoup plus rapide de recherche une valeur dans un dictionnaire que dans un tableau, surtout si ceux-ci contiennent un grand nombre d’éléments. La raison de cette différence sera évoquée en terminale.\n\n\nPour les curieux, la vidéo proposée par Lumni en lien ici permet d’approfondir la notion de dictionnaire.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Cours"
    ]
  },
  {
    "objectID": "11_tableaux/tableaux.html",
    "href": "11_tableaux/tableaux.html",
    "title": "Zoom sur les tableaux (listes)",
    "section": "",
    "text": "Tableaux et listes\n\n\n\nDans ce cours, conformément au programme, nous allons employer le terme “tableau”. Ce terme désigne une structure de données abstraite en informatique. Dans le langage Python, on utilise des objets du type list pour cette structure. Cependant, les objets de type list en Python sont bien plus que des tableaux au sens du cours. Pour éviter toute confusion, notamment par rapport à d’autres structures de données qui seront abordées en terminale, nous nous efforcerons d’employer “tableau” à la place de “liste”.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les tableaux (listes)"
    ]
  },
  {
    "objectID": "11_tableaux/tableaux.html#création-dun-tableau",
    "href": "11_tableaux/tableaux.html#création-dun-tableau",
    "title": "Zoom sur les tableaux (listes)",
    "section": "1. Création d’un tableau",
    "text": "1. Création d’un tableau\nPour créer un tableau en Python, nous utilisons un objet de type list. Un tel objet ressemble à un p-uplet : un ensemble ordonné d’éléments avec des indices pour les repérer. Les éléments d’un tableau sont séparés par des virgules et entourés de crochets.\n&gt;&gt;&gt; tab1 = [\"a\", \"b\", \"c\"] # un tableau à 3 éléments\n&gt;&gt;&gt; tab2 = [1] # un tableau contenant un seul élément\n&gt;&gt;&gt; tab3 = [[1, 2], [3, 4]] # un tableau de tableaux\n&gt;&gt;&gt; tab_vide = [] # un tableau vide\nPour créer rapidement un tableau d’entiers, nous pouvons utiliser les fonctions list et range.\n&gt;&gt;&gt; tab = list(range(2, 10, 3)) # [2, 5, 8]\nPour ajouter les éléments un par un en fin de tableau, nous pouvons utiliser la méthode append :\nmultiples_de_3 = [0, 3]\nmultiples_de_3.append(6) # [0, 3, 6]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les tableaux (listes)"
    ]
  },
  {
    "objectID": "11_tableaux/tableaux.html#construction-par-compréhension",
    "href": "11_tableaux/tableaux.html#construction-par-compréhension",
    "title": "Zoom sur les tableaux (listes)",
    "section": "2. Construction par compréhension",
    "text": "2. Construction par compréhension\nIl est aussi possible de créer un tableau par compréhension. Il s’agit de décrire les éléments du tableau par une boucle, des conditions…\nL’instruction de base s’écrit sous la forme [expression(i) for i in objet]. Ce type de construction est très spécifique au langage Python. En voici deux exemples :\nmultiples_de_3 = [3 * i for i in range(100)]\nmultiples_de_6 = [2 * n for n in multiples_de_3]\nSi on dispose d’une fonction f et d’un tableau d’abscisses x :\nimages = [f(x) for x in abscisses]\nOn peut aussi ajouter des conditions. Par exemple l’instruction ci-dessous est une autre façon de définir le tableau des multiples de 3 :\nmultiples_de_3 = [n for n in range(301) if n % 3 == 0]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les tableaux (listes)"
    ]
  },
  {
    "objectID": "11_tableaux/tableaux.html#utilisation-des-tableaux",
    "href": "11_tableaux/tableaux.html#utilisation-des-tableaux",
    "title": "Zoom sur les tableaux (listes)",
    "section": "3. Utilisation des tableaux",
    "text": "3. Utilisation des tableaux\nLa fonction len renvoie la longueur d’un tableau, le nombre d’éléments du tableau.\nOn accède aux différents éléments d’un tableau avec les indices comme pour les p-uplets. Dans le cas d’un tableau de tableaux, on utilise des doubles crochets : tab[1][0].\n&gt;&gt;&gt; tab = [\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; tab[1]\n'b'\n&gt;&gt;&gt; tab = [[\"a\", \"b\"], [\"c\", \"d\"]]\n&gt;&gt;&gt; tab[1][0]\n'c'\nÀ la différence des tuples, un tableau est un objet modifiable (on dit mutable en anglais). On peut donc réaffecter un élément d’un tableau déjà créé.\n&gt;&gt;&gt; tab = [1, 2, 3, 4]\n&gt;&gt;&gt; tab[0] = 17\n&gt;&gt;&gt; tab\n[17, 2, 3, 4]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les tableaux (listes)"
    ]
  },
  {
    "objectID": "11_tableaux/tableaux.html#opérations-sur-les-tableaux",
    "href": "11_tableaux/tableaux.html#opérations-sur-les-tableaux",
    "title": "Zoom sur les tableaux (listes)",
    "section": "4. Opérations sur les tableaux",
    "text": "4. Opérations sur les tableaux\nLe type d’une variable définit les valeurs qui peuvent être affectées à cette variable ainsi que les opérateurs et les fonctions utilisables. Les fonctions propres à un type donné sont appelées des méthodes. La fonction len par exemple, s’applique aux chaînes de caractères, aux p-uplets, aux tableaux. La méthode append, présentée plus haut, est par contre propre aux tableaux.\nAttention à la syntaxe : on écrit len(tab), mais tab.append(...). Le nom de la variable est suivi d’un point puis du nom de la méthode. Cette notation est issue de la programmation orientée objets qui sera abordée en terminale.\nVoici quelques méthodes pour le tableau :\n&gt;&gt;&gt; tab = [\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; tab.insert(1, \"d\") # insertion à l'indice 1 de l'élément \"d\"\n&gt;&gt;&gt; tab\n['a', 'd', 'b', 'c']\n&gt;&gt;&gt; tab.remove(\"b\") # suppression de la première occurrence de l'élément \"b\"\n&gt;&gt;&gt; tab\n['a', 'd', 'c']\n&gt;&gt;&gt; x = tab.pop() # supprime et retourne le dernier élément\n&gt;&gt;&gt; x\n'c'\n&gt;&gt;&gt; tab\n['a', 'd']\n&gt;&gt;&gt; tab.reverse() # renverse l'ordre des éléments\n&gt;&gt;&gt; tab\n['d', 'a']\n&gt;&gt;&gt; tab.sort() # trie les éléments dans l'ordre croissant ou alphabétique\n&gt;&gt;&gt; tab\n['a', 'd']\nToutes ces méthodes modifient la liste initiale contrairement aux opérateurs de concaténation + et * avec lesquels une nouvelle liste est créée. Ces deux opérateurs s’utilisent comme avec les p-uplets.\nNotons qu’il est aussi possible de trier une liste sans la modifier avec la fonction sorted qui crée une nouvelle liste.\n&gt;&gt;&gt; tab = [5, 2, 7, 4]\n&gt;&gt;&gt; tri = sorted(tab)\n&gt;&gt;&gt; tab\n[5, 2, 7, 4]\n&gt;&gt;&gt; tri\n[2, 4, 5, 7]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les tableaux (listes)"
    ]
  },
  {
    "objectID": "11_tableaux/tableaux.html#copie-dun-tableau",
    "href": "11_tableaux/tableaux.html#copie-dun-tableau",
    "title": "Zoom sur les tableaux (listes)",
    "section": "5. Copie d’un tableau",
    "text": "5. Copie d’un tableau\nUn tableau peut donc être modifié par une méthode. On peut aussi modifier l’un de ses éléments par affectation.\n&gt;&gt;&gt; tab = [\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; tab[1] = \"d\"\n&gt;&gt;&gt; tab\n[\"a\", \"d\", \"c\"]\nCeci oblige à une grande attention en particulier dans la création de copie de tableau. Observons le code suivant :\n&gt;&gt;&gt; tab1 = [\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; tab2 = tab1\n&gt;&gt;&gt; tab1[1] = \"d\"\n&gt;&gt;&gt; tab2\n[\"a\", \"d\", \"c\"]\nDans cet exemple, un même tableau a deux noms et tab2 n’est pas une copie de tab1 : il s’agit juste d’une nouvelle étiquette qui pointe vers le même contenu de la mémoire.\n\n\nPour obtenir une vraie copie, il faut créer un nouveau tableau.\nPour effectuer une vraie copie d’une liste simple, on peut entrer :\n&gt;&gt;&gt; tab2 = list(tab1)\n\n\nPour des tableaux de tableaux, cependant, cette copie simple ne suffira pas, car les éléments du tableau, qui sont eux-mêmes des tableaux, ne seront pas vraiment copiés. Pour y parvenir, si nécessaire, on utilise la fonction deepcopy de la bibliothèque copy.\n&gt;&gt;&gt; from copy import deepcopy\n&gt;&gt;&gt; tab1 = [[\"a\", \"b\"], [\"c\", \"d\"]]\n&gt;&gt;&gt; tab2 = deepcopy(liste1)\n&gt;&gt;&gt; tab2[1][0] = \"e\"\n&gt;&gt;&gt; tab2\n[[\"a\", \"b\"], [\"e\", \"d\"]]\n&gt;&gt;&gt; tab1\n[[\"a\", \"b\"], [\"c\", \"d\"]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les tableaux (listes)"
    ]
  },
  {
    "objectID": "11_tableaux/tableaux.html#parcours-dun-tableau-avec-une-boucle-for",
    "href": "11_tableaux/tableaux.html#parcours-dun-tableau-avec-une-boucle-for",
    "title": "Zoom sur les tableaux (listes)",
    "section": "6. Parcours d’un tableau avec une boucle for",
    "text": "6. Parcours d’un tableau avec une boucle for\nUne boucle for permet de parcourir chacun des éléments d’un tableau. On peut soit boucler sur les indices des éléments du tableau, soit sur les éléments eux-mêmes.\n&gt;&gt;&gt; t = [1,2,3,4]\n&gt;&gt;&gt; for k in t:  # boucle sur les éléments\n        print(k)\n1\n2\n3\n4\n&gt;&gt;&gt; for i in range(len(t)): # boucle sur les indices\n        print(t[i])\n1\n2\n3\n4\n\n\n\n\n\n\nÀ retenir\n\n\n\n\nUn tableau une structure ordonnée qui permet de contenir plusieurs éléments qui sont tous accessibles.\nTous les éléments d’un tableau sont du même type. Un tableau peut contenir d’autres tableaux.\nUn tableau est modifiable : on peut procéder à une affectation de la forme t[i]=valeur",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les tableaux (listes)"
    ]
  },
  {
    "objectID": "11_tableaux/tableaux.html#remarques-sur-les-tableaux-de-tableaux",
    "href": "11_tableaux/tableaux.html#remarques-sur-les-tableaux-de-tableaux",
    "title": "Zoom sur les tableaux (listes)",
    "section": "7. Remarques sur les tableaux de tableaux",
    "text": "7. Remarques sur les tableaux de tableaux\nVoici un exemple de tableau de tableaux :\nm = [[1, 3, 4], [5 ,6 ,8], [2, 1, 3], [7, 8, 15]]\nLe premier élément du tableau ci-dessus est bien un tableau ([1, 3, 4]), le deuxième élément est aussi un tableau ([5, 6, 8])…\nIl est souvent plus pratique de présenter ces “tableaux de tableaux” comme ci-dessous :\nm = [[1, 3, 4],\n     [5, 6, 8],\n     [2, 1, 3],\n     [7, 8, 15]]\nNous obtenons ainsi quelque chose qui ressemble beaucoup à un “objet mathématique” très utilisé : une matrice, tableau de nombres composé de lignes et de colonnes.\nL’instruction m[1] retourne le deuxième élément du tableau m, c’est-à-dire le tableau [5, 6, 8].\nPour accéder au troisième élément de ce dernier tableau, il faut donc entrer l’instruction m[1][2] qui va renvoyer 8.\nOn accède donc aux éléments du tableau de nombres en indexant m avec le numéro de la ligne puis le numéro de la colonne (comptés à partir de zéro).\nIl est possible de parcourir l’ensemble des éléments d’une matrice à l’aide d’une “double boucle for” :\nm = [[1, 3, 4],\n     [5, 6, 8],\n     [2, 1, 3],\n     [7, 8, 15]]\nnb_colonne = 3\nnb_ligne = 4\nfor i in range(0, nb_ligne):\n    for j in range(0, nb_colonne):\n        a = m[i][j]\n        print(a)\nL’exécution de ce programme donnera le résultat suivant :\n1\n3\n4\n5\n6\n8\n2\n1\n3\n7\n8\n15\nNous avons bien parcouru l’ensemble des éléments du tableau m.\nCette double boucle for est une structure complexe, mais pourtant assez répandue. N’hésitez pas à consacrer quelques minutes à son analyse.\nCe type de tableau à deux dimensions est utilisé pour coder les images sous forme d’images matricielles. Les curieux peuvent en apprendre plus à ce sujet en étudiant la vidéo suivante proposée sur Lumni (dans laquelle le narrateur dit “liste” au lieu de “tableau”).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les tableaux (listes)"
    ]
  },
  {
    "objectID": "11_tableaux/exos_tabs.html",
    "href": "11_tableaux/exos_tabs.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "11_tableaux/exos_tabs.html#exercice-1",
    "href": "11_tableaux/exos_tabs.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\nDonner les valeurs des tableaux T1, T2, T3, T4, T5, T6 suivants écrits en compréhension :\nT1 = [3 * i for i in range(10)]\nT2 = ['A' for i in range(7)]\nT3 = [randint(1, 6) for k in range(10)]\nT4 = [10 ** i for i in range(5)]\nT5 = [x * x for x in T4]\nListe = [-5, 2, 3, -7, 42, 7]\nT6 = [elt for elt in Liste if elt &gt; 0]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "11_tableaux/exos_tabs.html#exercice-2",
    "href": "11_tableaux/exos_tabs.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nChercher la différence entre les deux commandes python suivantes :\nT1 = [[0] * 5 for i in range(3)]\nT2 = [[0] * 5] * 3\nOn pourra observer les résultats de l’affectation de tableau[0][1]=7 pour les deux tableaux.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "11_tableaux/exos_tabs.html#exercice-3",
    "href": "11_tableaux/exos_tabs.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\n\nCréer un tableau en compréhension contenant toutes les lettres majuscules de l’alphabet.\nCréer en compréhension le tableau suivant : [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\nCréer en compréhension en utilisant le tableau précédent : [10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9, 2]\nCréer en compréhension le tableau donnant les 6 premiers multiples de 16.\nCréer en compréhension le tableau : [1, 0.5, 0.25, 0.125, …, \\(2^{-6}\\)].",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "11_tableaux/exos_tabs.html#exercice-4",
    "href": "11_tableaux/exos_tabs.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\nLe tableau suivant est le relevé de notes d’un élève par matières :\n\n\n\nMathématiques\n16\n18\n14\n17\n20\n\n\n\n\nAlgorithmique\n11\n15\n13\n10\n14\n\n\nProgrammation\n12\n8\n13\n7\n16\n\n\n\nOn le représente par le tableau suivant :\nNotes = [[16, 18, 14, 17, 20],\n         [11, 15, 13, 10, 14],\n         [12, 8, 13, 7, 16]]\nQuelles valeurs vont être affichées en console ?\n&gt;&gt;&gt; Notes[2][2]\n&gt;&gt;&gt; Notes[0][2]\n&gt;&gt;&gt; Notes[0]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "11_tableaux/exos_tabs.html#exercice-5",
    "href": "11_tableaux/exos_tabs.html#exercice-5",
    "title": "Exercices",
    "section": " Exercice 5",
    "text": "Exercice 5\nQuelles sont les valeurs contenues dans le tableau T à la suite de cette série d’instructions ?\nT = [[9, 20, 13, 4],\n     [17, 15, 3, 7],\n     [8, 6, 10, 21]]\nT[2][1] = 22\nT[1][2] = 27\nT[0][3] = T[0][3] + 8\nT[1][3] = T[2][0] + 5",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "11_tableaux/exos_tabs.html#exercice-6",
    "href": "11_tableaux/exos_tabs.html#exercice-6",
    "title": "Exercices",
    "section": " Exercice 6",
    "text": "Exercice 6\nLa matrice suivant donne les notes d’un élève dans différentes matières.\nNotesEleve = [[16, 7, 5, 8, 10],\n              [11, 3, 4, 12, 7],\n              [1, 9, 13, 2, 5]]\n\nÉcrire une fonction qui remplace chaque note de la matrice inférieure à 10 par un 10.\nÉcrire une fonction remplace(Tab) qui prend en paramètre une matrice (tableau de tableaux) contenant des nombres et qui renvoie une matrice dans laquelle les nombres inférieurs à 10 sont remplacés par 10 (il faudra créer dans la fonction une autre matrice qui sera renvoyée car il est bien utile de conserver la première en l’état !).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "11_tableaux/exos_tabs.html#qcm",
    "href": "11_tableaux/exos_tabs.html#qcm",
    "title": "Exercices",
    "section": " QCM",
    "text": "QCM\n\nOn définit : L = [1, 2, 3, 4, 5, 6]. Quelle est la valeur de L[3] ?\n\n[1, 2, 3]\n3\n4\n[4, 5, 6]\n\nOn définit : T = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nLaquelle des expressions suivantes a pour valeur 7 ?\n\nT[3, 1]\nT[3][1]\nT[2, 0]\nT[2][0]\n\nQuelle est l’expression qui a pour valeur le tableau [1, 4, 9, 16, 25, 36] ?\n\n[n*n  for n in range(0, 6)]\n[n*n  for n in range(6)]\n[n*n  for n in range(1, 7)]\n[n*n  for n in range(1, 6)]\n\nSi la variable note est définie par note = [\"do\", \"ré\", \"mi\", \"fa\", \"sol\", \"la\", \"si\"] alors :\n\nl’index de “sol” est 5\nl’index de note est 0\nl’index de “si” est 7\nl’index de “mi” est 2\n\nOn définit une grille G remplie de 0, sous la forme d’un tableau de tableaux, où tous les sous-tableaux ont le même nombre d’éléments.\nG = [[0, 0, 0, ..., 0],\n    [0, 0, 0, ..., 0],\n    [0, 0, 0, ..., 0],\n    ...\n    [0, 0, 0, ..., 0]]\nOn appelle hauteur de la grille le nombre de sous-tableaux contenus dans G et largeur de la grille le nombre d’éléments dans chacune de ces sous-tableaux. Comment peut-on les obtenir ?\n\nhauteur = len(G[0]) et largeur = len(G)\nhauteur = len(G) et largeur = len(G[0])\nhauteur = len(G[0]) et largeur = len(G[1])\nhauteur = len(G[1]) et largeur = len(G[0])\n\nQuelle est la valeur de l’expression [2 * k + 1 for k in range(4)] ?\n\n[1, 3, 5, 7]\n[0, 1, 2, 3]\n[3, 5, 7, 9]\n[1, 2, 3, 4]\n\nDe quelle expression le tableau suivante est-il la valeur : [[0, 0, 0, 0], [1, 1, 1, 1], [2, 2, 2, 2]] ?\n\n[[i] * 4 for i in range(4)]\n[[i] * 3 for i in range(4)]\n[[i] * 4 for i in range(3)]\n[[i] * 3 for i in range(3)]\n\nQuelle est la valeur de l’expression : [(a, b) for a in range(3) for b in range(3) if a &gt; b] ?\n\n[(a, b), (a, b), (a, b), (a, b), (a, b), (a, b), (a, b), (a, b), (a, b)]\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n[(1, 0), (2, 0), (2, 1)]\n[(0 ,0), (0 ,1), (0, 2), (1, 0), (1, 1), (1, 2), (1, 0), (1, 1), (1, 2)]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "10_p-uplets/index.html",
    "href": "10_p-uplets/index.html",
    "title": "Programme",
    "section": "",
    "text": "À partir des types de base se constituent des types construits, qui sont introduits au fur et à mesure qu’ils sont nécessaires.\nIl s’agit de présenter tour à tour les p-uplets (tuples), les enregistrements qui collectent des valeurs de types différents dans des champs nommés et les tableaux qui permettent un accès calculé direct aux éléments. En pratique, on utilise les appellations de Python, qui peuvent être différentes de celles d’autres langages de programmation.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\np-uplets. p-uplets nommés\nÉcrire une fonction renvoyant un p-uplet de valeurs.\n\n\n\nTableau indexé, tableau donné en compréhension\nLire et modifier les éléments d’un tableau grâce à leurs index. Construire un tableau par compréhension. Utiliser des tableaux de tableaux pour représenter des matrices : notation a [i] [j]. Itérer sur les éléments d’un tableau.\nSeuls les tableaux dont les éléments sont du même type sont présentés. Aucune connaissance des tranches (slices) n’est exigible. L’aspect dynamique des tableaux de Python n’est pas évoqué. Python identifie listes et tableaux. Il n’est pas fait référence aux tableaux de la bibliothèque NumPy.\n\n\nDictionnaires par clés et valeurs\nConstruire une entrée de dictionnaire. Itérer sur les éléments d’un dictionnaire.\nIl est possible de présenter les données EXIF d’une image sous la forme d’un enregistrement. En Python, les p-uplets nommés sont implémentés par des dictionnaires. Utiliser les méthodes keys(), values () et items ()."
  },
  {
    "objectID": "09_texte/textes_exos.html",
    "href": "09_texte/textes_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "09_texte/textes_exos.html#exercice-1",
    "href": "09_texte/textes_exos.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\nÉcrire une procédure qui affiche à l’écran la table des 128 caractères ASCII sur 8 lignes de 16 colonnes, avec deux boucles for imbriquées et la fonction chr().",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "09_texte/textes_exos.html#exercice-2",
    "href": "09_texte/textes_exos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nL’encodage consiste à coder un caractère par un nombre. Il ne faut pas confondre cette opération de numérisation avec le chiffrement, ou cryptage, qui consiste aussi à remplacer des caractères par des nombres, mais de telle façon que le décodage ne puisse se faire que par le destinataire du message. La numérisation est cependant le plus souvent la première étape du chiffrement.\nConsidérons le procédé rot-13 qui consiste à remplacer une lettre codée par l’entier \\(n\\) par la lettre codée par l’entier \\(n+13\\) (on se limite aux caractères de la table ASCII).\nComme l’alphabet latin compte 26 lettres, le déchiffrement se fait exactement par la même opération.\nPour trouver que l’image par rot-13 du caractère ‘R’ est ‘E’ :\n\non calcule d’abord le rang alphabétique du caractère :\n&gt;&gt;&gt; ord('R') - ord('A')\n17\npuis on ajoute 13 à ce rang et on prend le reste dans la division euclidienne par 26 :\n&gt;&gt;&gt; (ord('R') - ord('A') + 13) % 26\n4\nenfin on retrouve le rang du caractère associé au rang alphabétique calculé :\n&gt;&gt;&gt; chr(ord('A') + 4)\n'E'\n\nÉcrire une fonction rot13(chaine) qui chiffre ou déchiffre la chaîne (en majuscules ou convertie en majuscules avec chaine.upper()) passée en paramètre, avec l’algorithme rot13.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "09_texte/textes_exos.html#exercice-3",
    "href": "09_texte/textes_exos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\n\nSur une page web qui s’affiche sur notre navigateur on peut lire :\n« En consÃ©quence, l’AssemblÃ©e Nationale reconnaÃ®t et dÃ©clare, en prÃ©sence »\nQuelle peut être la cause des affichages étranges de cette page ?\n\nl’encodage des caractères n’est pas celui attendu par le navigateur\nle texte original est en japonais\nla taille des caractères n’est pas celle attendue par le navigateur\nla connexion à Internet présente des coupures\n\nLe code ASCII permet de représenter en binaire les caractères alphanumériques. Quel est son principal inconvénient ?\n\nIl utilise beaucoup de bits.\nIl ne différencie pas les majuscules des minuscules.\nIl ne représente pas les caractères accentués.\nIl n’est passer compatible avec la plupart des systèmes informatiques",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "09_texte/textes_exos.html#exercice-4",
    "href": "09_texte/textes_exos.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\n\nParmi les caractères ci-dessous, lequel ne fait pas partie du code ASCII ?\n\na\nB\n@\né\n\nLaquelle de ces affirmations concernant le codage UTF-8 des caractères est vraie ?\n\nle codage UTF-8 est sur 7 bits\nle codage UTF-8 est sur 8 bits\nle codage UTF-8 est sur 1 à 4 octets\nle codage UTF-8 est sur 8 octets\n\nQuel est un avantage du codage UTF-8 par rapport au codage ASCII ?\n\nil permet de coder un caractère sur un octet au lieu de deux\nil permet de coder les majuscules\nil permet de coder tous les caractères\nil permet de coder différentes polices de caractères",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "09_texte/textes_exos.html#exercice-5",
    "href": "09_texte/textes_exos.html#exercice-5",
    "title": "Exercices",
    "section": " Exercice 5",
    "text": "Exercice 5\nEn Python, pour saisir directement un caractère à partir de son point de code Unicode, on peut utiliser des séquences d’échappement spéciales : ‘\\uxxxx’ si le point de code peut s’écrire avec 4 chiffres hexadécimaux, ou ‘\\Uxxxxxxxx’ s’il faut plus de quatre chiffres, en remplissant par des 0 à gauche les positions vides sur les huit possibles.\n\nTester l’instruction ci-dessous dans une console Python :\nprint(\"\\U0001f600\")\nÉcrire un code Python qui affiche tous les caractères dont le point de code est compris entre U+1F600 et U+1F64F sur des lignes de 16 caractères par colonne.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "09_texte/index.html",
    "href": "09_texte/index.html",
    "title": "Programme",
    "section": "",
    "text": "Toute machine informatique manipule une représentation des données dont l’unité minimale est le bit 0/1, ce qui permet d’unifier logique et calcul. Les données de base sont représentées selon un codage dépendant de leur nature : entiers, flottants, caractères et chaînes de caractères. Le codage conditionne la taille des différentes valeurs en mémoire.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nÉcriture d’un entier positif dans une base b ⩾ 2\nPasser de la représentation d’une base dans une autre.\nLes bases 2, 10 et 16 sont privilégiées.\n\n\nReprésentation binaire d’un entier relatif\nÉvaluer le nombre de bits nécessaires à l’écriture en base 2 d’un entier, de la somme ou du produit de deux nombres entiers. Utiliser le complément à 2.\nIl s’agit de décrire les tailles courantes des entiers (8, 16, 32 ou 64 bits). Il est possible d’évoquer la représentation des entiers de taille arbitraire de Python.\n\n\nReprésentation approximative des nombres réels : notion de nombre flottant\nCalculer sur quelques exemples la représentation de nombres réels : 0.1, 0.25 ou 1/3.\n0.2 + 0.1 n’est pas égal à 0.3. Il faut éviter de tester l’égalité de deux flottants. Aucune connaissance précise de la norme IEEE-754 n’est exigible.\n\n\nValeurs booléennes : 0, 1. Opérateurs booléens : and, or, not. Expressions booléennes\nDresser la table d’une expression booléenne.\nLe ou exclusif (xor) est évoqué. Quelques applications directes comme l’addition binaire sont présentées. L’attention des élèves est attirée sur le caractère séquentiel de certains opérateurs booléens.\n\n\nReprésentation d’un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode\nIdentifier l’intérêt des différents systèmes d’encodage. Convertir un fichier texte dans différents formats d’encodage.\nAucune connaissance précise des normes d’encodage n’est exigible."
  },
  {
    "objectID": "09_texte/index.html#programme",
    "href": "09_texte/index.html#programme",
    "title": "Programme",
    "section": "",
    "text": "Toute machine informatique manipule une représentation des données dont l’unité minimale est le bit 0/1, ce qui permet d’unifier logique et calcul. Les données de base sont représentées selon un codage dépendant de leur nature : entiers, flottants, caractères et chaînes de caractères. Le codage conditionne la taille des différentes valeurs en mémoire.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nÉcriture d’un entier positif dans une base b ⩾ 2\nPasser de la représentation d’une base dans une autre.\nLes bases 2, 10 et 16 sont privilégiées.\n\n\nReprésentation binaire d’un entier relatif\nÉvaluer le nombre de bits nécessaires à l’écriture en base 2 d’un entier, de la somme ou du produit de deux nombres entiers. Utiliser le complément à 2.\nIl s’agit de décrire les tailles courantes des entiers (8, 16, 32 ou 64 bits). Il est possible d’évoquer la représentation des entiers de taille arbitraire de Python.\n\n\nReprésentation approximative des nombres réels : notion de nombre flottant\nCalculer sur quelques exemples la représentation de nombres réels : 0.1, 0.25 ou 1/3.\n0.2 + 0.1 n’est pas égal à 0.3. Il faut éviter de tester l’égalité de deux flottants. Aucune connaissance précise de la norme IEEE-754 n’est exigible.\n\n\nValeurs booléennes : 0, 1. Opérateurs booléens : and, or, not. Expressions booléennes\nDresser la table d’une expression booléenne.\nLe ou exclusif (xor) est évoqué. Quelques applications directes comme l’addition binaire sont présentées. L’attention des élèves est attirée sur le caractère séquentiel de certains opérateurs booléens.\n\n\nReprésentation d’un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode\nIdentifier l’intérêt des différents systèmes d’encodage. Convertir un fichier texte dans différents formats d’encodage.\nAucune connaissance précise des normes d’encodage n’est exigible."
  },
  {
    "objectID": "08_booleens/booleens_exos.html",
    "href": "08_booleens/booleens_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_exos.html#exercice-1",
    "href": "08_booleens/booleens_exos.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\n\nConstruire la table de vérité de l’expression : a OU (NON b)\nConstruire la table de vérité de l’expression : NON a ET (b OU c)\nConstruire la table de vérité de l’expression : (a ET NON b) OU (NON a ET b)\nConstruire la table de vérité de l’expression : (a OU b) ET (a OU c)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_exos.html#exercice-2",
    "href": "08_booleens/booleens_exos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nDonner la valeur des expressions booléennes suivantes :\n&gt;&gt;&gt; (1 &gt; 2) and (3 &lt; 5)\n&gt;&gt;&gt; ((4 - 7) &gt;= 2) or (2 != 1 + 1)\n&gt;&gt;&gt; a = 223\n&gt;&gt;&gt; b = 455\n&gt;&gt;&gt; a != (b // 2)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_exos.html#exercice-3",
    "href": "08_booleens/booleens_exos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\nOn considère la table de vérité de l’expression booléenne Z ci-dessous :\n\n\n\nx\nZ(x)\n\n\n\n\n0\n0\n\n\n1\n0\n\n\n\nExprimer Z à l’aide des fonctions booléennes ET, OU, NON.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_exos.html#exercice-4",
    "href": "08_booleens/booleens_exos.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\nOn considère la table de vérité de l’expression U ci-dessous :\n\n\n\nx\nU(x)\n\n\n\n\n0\n1\n\n\n1\n1\n\n\n\nExprimer U à l’aide des fonctions booléennes ET, OU, NON.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_exos.html#exercice-5",
    "href": "08_booleens/booleens_exos.html#exercice-5",
    "title": "Exercices",
    "section": " Exercice 5",
    "text": "Exercice 5\nOn considère l’extrait de code suivant :\nwhile (a &lt; 20) or (b &gt; 50):\n    ......\n    ......\nQuelles conditions permettent de mettre fin à cette boucle ?\n\nla boucle prend fin lorsque \\(a &lt; 20\\) ou \\(b &gt; 50\\)\nla boucle prend fin lorsque \\(a &lt; 20\\) et \\(b &gt; 50\\)\nla boucle prend fin lorsque \\(a \\geqslant 20\\) ou \\(b \\leqslant 50\\)\nla boucle prend fin lorsque \\(a \\geqslant 20\\) et \\(b \\leqslant 50\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_exos.html#exercice-6",
    "href": "08_booleens/booleens_exos.html#exercice-6",
    "title": "Exercices",
    "section": " Exercice 6",
    "text": "Exercice 6\nSi A et B sont des variables booléennes, laquelle de ces expressions booléennes est équivalente à (not A) or B ?\n\n(A and B) or (not A and B)\n(A and B) or (not A and B) or (not A and not B)\n(not A and B) or (not A and not B)\n(A and B) or (not A and not B)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_exos.html#exercice-7",
    "href": "08_booleens/booleens_exos.html#exercice-7",
    "title": "Exercices",
    "section": " Exercice 7",
    "text": "Exercice 7\nQuelle table de vérité correspond à l’expression (NON(A) OU B) ?\nRemarque : dans les tables proposées, la première colonne donne les valeurs de A, la première ligne les valeurs de B.\n\nTable 1 :\n\n\n\nA\n0\n1\n\n\n\n\n0\n0\n1\n\n\n1\n1\n1\n\n\n\nTable 2 :\n\n\n\nA\n0\n1\n\n\n\n\n0\n1\n1\n\n\n1\n0\n0\n\n\n\nTable 3 :\n\n\n\nA\n0\n1\n\n\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n\nTable 4 :\n\n\n\nA\n0\n1\n\n\n\n\n0\n1\n0\n\n\n1\n1\n0",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_exos.html#exercice-8",
    "href": "08_booleens/booleens_exos.html#exercice-8",
    "title": "Exercices",
    "section": " Exercice 8",
    "text": "Exercice 8\nParmi les quatre expressions suivantes, laquelle s’évalue en True ?\n\nFalse and (True and False)\nFalse or (True and False)\nTrue and (True and False)\nTrue or (True and False)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_exos.html#exercice-9",
    "href": "08_booleens/booleens_exos.html#exercice-9",
    "title": "Exercices",
    "section": " Exercice 9",
    "text": "Exercice 9\nÀ quelle affectation sont équivalentes les instructions suivantes, où a, b sont des variables entières et c une variable booléenne ?\nif a==b:\n    c = True\nelif a &gt; b+10:\n    c = True\nelse:\n    c = False\n\nc = (a==b) or (a &gt; b+10)\nc = (a==b) and (a &gt; b+10)\nc = not(a==b)\nc = not(a &gt; b+10)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "08_booleens/booleens_cours.html",
    "href": "08_booleens/booleens_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Nous avons déjà rencontré les booléens dans la première séquence.\nEn programmation informatique, un booléen est un type de variable à deux états (généralement notés vrai et faux), destiné à représenter les valeurs de vérité de la logique et l’algèbre booléenne. Il est nommé ainsi d’après George Boole (1815-1864), fondateur dans le milieu du XIXe siècle de l’algèbre portant son nom.\nNous avons vu qu’en Python, les deux valeurs booléennes sont notées True et False.\nDe manière équivalents, on adopte souvent une notation numérique en associant 1 à True et 0 à False."
  },
  {
    "objectID": "08_booleens/booleens_cours.html#opérateurs-booléens-de-base",
    "href": "08_booleens/booleens_cours.html#opérateurs-booléens-de-base",
    "title": "Cours",
    "section": "1. Opérateurs booléens de base",
    "text": "1. Opérateurs booléens de base\nDans le cours sur les bases de Python, nous avons déjà vu les opérateurs or, and et not.\n\nOpérateur OU\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(a\\) et \\(b\\) deux expressions :\n\\[a\\textrm{ OU }b\\textrm{ est vrai }\\iff a\\textrm{ est vrai ou }b\\textrm{ est vrai}\\]\n\n\nTable de vérité de l’opérateur OU :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(a\\) OU \\(b\\)\n\n\n\n\n1\n1\n1\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n\n\n\n\n\n\n\nRemarque\n\n\n\nEn logique l’opérateur OU est inclusif : cela signifie que \\(a\\) OU \\(b\\) est vrai aussi lorsque \\(a\\) est vrai et \\(b\\) est vrai. Dans la langue courant, le mot ou est le plus souvent exclusif : dans un menu, par exemple “fromage ou dessert” ne permet pas de prendre les deux.\n\n\n\n\nOpérateur ET\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(a\\) et \\(b\\) deux expressions :\n\\[a\\textrm{ ET }b\\textrm{ est vrai }\\iff a\\textrm{ est vrai et }b\\textrm{ est vrai}\\]\n\n\nTable de vérité de l’opérateur ET :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(a\\) ET \\(b\\)\n\n\n\n\n1\n1\n1\n\n\n1\n0\n0\n\n\n0\n1\n0\n\n\n0\n0\n0\n\n\n\n\n\nOpérateur NON\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(a\\) une expression :\n\\[(\\textrm{NON }a)\\textrm{ est vrai }\\iff a\\textrm{ est faux}\\]\n\n\nTable de vérité de l’opérateur NON :\n\n\n\n\\(a\\)\nNON \\(a\\)\n\n\n\n\n1\n0\n\n\n0\n1"
  },
  {
    "objectID": "08_booleens/booleens_cours.html#expressions-booléennes",
    "href": "08_booleens/booleens_cours.html#expressions-booléennes",
    "title": "Cours",
    "section": "2. Expressions booléennes",
    "text": "2. Expressions booléennes\nLes opérateurs de base peuvent être combinés pour formuler des expressions booléennes plus complexes. Pour éviter des problèmes d’interprétation, il est préférable d’utiliser des parenthèses pour marquer les priorités.\n\n\n\n\n\n\nExercice\n\n\n\nRecopier et compléter la table de vérité ci-dessous :\n\n\n\n\n\n\n\n\n\n\n\n\n\\(a\\)\n\\(b\\)\nNON \\(a\\)\nNON \\(b\\)\n(NON \\(a\\)) ET (NON \\(b\\))\nNON((NON \\(a\\)) ET (NON \\(b\\)))\n\\(a\\) OU \\(b\\)\n\n\n\n\n1\n1\n\n\n\n\n\n\n\n1\n0\n\n\n\n\n\n\n\n0\n1\n\n\n\n\n\n\n\n0\n0\n\n\n\n\n\n\n\n\nQue peut-on constater ?"
  },
  {
    "objectID": "08_booleens/booleens_cours.html#le-ou-exclusif",
    "href": "08_booleens/booleens_cours.html#le-ou-exclusif",
    "title": "Cours",
    "section": "3. Le ou exclusif",
    "text": "3. Le ou exclusif\nLe OU logique étant inclusif, on définit un opérateur spécifique pour le ou exclusif, appelé opérateur XOR.\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(a\\) et \\(b\\) deux expressions :\n\\[a\\textrm{ XOR }b\\textrm{ est vrai }\\iff (a\\textrm{ est vrai et }b\\textrm{ est faux})\\textrm{ ou }(a\\textrm{ est faux et }b\\textrm{ est vrai})\\]\n\n\nTable de vérité de l’opérateur XOR :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(a\\) XOR \\(b\\)\n\n\n\n\n1\n1\n0\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n\nEn Python, l’opérateur xor n’existe pas. Le ou exclusif est noté ^.\n&gt;&gt;&gt; True ^ False\nTrue"
  },
  {
    "objectID": "08_booleens/booleens_cours.html#laddition-binaire-en-mode-booléen",
    "href": "08_booleens/booleens_cours.html#laddition-binaire-en-mode-booléen",
    "title": "Cours",
    "section": "4. L’addition binaire en mode booléen",
    "text": "4. L’addition binaire en mode booléen\nLorsque nous posons l’addition de deux entiers écrits en base 2, nous avons besoin d’additionner des groupes de 3 bits (un pour chaque nombre et un pour la retenue).\nVoyons ce que donne l’addition de trois bits :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(a+b+c\\)\n\n\n\n\n0\n0\n0\n0\n\n\n1\n0\n0\n1\n\n\n0\n1\n0\n1\n\n\n0\n0\n1\n1\n\n\n1\n1\n0\n10\n\n\n1\n0\n1\n10\n\n\n0\n1\n1\n10\n\n\n1\n1\n1\n11\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nEn assimilant 0 à False et 1 à True écrire une fonction add_trois_bits(a, b, c) qui retourne la somme \\(a+b+c\\) en utilisant uniquement les opérateurs ET, OU et NON. On retournera la somme sous la forme d’une chaîne de deux caractères (\"01\" par exemple).\ndef add_3_bits(a, b, c) :\n    unite = int(...)\n    deuzaine = int(...)\n    return str(deuzaine)+str(unite)\n\nassert add_3_bits(0,0,0)==\"00\"\nassert add_3_bits(1,0,0)==\"01\"\nassert add_3_bits(0,1,0)==\"01\"\nassert add_3_bits(0,0,1)==\"01\"\nassert add_3_bits(1,1,0)==\"10\"\nassert add_3_bits(1,0,1)==\"10\"\nassert add_3_bits(0,1,1)==\"10\"\nassert add_3_bits(1,1,1)==\"11\"\nprint(\"C'est parfait !\")"
  },
  {
    "objectID": "07_flottants/mini_tp_nombres.html",
    "href": "07_flottants/mini_tp_nombres.html",
    "title": "TP : Bases 2, 10 et 16 en Python",
    "section": "",
    "text": "Ce T.P. est disponible dans Capytale.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "TP : Bases 2, 10 et 16 en Python"
    ]
  },
  {
    "objectID": "07_flottants/flottants_exos.html",
    "href": "07_flottants/flottants_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "07_flottants/flottants_exos.html#exercice-1",
    "href": "07_flottants/flottants_exos.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\nDéterminer l’écriture en base 10 des nombres binaires suivants :\n\n\\(11,01_2\\)\n\\(10,11_2\\)\n\\(1001,101_2\\)\n\\(101,0111_2\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "07_flottants/flottants_exos.html#exercice-2",
    "href": "07_flottants/flottants_exos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nDéterminer l’écriture binaire des nombres décimaux suivants :\n\n\\(7,125_{10}\\)\n\\(10,75_{10}\\)\n\\(3,375_{10}\\)\n\\(6,1875_{10}\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "07_flottants/flottants_exos.html#exercice-3",
    "href": "07_flottants/flottants_exos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\nDéterminer la représentation binaire des nombres décimaux suivants selon la norme IEEE-754 sur 32 bits.\n\n\\(0,9218_{10}\\)\n\\(0,002125_{10}\\)\n\\(45,218_{10}\\).\n\\(126,725_{10}\\).\n\\(0,1_{10}\\).\n\\(\\frac{1}{3}_{10}\\).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "07_flottants/flottants_exos.html#exercice-4",
    "href": "07_flottants/flottants_exos.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\nDans la console Python, taper :\n&gt;&gt;&gt; 0.1 + 0.2\nQuel résultat est affiché ? Expliquer !",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "06_relatif/relatifs_exos.html",
    "href": "06_relatif/relatifs_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "06_relatif/relatifs_exos.html#exercice-1",
    "href": "06_relatif/relatifs_exos.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\n\nÉcrire les entiers relatifs suivants en complément à 2, sur 8 bits :\n\n\\(-69\\)\n\\(124\\)\n\\(-125\\)\n\\(-26\\)\n\nConvertir en base 10 les entiers relatifs suivants exprimés en complément à 2, sur 8 bits.\n\n\\(0000\\; 1101\\)\n\\(1000\\;1011\\)\n\\(1111\\;1111\\)\n\\(1001\\;1000\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "06_relatif/relatifs_exos.html#exercice-2",
    "href": "06_relatif/relatifs_exos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nPoser et effectuer la soustraction suivante en binaire sur un octet : 96−84.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "06_relatif/relatifs_exos.html#exercice-3",
    "href": "06_relatif/relatifs_exos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\nDans cet exercice, on code les entiers relatifs sur 2 octets.\n\nDéterminer la représentation de l’entier \\(-47\\).\nCombien de nombres strictement positifs peut-on coder ? Préciser le plus petit et le plus grand.\nCombien de nombres strictement négatifs peut-on coder ? Préciser le plus petit et le plus grand.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "06_relatif/index.html",
    "href": "06_relatif/index.html",
    "title": "Programme",
    "section": "",
    "text": "Toute machine informatique manipule une représentation des données dont l’unité minimale est le bit 0/1, ce qui permet d’unifier logique et calcul. Les données de base sont représentées selon un codage dépendant de leur nature : entiers, flottants, caractères et chaînes de caractères. Le codage conditionne la taille des différentes valeurs en mémoire.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nÉcriture d’un entier positif dans une base b ⩾ 2\nPasser de la représentation d’une base dans une autre.\nLes bases 2, 10 et 16 sont privilégiées.\n\n\nReprésentation binaire d’un entier relatif\nÉvaluer le nombre de bits nécessaires à l’écriture en base 2 d’un entier, de la somme ou du produit de deux nombres entiers. Utiliser le complément à 2.\nIl s’agit de décrire les tailles courantes des entiers (8, 16, 32 ou 64 bits). Il est possible d’évoquer la représentation des entiers de taille arbitraire de Python.\n\n\nReprésentation approximative des nombres réels : notion de nombre flottant\nCalculer sur quelques exemples la représentation de nombres réels : 0.1, 0.25 ou 1/3.\n0.2 + 0.1 n’est pas égal à 0.3. Il faut éviter de tester l’égalité de deux flottants. Aucune connaissance précise de la norme IEEE-754 n’est exigible.\n\n\nValeurs booléennes : 0, 1. Opérateurs booléens : and, or, not. Expressions booléennes\nDresser la table d’une expression booléenne.\nLe ou exclusif (xor) est évoqué. Quelques applications directes comme l’addition binaire sont présentées. L’attention des élèves est attirée sur le caractère séquentiel de certains opérateurs booléens.\n\n\nReprésentation d’un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode\nIdentifier l’intérêt des différents systèmes d’encodage. Convertir un fichier texte dans différents formats d’encodage.\nAucune connaissance précise des normes d’encodage n’est exigible."
  },
  {
    "objectID": "05_base/base_exos.html",
    "href": "05_base/base_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "05_base/base_exos.html#exercice-1",
    "href": "05_base/base_exos.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\nConvertir en base 2 :\n\n\\(23_{10}\\)\n\\(2\\;025_{10}\\)\n\\(40\\;500_{10}\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "05_base/base_exos.html#exercice-2",
    "href": "05_base/base_exos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nConvertir en base 10 :\n\n\\(111_2\\)\n\\(11\\;0001_2\\)\n\\(1101\\;0101_2\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "05_base/base_exos.html#exercice-3",
    "href": "05_base/base_exos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\nConvertir en base 10 :\n\n\\(23_{16}\\)\n\\(E85_{16}\\)\n\\(FAB15_{16}\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "05_base/base_exos.html#exercice-4",
    "href": "05_base/base_exos.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\nConvertir en base 16 :\n\n\\(16_{10}\\)\n\\(2\\;022_{10}\\).\n\\(65\\;724_{10}\\).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "05_base/base_exos.html#exercice-5",
    "href": "05_base/base_exos.html#exercice-5",
    "title": "Exercices",
    "section": " Exercice 5",
    "text": "Exercice 5\nConvertir en base 16 les nombres binaires suivants :\n\n\\(1\\;1011_2\\)\n\\(1100\\;1010\\;0001\\;1100_2\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "05_base/base_exos.html#exercice-6",
    "href": "05_base/base_exos.html#exercice-6",
    "title": "Exercices",
    "section": " Exercice 6",
    "text": "Exercice 6\nPoser et effectuer les additions suivantes :\n\n\\(111_2+1011_2\\)\n\\(1011\\;0111_2+111\\;0100_2\\)\n\\(1101_2+1\\;1001_2\\)\n\\(1\\;0111_2+11\\;0110_2+11\\;1101_2\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "05_base/base_exos.html#exercice-7",
    "href": "05_base/base_exos.html#exercice-7",
    "title": "Exercices",
    "section": " Exercice 7",
    "text": "Exercice 7\nDans un certain langage de programmation, les entiers naturels sont codés sur un octet. Parmi les additions suivantes, lesquelles vont provoquer un dépassement de capacité (overflow error) ?\n\n\\(1111\\;1011 + 1001\\;1111\\)\n\\(1001\\;1011 + 0111\\;1011\\)\n\\(0011\\;1011 + 1001\\;1001\\)\n\\(1010\\;1011 + 0001\\;0100\\)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "05_base/base_exos.html#exercice-8",
    "href": "05_base/base_exos.html#exercice-8",
    "title": "Exercices",
    "section": " Exercice 8",
    "text": "Exercice 8\nEn procédant comme pour les nombres écrits en base 10, poser la multiplication suivante :\n\\[1\\;1101_2\\times 111_2\\]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Exercices"
    ]
  },
  {
    "objectID": "04_langages/langages.html",
    "href": "04_langages/langages.html",
    "title": "Exposé / Recherches - Diversité et unité des langages de programmation",
    "section": "",
    "text": "Il existe de très nombreux langages de programmation différents. Chaque langage a ses particularités propres, mais certaines ressemblances peuvent également être observées.\nVoici un arbre généalogique des principaux langages, tiré des documents d’accompagnement du programme de première :",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exposé / Recherches - Diversité et unité des langages de programmation"
    ]
  },
  {
    "objectID": "04_langages/langages.html#popularité-des-principaux-langages",
    "href": "04_langages/langages.html#popularité-des-principaux-langages",
    "title": "Exposé / Recherches - Diversité et unité des langages de programmation",
    "section": "1. Popularité des principaux langages",
    "text": "1. Popularité des principaux langages\nL’entreprise néerlandaise TIOBE propose un indice de popularité des principaux langages de programmation. Voici comment cet indice est présenté sur son site :\n\n\n\n\n\n\nCitation\n\n\n\nL’indice TIOBE Programming Community est un indicateur de la popularité des langages de programmation. L’indice est mis à jour une fois par mois. Les évaluations sont basées sur le nombre d’ingénieurs qualifiés dans l’utilisation de chaque langage dans le monde entier, de cours et de fournisseurs tiers. Les moteurs de recherche populaires tels que Google, Bing, Yahoo!, Wikipedia, Amazon, YouTube et Baidu sont utilisés pour calculer les évaluations. Il est important de noter que l’indice TIOBE ne concerne pas le meilleur langage de programmation ou le langage dans lequel la plupart des lignes de code ont été écrites.\nL’indice peut être utilisé pour vérifier si vos compétences en programmation sont toujours à jour ou pour prendre une décision stratégique sur le langage de programmation à adopter lorsque vous commencez à construire un nouveau système logiciel. La définition de l’indice TIOBE peut être trouvée ici.\n\n\nVoici le classement des dix premiers langages selon l’indice TIOBE en septembre 2023 et le graphique de son évolution :",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exposé / Recherches - Diversité et unité des langages de programmation"
    ]
  },
  {
    "objectID": "04_langages/langages.html#différentes-implémentations-dun-même-algorithme",
    "href": "04_langages/langages.html#différentes-implémentations-dun-même-algorithme",
    "title": "Exposé / Recherches - Diversité et unité des langages de programmation",
    "section": "2. Différentes implémentations d’un même algorithme",
    "text": "2. Différentes implémentations d’un même algorithme\nPour découvrir et comparer quelques langages de programmation, nous allons nous intéresser à l’algorithme suivant dont l’objet est de tester si un nombre entier positif \\(n\\) donné en argument est premier ou non. On procède pour cela en testant la divisibilité par les entiers inférieurs ou égaux à \\(\\sqrt{n}\\). Si \\(n\\) ne possède aucun diviseur (autre que 1) inférieur ou égal à \\(\\sqrt{n}\\), alors \\(n\\) est premier.\nL’algorithme représenté ci dessous (on traite directement le cas \\(n=2\\) et on élimine tous les multiples de 2):\n\n\n\n\n\n\nAlgorithme en pseudo-code\n\n\n\nFonction is_prime(n)\n    Début\n        Si n = 2, Alors\n            Retourne Vrai\n        FinSi\n        Si n &lt; 2 ou 2 divise n, Alors\n            Retourne Faux\n        FinSi\n        Pour k variant de 3 à la partie entière de racine_carrée(n), avec un pas de 2, Faire\n            Si k divise n, alors\n                Retourne Faux\n            FinSi\n        FinPour\n        Retourne Vrai\n    Fin\n\n\nVoici maintenant sa traduction dans quelques langages de programmation. À chaque fois, nous avons essayé de suivre au plus près la structure de programmation de l’algorithme en pseudo-code. Dans chaque exemple, une fonction est définie, puis elle est exécutée pour vérifier que le nombre 37 est premier. Le résultat est affiché à l’écran.\n\nPython\n\n\nLangage Python\n\nfrom math import sqrt\n\ndef is_prime(n):\n    if n == 2:\n        return True\n    if n &lt; 2 or n % 2 == 0:\n        return False\n    for k in range(3, int(sqrt(n))+1, 2):\n        if n % k == 0:\n            return False\n    return True\n\nprint(is_prime(37)\n\n\n\nC, C++\nDans le script ci-dessous, écrit en C, on retrouve le même algorithme. Le code fonctionne en C ou en C++ (on peut considérer que C est un sous-ensemble de C++). Cliquer ici pour tester ce code en ligne :\n\n\nLangage C\n\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;math.h&gt;\n\nbool is_prime(unsigned int n)\n{\n    unsigned int k;\n    if (n == 2) return true;\n    if (n &lt; 2 || n % 2 == 0) return false;\n    for (k = 3; k &lt;= sqrt(n) + 1; k += 2)\n        if (n % k == 0) return false;\n    return true;\n}\n\nint main()\n{\n    unsigned int number = 91;\n    bool result = is_prime(number);\n\n    if (result)\n        printf(\"%u est un nombre premier.\\n\", number);\n    else\n        printf(\"%u n'est pas un nombre premier.\\n\", number);\n\n    return 0;\n}\n\n\n\n\n\nC#\nLa même chose en C# Cliquer ici pour tester ce code en ligne :\n\n\nLangage C#\n\nusing System;\n\nclass Program\n{\n    static bool is_Prime(int n)\n    {\n        if (n == 2) return true;\n        if (n &lt; 2 || n % 2 == 0) return false;\n        for (int k = 3; k &lt;= Math.Sqrt(n) + 1; k += 2)\n            if (n % k == 0) return false;\n        return true;\n    }\n\n    static void Main()\n    {\n        int number = 91;\n        bool result = is_Prime(number);\n\n        if (result)\n            Console.WriteLine($\"{number} est un nombre premier.\");\n        else\n            Console.WriteLine($\"{number} n'est pas un nombre premier.\");\n\n        // Attendre une saisie pour que la console ne se ferme pas immédiatement\n        Console.ReadLine();\n    }\n}\n\n\n\n\n\nJava\nPassons à Java Cliquer ici pour tester ce code en ligne :\n\n\nLangage Java\n\nclass PrimeTest {\n\n    static boolean isPrime(int n) {\n        if (n == 2) return true;\n        if (n &lt; 2 || n % 2 == 0) return false;\n        for (int k = 3; k &lt;= Math.sqrt(n) + 1; k += 2)\n            if (n % k == 0) return false;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int number = 37;\n        boolean result = isPrime(number);\n\n        if (result)\n            System.out.println(number + \" est un nombre premier.\");\n        else\n            System.out.println(number + \" n'est pas un nombre premier.\");\n    }\n}\n\n\n\n\n\nJavascript\nVoici maintenant un peu de Javascript Cliquer ici pour tester ce code en ligne :\n\n\nLangage Javascript\n\nfunction is_prime(n) {\n  if (n == 2) {\n    return true;\n  } else if ((n &lt; 2) || (n % 2 == 0)) {\n    return false;\n  } else {\n    for (var k = 3; k &lt;= Math.sqrt(n); k += 2) {\n      if (n % k == 0)\n        return false;\n    }\n    return true;\n  }\n}\n\nconsole.log(is_prime(37))\n\n\n\n\n\nBasic\nEn Basic (version visual Basic) Cliquer ici pour tester ce code en ligne :\n\n\nLangage Visual Basic\n\nModule MainModule\n\n    Function is_prime(n As Integer) As Boolean\n        If n = 2 Then\n            is_prime = True\n        ElseIf n &lt; 2 Or n Mod 2 = 0 Then\n            is_prime = False\n        Else\n            is_prime = True\n            For k = 3 To CInt(Math.Sqrt(n)) + 1 Step 2\n                If n Mod k = 0 Then\n                    is_prime = False\n                    Exit For\n                End If\n            Next\n        End If\n    End Function\n\n    Sub Main()\n        Dim number As Integer = 37\n        Dim result As Boolean = is_prime(number)\n\n        If result Then\n            Console.WriteLine(number & \" est un nombre premier.\")\n        Else\n            Console.WriteLine(number & \" n'est pas un nombre premier.\")\n        End If\n\n        ' Attendre une saisie pour que la console ne se ferme pas immédiatement\n        Console.ReadLine()\n    End Sub\n\nEnd Module\n\n\n\n\n\nFortran\nEn Fortran Cliquer ici pour tester ce code en ligne :\n\n\nLangage Fortran\n\nPROGRAM Main\n  IMPLICIT NONE\n\n  LOGICAL :: result\n  INTEGER :: number\n\n  number = 91\n  result = is_prime(number)\n\n  IF (result) THEN\n    WRITE(*, *) number, \" est un nombre premier.\"\n  ELSE\n    WRITE(*, *) number, \" n'est pas un nombre premier.\"\n  END IF\n\nCONTAINS\n\n  FUNCTION is_prime(n)\n    LOGICAL :: is_prime\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: k\n\n    IF (n == 2) THEN\n      is_prime = .TRUE.\n    ELSE IF (n &lt; 2 .OR. MOD(n, 2) == 0) THEN\n      is_prime = .FALSE.\n    ELSE\n      is_prime = .TRUE.\n      DO k = 3, INT(SQRT(REAL(n))) + 1, 2\n        IF (MOD(n, k) == 0) THEN\n          is_prime = .FALSE.\n          EXIT\n        END IF\n      END DO\n    END IF\n\n  END FUNCTION is_prime\n\nEND PROGRAM Main\n\n\n\n\n\nPascal\nEn Pascal Cliquer ici pour tester ce code en ligne :\n\n\nLangage Pascal\n\nprogram PrimeTest;\n\nfunction is_prime(n: integer): boolean;\nvar\n  k: integer;\nbegin\n  if n = 2 then\n    is_prime := true\n  else if (n &lt; 2) or (n mod 2 = 0) then\n    is_prime := false\n  else begin\n    is_prime := true;\n    k := 3;\n    while k &lt;= trunc(sqrt(n)) + 1 do begin\n      if n mod k = 0 then begin\n        is_prime := false;\n        exit;\n      end;\n      k := k + 2;\n    end;\n  end;\nend;\n\nvar\n  number: integer;\n  result: boolean;\nbegin\n  number := 91;\n  result := is_prime(number);\n\n  if result then\n    writeln(number, ' est un nombre premier.')\n  else\n    writeln(number, ' n''est pas un nombre premier.');\n\n  readln;\nend.\n\n\n\n\n\nOCaml\nPour finir, en OCaml Cliquer ici pour tester ce code en ligne :\n\n\nLangage OCaml\n\nlet is_prime n =\n  if n = 2 then true\n  else if n &lt; 2 || n mod 2 = 0 then false\n  else begin\n    let reponse = ref true in\n    for k = 3 to 1 + int_of_float (sqrt (float_of_int n)) do\n      if n mod k = 0 then\n        reponse := false\n    done;\n    !reponse\n  end\n;;\n\nlet () =\n  let number = 91 in\n  let result = is_prime number in\n  if result then\n    Printf.printf \"%d est un nombre premier.\\n\" number\n  else\n    Printf.printf \"%d n'est pas un nombre premier.\\n\" number\n;;\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nNotre langage d’étude est Python. Repérer, dans les dix programmes ci-dessous des points communs et des différences. Vous présenterez vos résultats dans un tableau et vous effectuerez ce travail en présentant brièvement chacun des langages cités (date de création, domaine d’application, …).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exposé / Recherches - Diversité et unité des langages de programmation"
    ]
  },
  {
    "objectID": "04_langages/langages.html#compléments",
    "href": "04_langages/langages.html#compléments",
    "title": "Exposé / Recherches - Diversité et unité des langages de programmation",
    "section": "Compléments",
    "text": "Compléments\n\nLe site RosettaCode.org propose un très grand nombre d’algorithmes traduits dans un très grand nombre de langages. Les programmes présentés ici en sont inspirés, avec quelques modifications.\nOn y trouve notamment le fameux programme “Hello, World!” dans de très nombreux langages : Hello, World!.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exposé / Recherches - Diversité et unité des langages de programmation"
    ]
  },
  {
    "objectID": "03_spec/spec_exos.html",
    "href": "03_spec/spec_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.\nFiche d’exercices sur la spécification et la mise au point des fonctions.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "03_spec/spec_exos.html#exercice-1",
    "href": "03_spec/spec_exos.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\n\nDans la console Python, importer toutes les fonctions du module statistics qui, comme son nom l’indique, permet de réaliser quelques calculs statistiques !\nTaper ensuite les commandes permettant d’afficher les spécifications des fonctions mean (calcul de la moyenne), median (calcul de la médiane) et quantiles (calcul des quantiles).\nRecopier ces spécifications.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "03_spec/spec_exos.html#exercice-2",
    "href": "03_spec/spec_exos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nLa fonction punition() affiche une phrase de punition un certain nombre de fois donné en paramètre.\ndef punition(nombrecopies) : \n    for compteur in range (1,nombrecopies+1,1) :\n        print(\"Je ne dois pas bavarder en classe.\")\n\nParmi les appels suivants, lesquels vont provoquer une erreur ?\n\npunition(\"Marcello\")\npunition(200)\npunition( )\npunition(3.5)\npunition(-10)\n\nAjouter dans la fonction un assert de précondition avec une phrase d’erreur et le tester.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "03_spec/spec_exos.html#exercice-3",
    "href": "03_spec/spec_exos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\nL’Indice de Masse Corporelle se calcule par la formule \\(IMC = \\frac{masse}{taille^2}\\), où la masse est en kilogrammes et la taille en mètres. Un IMC est considéré comme normal s’il est compris entre 18,5 et 25. En dessous de 18,5, la personne est en sous-poids et au-dessus de 25 elle est en sur-poids.\n\nÉcrire une fonction d’en-tête imc(m, t) qui renvoie la classification de l’IMC correspondant à une masse de m kilogrammes et une taille de t mètres : classe 0 pour sous-poids, 1 pour normal et 2 pour surpoids.\nDétailler précisément la spécification de cette fonction et proposer des préconditions pertinentes à tester.\nÉcrire une fonction test_IMC() mettant en oeuvre un jeu de tests unitaires pour la fonction imc(m, t).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "03_spec/spec_exos.html#exercice-4",
    "href": "03_spec/spec_exos.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\nÉcrire une fonction mention(note) et sa spécification qui prend en paramètre une note et renvoie la chaîne de caractères ’R’ si \\(note &lt; 10\\), ’A’ si \\(10 \\leqslant note &lt; 12\\), ’AB’ si \\(12\\leqslant note &lt; 14\\), ’B’ si \\(14 \\leqslant note &lt; 16\\) et ’TB’ sinon.\nOn vérifiera d’abord que la note passée en paramètre est comprise entre 0 et 20.\nProposer un jeu de tests unitaires pour cette fonction.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "03_spec/index.html",
    "href": "03_spec/index.html",
    "title": "Programme",
    "section": "",
    "text": "Les langages de programmation Turing-complets sont caractérisés par un corpus de « constructions élémentaires ». Sans introduire cette terminologie, il s’agit de montrer qu’il existe de nombreux langages de programmation, différents par leur style (impératif, fonctionnel, objet, logique, événementiel, etc.), ainsi que des langages formalisés de description ou de requêtes qui ne sont pas des langages de programmation.\nL’importance de la spécification, de la documentation et des tests est à présenter, ainsi que l’intérêt de la modularisation qui permet la réutilisation de programmes et la mise à disposition de bibliothèques. Pour les programmes simples écrits par les élèves, on peut se contenter d’une spécification rapide mais précise.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nSpécification\nPrototyper une fonction. Décrire les préconditions sur les arguments. Décrire des postconditions sur les résultats.\nDes assertions peuvent être utilisées pour garantir des préconditions ou des postconditions.\n\n\nMise au point de programmes\nUtiliser des jeux de tests.\nL’importance de la qualité et du nombre des tests est mise en évidence. Le succès d’un jeu de tests ne garantit pas la correction d’un programme."
  },
  {
    "objectID": "02_python/python_str.html",
    "href": "02_python/python_str.html",
    "title": "Zoom sur les chaînes de caractères",
    "section": "",
    "text": "L’utilisation du signe + ne se limite pas à l’addition. Appliqué à des chaînes de caractères, il réalise l’opération de concaténation.\n\n Concaténation\n\nLe terme concaténation (substantif féminin), du latin cum («avec») et catena («chaîne, liaison»), désigne l’action de mettre bout à bout au moins deux chaînes. (Wikipédia)\n\n\nSi on considère le programme suivant :\na = \"Hello\"\nb = \"World\"\nmon_expression = a + b\naprès l’exécution de ce programme, la variable mon_expression aura pour valeur \"HelloWorld\".\nIl est aussi possible de concaténer une chaîne de caractères et une ou plusieurs variables de type str :\nma_chaine_1 = \"Bonjour \"\nma_chaine_2 = \"le \"\nres = ma_chaine_1 + ma_chaine_2 + \"monde !\"\nAprès l’exécution de ce programme, la variable res aura pour valeur \"Bonjour le  monde !.\nLes deux noms ma_chaine_1 et ma_chaine_2 sont associés à deux chaînes de caractères, nous avons donc bien ici une concaténation.\nQue se passe-t-il si nous avons ce cas de figure :\na = \"Nombre de pommes : \"\nb = 4 \nc = a + b\na est de type str, alors que b est de type int. Le signe + représente une addition ou une concaténation ? Ni l’un, ni l’autre, puisque Python vous renverra une erreur : il ne peut pas concaténer, ni additionner un entier et une chaîne de caractère.\nLa solution : transformer le nombre 4 en caractère 4 à l’aide de la fonction str() :\na = \"Nombre de pommes : \"\nb = 4 \nc = a + str(b)\nNous avons maintenant une concaténation, car str(4) est de type string.\nAutre solution pour faire cohabiter des variables de type int ou float avec des variables de type str : les fstring (attention les fstring sont uniquement disponible à partir de Python 3.5)\nIl est possible d’écrire :\na = \"Nombre de pommes :\"\nb = 4 \nc = f\"{a} {b}\"\naprès l’exécution du programme ci-dessus, la variable c aura pour valeur \"Nombre de pommes : 4\".\nDans la chaîne de caractère, {a} sera remplacé par la valeur de la variable a, c’est-à-dire \"Nombre de pommes :\". Même chose avec {b} qui sera remplacé par la valeur de b, c’est-à-dire 4.\nAutre exemple d’utilisation des fstring :\nnum_train = 4232\ndest = \"Paris\" \nc = f\"Le train n°{num_train} à destination de {dest} entre en gare\" \nAprès l’exécution du programme ci-dessus, la variable c aura pour valeur \"Le train n°4232 à destination de Paris entre en gare\".\nNotez la présence du “f” juste avant le guillemet et des accolades qui encadrent le nom de la variable. Il est nécessaire d’ajouter ce “f” pour avoir une fstring.\n\n\n\n\n\n\nEntrées utilisateurs avec input()\n\n\n\nLa fonction input() permet de demander à l’utilisateur d’entrer une valeur dans la console et de récupérer cette valeur en l’affectant à une variable.\nOn pourra par exemple tester le script suivant :\nnom = input(\"Quel est votre nom ? : \")\nprint(\"Bonjour\", nom, \" ! \")\nUne erreur courante consiste à demander l’entrée d’une valeur numérique et à l’utiliser directement dans un calcul. Le script suivant, par exemple :\nrayon = input(\"Entrer le rayon du cercle : \")\nperi = 2 * 3.14 * rayon\nprint(\"La longueur du cercle est :\", peri)\nconduit à :\nTypeError: can't multiply sequence by non-int of type 'float'\nLa fonction input() retourne toujours une chaîne de caractères. Pour une entrée numérique, cette chaîne de caractère doit être évaluée, par exemple avec la fonction eval() qui retournera un type numérique int ou float selon les cas.\nLe script ci-dessous produit le résultat attendu :\nrayon = eval(input(\"Entrer le rayon du cercle : \"))\nperi = 2 * 3.14 * rayon\nprint(\"La longueur du cercle est :\", peri)\n\n\n\n\n\n\n\n\nExercices\n\n\n\n Fiche d’exercices sur les variables, les affectations et les chaînes de caractères.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les chaînes de caractères"
    ]
  },
  {
    "objectID": "02_python/python_fonctions.html",
    "href": "02_python/python_fonctions.html",
    "title": "Fonctions",
    "section": "",
    "text": "Lors du développement d’un projet informatique, de nombreuses lignes de programme sont souvent nécessaires.\nPour clarifier le code et rendre sa compréhension, et donc sa correction, plus faciles, il est possible de le décomposer en plusieurs sous-programmes plus simples qui peuvent être étudiés séparément.\nD’autre part, il arrivera souvent qu’une même séquence d’instructions doive être utilisée à plusieurs reprises dans un programme, et on souhaitera bien évidemment ne pas avoir à la reproduire systématiquement.\nPour cela, nous pouvons définir de nouvelles fonctions, c’est-à-dire donner un nom à un groupe d’instructions, qui pourra être appelé à plusieurs reprises dans le programme principal. Cela revient à définir de nouvelles instructions.\nEn python, la syntaxe est la suivante :\ndef ma_fonction(liste des arguments de la fonction) :\n    ...\n    # groupe d'instructions\n    ...\nRemarquez les deux points et l’indentation. La première ligne, introduite par def est l’entête ou la signature de la fonction.\nVoici un premier exemple de fonction qui prend en paramètre un nombre entier \\(n\\) :\ndef table(n) :\n    for k in range(11) :\n        print(n, \"fois\", k, \"font\", n * k)\nPour exécuter cette fonction, il suffit d’écrire par exemple table(4) et on obtient l’affichage suivant :\n4 fois 0 font 0\n4 fois 1 font 4\n4 fois 2 font 8\n4 fois 3 font 12\n4 fois 4 font 16\n4 fois 5 font 20\n4 fois 6 font 24\n4 fois 7 font 28\n4 fois 8 font 32\n4 fois 9 font 36\n4 fois 10 font 40\nUne fonction peut avoir plusieurs paramètres. Ils doivent alors être séparés par des virgules.\nPar exemple, la fonction ci-dessous affiche le prix TTC en fonction du prix hors taxes et du taux de la taxe, donné en pourcentage :\ndef prixTTC(prixHT, taux) :\n    print(prixHT*(1+taux/100))\nOn a souvent besoin de définir une fonction qui calcule une valeur ou qui retourne le résultat d’un algorithme. Il faut alors utiliser l’instruction return suivie du nom de la variable contenant la valeur à retourner.\n# definition d'une fonction\ndef aire_triangle(base, hauteur) :\n    aire = base * hauteur / 2\n    return aire\n\n# programme principal\na = aire_triangle(2, 3)\nprint(a)\nRemarque : Python propose des fonctions prêtes à être utilisées par le programmeur : les fonctions natives (built-in functions en anglais). Nous avons déjà eu l’occasion d’en voir deux avec type (qui renvoie le type d’une variable) et str qui renvoie la chaîne de caractère obtenue à partir d’un nombre (str(4) renvoie le caractère “4”). Il existe beaucoup d’autres fonctions natives Python (il en existe plus de 50). Nous pouvons en citer deux autres :\n\nla fonction len prend en paramètre une chaîne de caractères et renvoie le nombre de caractères présents dans cette chaîne de caractères (par exemple len(\"azerty\") renvoie 5)\nla fonction print permet d’afficher à l’écran la valeur qui lui est passée en paramètre.\n\n\n\n\n\n\n\nPoint de vocabulaire\n\n\n\nDans ce qui précède, nous avons utilisé le terme fonction de manière très générale. Nous devons différencier deux types de “fonctions”.\n\nun groupe d’instruction qui retourne une valeur au programme principal est appelé une fonction. Une fonction ne réalise pas d’affichage : elle communique avec le programme principal par ses arguments et la valeur retournée.\nun groupe d’instruction qui ne retourne pas de valeur et qui peut éventuellement effectuer des affichages sera appelé une procédure.\n\nPar exemple, le script ci-dessus qui affiche une table de multiplication et celui qui est nommé prixTTC sont des procédures. Par contre, aire_triangle est une fonction.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Fonctions"
    ]
  },
  {
    "objectID": "02_python/python_fonctions.html#définir-une-fonction",
    "href": "02_python/python_fonctions.html#définir-une-fonction",
    "title": "Fonctions",
    "section": "",
    "text": "Lors du développement d’un projet informatique, de nombreuses lignes de programme sont souvent nécessaires.\nPour clarifier le code et rendre sa compréhension, et donc sa correction, plus faciles, il est possible de le décomposer en plusieurs sous-programmes plus simples qui peuvent être étudiés séparément.\nD’autre part, il arrivera souvent qu’une même séquence d’instructions doive être utilisée à plusieurs reprises dans un programme, et on souhaitera bien évidemment ne pas avoir à la reproduire systématiquement.\nPour cela, nous pouvons définir de nouvelles fonctions, c’est-à-dire donner un nom à un groupe d’instructions, qui pourra être appelé à plusieurs reprises dans le programme principal. Cela revient à définir de nouvelles instructions.\nEn python, la syntaxe est la suivante :\ndef ma_fonction(liste des arguments de la fonction) :\n    ...\n    # groupe d'instructions\n    ...\nRemarquez les deux points et l’indentation. La première ligne, introduite par def est l’entête ou la signature de la fonction.\nVoici un premier exemple de fonction qui prend en paramètre un nombre entier \\(n\\) :\ndef table(n) :\n    for k in range(11) :\n        print(n, \"fois\", k, \"font\", n * k)\nPour exécuter cette fonction, il suffit d’écrire par exemple table(4) et on obtient l’affichage suivant :\n4 fois 0 font 0\n4 fois 1 font 4\n4 fois 2 font 8\n4 fois 3 font 12\n4 fois 4 font 16\n4 fois 5 font 20\n4 fois 6 font 24\n4 fois 7 font 28\n4 fois 8 font 32\n4 fois 9 font 36\n4 fois 10 font 40\nUne fonction peut avoir plusieurs paramètres. Ils doivent alors être séparés par des virgules.\nPar exemple, la fonction ci-dessous affiche le prix TTC en fonction du prix hors taxes et du taux de la taxe, donné en pourcentage :\ndef prixTTC(prixHT, taux) :\n    print(prixHT*(1+taux/100))\nOn a souvent besoin de définir une fonction qui calcule une valeur ou qui retourne le résultat d’un algorithme. Il faut alors utiliser l’instruction return suivie du nom de la variable contenant la valeur à retourner.\n# definition d'une fonction\ndef aire_triangle(base, hauteur) :\n    aire = base * hauteur / 2\n    return aire\n\n# programme principal\na = aire_triangle(2, 3)\nprint(a)\nRemarque : Python propose des fonctions prêtes à être utilisées par le programmeur : les fonctions natives (built-in functions en anglais). Nous avons déjà eu l’occasion d’en voir deux avec type (qui renvoie le type d’une variable) et str qui renvoie la chaîne de caractère obtenue à partir d’un nombre (str(4) renvoie le caractère “4”). Il existe beaucoup d’autres fonctions natives Python (il en existe plus de 50). Nous pouvons en citer deux autres :\n\nla fonction len prend en paramètre une chaîne de caractères et renvoie le nombre de caractères présents dans cette chaîne de caractères (par exemple len(\"azerty\") renvoie 5)\nla fonction print permet d’afficher à l’écran la valeur qui lui est passée en paramètre.\n\n\n\n\n\n\n\nPoint de vocabulaire\n\n\n\nDans ce qui précède, nous avons utilisé le terme fonction de manière très générale. Nous devons différencier deux types de “fonctions”.\n\nun groupe d’instruction qui retourne une valeur au programme principal est appelé une fonction. Une fonction ne réalise pas d’affichage : elle communique avec le programme principal par ses arguments et la valeur retournée.\nun groupe d’instruction qui ne retourne pas de valeur et qui peut éventuellement effectuer des affichages sera appelé une procédure.\n\nPar exemple, le script ci-dessus qui affiche une table de multiplication et celui qui est nommé prixTTC sont des procédures. Par contre, aire_triangle est une fonction.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Fonctions"
    ]
  },
  {
    "objectID": "02_python/python_fonctions.html#utilisation-de-bibliothèques",
    "href": "02_python/python_fonctions.html#utilisation-de-bibliothèques",
    "title": "Fonctions",
    "section": "2. Utilisation de bibliothèques",
    "text": "2. Utilisation de bibliothèques\nIl est possible d’utiliser d’autres fonctions “prêtes à l’emploi” en important des bibliothèques, aussi appelées modules. Un module est un fichier contenant des fonctions qui pourront être utilisées dans d’autres programmes.\nDe nombreuses bibliothèques sont fournies avec une installation standard de Python, d’autres doivent être installées séparément.\nLe module math est un module très important puisqu’il comporte toutes les fonctions mathématiques classiques : cosinus, sinus, exposant, racine carrée…\nPour utiliser les fonctions présentes dans un module, il est nécessaire d’importer le module dans notre programme. Par exemple, pour pouvoir utiliser les fonctions du module math il faudra écrire :\nimport math\nau début de son programme.\nPour utiliser une fonction d’un module importé, il faudra préciser le nom du module qui propose cette fonction. Par exemple, pour déterminer le sinus de 3.14, il faudra écrire :\nmath.sin(3.14)\nVoici une série de calculs qui fait appel à des fonctions issues du module maths :\nimport math\n\na = 5\nb = 16\nc = 3.14\npuis = math.pow(a,3)\nracine = math.sqrt(b)\ns = math.sin(c)\nAprès l’exécution de ce programme :\n\nla variable puis aura pour valeur \\(5^3 = 125\\) ;\nla variable racine aura pour valeur \\(\\sqrt{16}=4\\) :\nla variable s aura pour valeur \\(\\sin(3.14)\\approx 0.05\\).\n\nPour alléger l’écriture, on peut aussi importer toutes les fonctions du module directement dans notre programme en tapant : from math import *. Il n’est alors plus nécessaire de spécifier math. devant chaque fonction utilisée.\nParmi les modules que nous utiliserons pour débuter se trouvent :\n\nle module math déjà cité ;\nle module random introduisant des fonctions permettant de générer des nombres aléatoires ;\n\n\n\n\nFonction\nEffet\n\n\n\n\nrandrange(a,b)\nrenvoie un entier aléatoire dans \\([a;b[\\)\n\n\nrandint(a,b)\nrenvoie un entier aléatoire dans \\([a;b]\\)\n\n\nrandom()\nrenvoie un flottant aléatoire dans \\([0;1[\\)\n\n\nuniform(a,b)\nrenvoie un flottant aléatoire dans \\([a;b]\\)\n\n\n\n\nle module turtle est une implémentation en Python du langage Logo créé dans les années 1970 pour l’enseignement de l’informatique à l’école. Il est disponible dans la distribution standard de Python. En déplaçant une pointe de stylo qui peut être matérialisée par une tortue, on peut tracer des figures géométriques dans un repère cartésien dont l’origine est au centre de la fenêtre et dont l’unité par défaut est le pixel. Lorsqu’on déplace le crayon, il laisse une trace s’il est baissé ou pas de trace s’il est levé. Nous utiliserons les fonctions suivantes de turtle :\n\n\n\n\n\n\n\n\nFonction\nEffet\n\n\n\n\ngoto(x,y)\ndéplace la tortue jusqu’au point de coordonnées (x, y)\n\n\npenup()\nlever le crayon\n\n\npendown()\nbaisser le crayon\n\n\nsetheading(angle)\nchoisir l’angle d’orientation de la tortue en degrés\n\n\nforward(n)\navancer de n pixels selon l’orientation de la tortue\n\n\nleft(a)\ntourne à gauche de a degrés\n\n\nright(a)\ntourne à droite de a degrés\n\n\ncolor(“red”)\nchoisir la couleur rouge (ou “black”, “green”, “blue” . . . )\n\n\n\nPour connaître toutes les fonctions contenues dans une bibliothèque, on peut, après avoir tapé import math dans la console interactive, taper ensuite help(math). On peut aussi consulter la documentation officielle.\nVoici par exemple un programme qui génère la figure ci-dessous :\nimport turtle as tt\n\ndef spirale(n):\n    tt.penup()\n    tt.goto(0,0)\n    tt.pendown()\n    c = 5\n    for i in range(4):\n        for j in range(4):\n            tt.forward(c)\n            c = 10 + c\n            tt.left(90)\nspirale(4)\ntt.exitonclick()\n\nQuelques remarques complémentaires sur ce programme :\n\nà la ligne 1, on importe le module turtle en le renommant tt afin d’alléger l’appel aux fonctions de cette bibliothèque. Cette pratique est très courante.\nà la ligne 14, la fonction exitonclick() permet de fermer la fenêtre graphique en cliquant une fois à l’intérieur.\n\n\n\n\n\n\n\nCréation d’une bibliothèque personnelle\n\n\n\nIl est aussi possible de créer un module personnel, regroupant toutes les fonctions que vous avez créées pour un projet particulier.\nSupposons par exemple que nous avons créé un fichier MesFonc.py dans lequel nous avons mis les définitions des fonctions fonc1 et fonc2.\nPour réutiliser ces fonctions dans un autre programme, on pourra importer le module MesFonc en tapant :\n\nfrom MesFonc import * : import de toutes les fonctions du module, utilisables sans préfixe.\nfrom MesFonc import fonc1 : import uniquement de la fonction fonc1, utilisable sans préfixe.\nimport MesFonc : import de toutes les fonctions du module, utilisables avec préfixe. Pour appeler la fonction fonc1, on tapera MesFonc.fonc1().\nimport MesFonc as MF : import de toutes les fonctions du module, utilisables avec préfixe alias, par commodité. Pour appeler la fonction fonc1, on tapera MF.fonc1().\n\nLes deux dernières possibilités sont intéressantes, par exemple, lorsqu’une fonction du module a le même nom qu’une autre fonction Python.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Fonctions"
    ]
  },
  {
    "objectID": "02_python/python_fonctions.html#variables-locales-et-variables-globales",
    "href": "02_python/python_fonctions.html#variables-locales-et-variables-globales",
    "title": "Fonctions",
    "section": "3. Variables locales et variables globales",
    "text": "3. Variables locales et variables globales\nConsidérons le programme suivant :\ndef ma_fonc():\n    i = 5\nma_fonc()\nprint (i)\nNous commençons par définir une fonction ma_fonc qui ne prend aucun paramètre et qui ne renvoie aucune valeur (absence du mot-clef return). Cette fonction attribue juste la valeur 5 à la variable ayant pour nom i.\nÀ la 3e ligne du programme, nous exécutons la fonction ma_fonc.\nRappelons que la fonction print permet d’afficher à l’écran la valeur qui lui est passée en paramètre. La 4e ligne de ce programme permet donc d’afficher la valeur de la variable i à l’écran.\nOn pourrait penser que ce programme va donc afficher 5 ! Pas du tout, nous avons le droit à l’erreur suivante :\nNameError: name 'i' is not defined\nLe message d’erreur est suffisamment parlant, inutile de s’attarder dessus : la variable i n’est pas définie. À noter que cette erreur est déclenchée par la 4e ligne (le print).\nPourquoi cette erreur, la variable i est bien définie dans la fonction ma_fonc et la fonction ma_fonc est bien exécutée, où est donc le problème ?\nEn fait, la variable i est une variable dite locale : elle a été définie dans une fonction et elle “restera” dans cette fonction. Une fois que l’exécution de la fonction sera terminée, la variable i sera “détruite” (supprimée de la mémoire). Elle n’est donc pas accessible depuis “l’extérieur” de la fonction (ce qui explique le message d’erreur que nous obtenons, car le print est en dehors la fonction ma_fonc, la variable i n’est donc plus accessible).\nÉtudions maintenant un cas un peu plus complexe :\ni = 3\ndef ma_fonc():\n    i = 5\nma_fonc()\nprint (i)  \nOn pourrait s’attendre à voir s’afficher la valeur 5 à l’écran. Pas du tout, nous ne rencontrons pas d’erreur cette fois, mais c’est la valeur 3 qui s’affiche à l’écran.\nEn fait dans cet exemple, nous avons 2 variables i différentes : la variable i “globale” (celle qui a été définie en dehors de toute fonction) et la variable i “locale” (celle qui a été définie dans la fonction). Ces 2 variables portent le même nom, mais sont différentes (elles correspondent à des cases mémoire différentes). Au moment de l’exécution du print à la 5e ligne seule la variable globale existe encore (celle définie à la première ligne du programme), d’où l’affichage du 3.\nUne variable globale peut être “utilisée” à l’intérieur d’une fonction :\ni = 3\ndef ma_fonc():\n    print (i)\nma_fonc()\nAttention, le print se situe dans la fonction (la ligne du print est bien indentée)\nCe programme permet d’afficher la valeur 3 à l’écran.\nQuand on cherche à utiliser une variable dans une fonction, le système va d’abord chercher si cette variable se “trouve” dans l’espace local de la fonction, puis, s’il ne la trouve pas dans cet espace local, le système va aller rechercher la variable dans l’espace global. Pour le print(i) situé dans la fonction le système ne trouve pas de variable i dans l’espace local de la fonction ma_fonc, il passe donc à l’espace global et trouve la variable i (nous avons donc 3 qui s’affiche).\nIl est important de bien comprendre que dans le programme ci-dessous le système trouve une variable i dans l’espace local de la fonction, la “recherche” de la variable i se serait arrêtée là :\ni = 3\ndef ma_fonc():\n    i = 5\n    print (i)\nma_fonc()\net ce programme affiche la valeur 5 à l’écran. i a été trouvée dans l’espace local de la fonction ma_fonc, la recherche ne va donc pas plus loin (inutile de remonter jusqu’à l’espace global)\nEn revanche le programme ci-dessous génère une erreur : “UnboundLocalError: local variable ‘i’ referenced before assignment”\ni = 3\ndef ma_fonc():\n    i = i + 1\nma_fonc()\nprint(i)\nIl n’est à priori pas possible de modifier une variable globale (ici la variable i) dans une fonction.\nPour pouvoir modifier une variable globale dans une fonction, il faut le déclarer explicitement en utilisant le mot-clef global :\ni = 3\ndef ma_fonc():\n    global i\n    i = i + 1\nma_fonc()\nprint(i)\nIci, aucune erreur la valeur 4 est bien affichée à l’écran.\nIl est fortement déconseillé de donner le même nom à une variable locale et à une variable globale pour éviter ce genre de confusions.\nOn évitera également l’emploi du mot-clef global car cette utilisation peut entraîner des “effets de bord”.\n\n\n\n\n\n\nÀ retenir\n\n\n\nLorsqu’on écrit un programme, python crée un espace de noms (namespace) dans lequel les noms des variables et des fonctions définies dans ce programme sont stockés.\nÀ l’intérieur de chaque fonction, il est possible de définir aussi des variables. Un nouvel espace de noms, complètement indépendant de l’espace de noms principal est créé pour chaque fonction.\nPar conséquent, une variable définie à l’intérieur d’une fonction n’est pas accessible depuis le programme principal et elle n’existe plus lorsque l’exécution de la fonction est terminée (même si elle porte le même nom qu’une variable du programme principal). On dit qu’il s’agit d’une variable locale.\n\n\nOn parle d’effet de bord quand une fonction modifie l’état d’une variable globale. Dans notre exemple ci-dessus, la fonction ma_fonc modifie bien la valeur de i : avant l’exécution de ma_fonc, i a la valeur 3, après l’exécution de la fonction ma_fonc, i est associé à la valeur 4. Nous avons donc bien un effet de bord.\nLes effets de bords provoquent parfois des comportements non désirés par le programmeur (évidemment dans des programmes très complexes, pas dans des cas simplistes comme celui que nous venons de voir). Ils rendent aussi parfois les programmes difficilement lisibles (difficilement compréhensibles). À cause des effets de bord, on risque de se retrouver avec des variables qui auront des valeurs qui n’étaient pas prévues par le programmeur. On dit aussi qu’à un instant donné, l’état futur des variables est difficilement prévisible à cause des effets de bord. En résumé, on évitera autant que possible l’utilisation du “global”.\n\n\n\n\n\n\nExercices\n\n\n\n Fiche d’exercices sur fonctions et la portée des variables.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Fonctions"
    ]
  },
  {
    "objectID": "02_python/python_bool.html",
    "href": "02_python/python_bool.html",
    "title": "Zoom sur les booléens",
    "section": "",
    "text": "Pour l’instant, nous avons vu deux grands types de données : les nombres (entier ou flottant) et les chaînes de caractères, il existe un troisième type tout aussi important que les deux premiers : les booléens. Un booléen est un type de données qui ne peut prendre que deux valeurs : vrai (True) ou faux (False). Une expression est soit True, soit False.\nLes opérateurs de comparaison renvoient des booléens.\n\n\n\n\n\n\nOpérateurs de comparaison\n\n\n\n\na == 0 : teste si a est égal à 0 ;\na != 0 : teste si a est différent de 0 ;\na &lt; 0 : teste si a est strictement inférieur à 0 ;\na &gt; 0 : teste si a est strictement supérieur à 0 ;\na &lt;= 0 : teste si a est inférieur ou égal à 0 ;\na &gt;= 0 : teste si a est supérieur ou égal à 0.\n\n\n\n\n\n\n\n\n\nATTENTION\n\n\n\nNotez le double égal == qui permet de distinguer un test d’égalité d’une affectation (association d’une valeur à un nom (variable)). Le fait de confondre le “simple égal” et le “double égal” est une erreur classique qu’il faut éviter.\n\n\nEn programmation informatique, un booléen est un type de variable à deux états (généralement notés vrai et faux), destiné à représenter les valeurs de vérité de la logique et l’algèbre booléenne. Il est nommé ainsi d’après George Boole (1815-1864), fondateur dans le milieu du XIXe siècle de l’algèbre portant son nom.\nNous avons vu qu’en Python, les deux valeurs booléennes sont notées True et False.\nDe manière équivalente, on adopte souvent une notation numérique en associant 1 à True et 0 à False.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les booléens"
    ]
  },
  {
    "objectID": "02_python/python_bool.html#opérateurs-booléens-de-base",
    "href": "02_python/python_bool.html#opérateurs-booléens-de-base",
    "title": "Zoom sur les booléens",
    "section": "1. Opérateurs booléens de base",
    "text": "1. Opérateurs booléens de base\nDans le cours sur les bases de Python, nous avons déjà vu les opérateurs or, and et not.\n\nOpérateur OU\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(a\\) et \\(b\\) deux expressions :\n\\[a\\textrm{ OU }b\\textrm{ est vrai }\\iff a\\textrm{ est vrai ou }b\\textrm{ est vrai}\\]\n\n\nTable de vérité de l’opérateur OU :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(a\\) OU \\(b\\)\n\n\n\n\n1\n1\n1\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n\n\n\n\n\n\n\nRemarque\n\n\n\nEn logique l’opérateur OU est inclusif : cela signifie que \\(a\\) OU \\(b\\) est vrai aussi lorsque \\(a\\) est vrai et \\(b\\) est vrai. Dans la langue courante, le mot ou est le plus souvent exclusif : dans un menu, par exemple “fromage ou dessert” ne permet pas de prendre les deux.\n\n\n\n\nOpérateur ET\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(a\\) et \\(b\\) deux expressions :\n\\[a\\textrm{ ET }b\\textrm{ est vrai }\\iff a\\textrm{ est vrai et }b\\textrm{ est vrai}\\]\n\n\nTable de vérité de l’opérateur ET :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(a\\) ET \\(b\\)\n\n\n\n\n1\n1\n1\n\n\n1\n0\n0\n\n\n0\n1\n0\n\n\n0\n0\n0\n\n\n\n\n\nOpérateur NON\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(a\\) une expression :\n\\[(\\textrm{NON }a)\\textrm{ est vrai }\\iff a\\textrm{ est faux}\\]\n\n\nTable de vérité de l’opérateur NON :\n\n\n\n\\(a\\)\nNON \\(a\\)\n\n\n\n\n1\n0\n\n\n0\n1",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les booléens"
    ]
  },
  {
    "objectID": "02_python/python_bool.html#expressions-booléennes",
    "href": "02_python/python_bool.html#expressions-booléennes",
    "title": "Zoom sur les booléens",
    "section": "2. Expressions booléennes",
    "text": "2. Expressions booléennes\nLes opérateurs de base peuvent être combinés pour formuler des expressions booléennes plus complexes. Pour éviter des problèmes d’interprétation, il est préférable d’utiliser des parenthèses pour marquer les priorités.\n\n\n\n\n\n\nExercice\n\n\n\nCompléter la table de vérité ci-dessous :\n\n\n\n\n\n\n\n\n\n\n\n\n\\(a\\)\n\\(b\\)\nNON \\(a\\)\nNON \\(b\\)\n(NON \\(a\\)) ET (NON \\(b\\))\nNON((NON \\(a\\)) ET (NON \\(b\\)))\n\\(a\\) OU \\(b\\)\n\n\n\n\n1\n1\n\n\n\n\n\n\n\n1\n0\n\n\n\n\n\n\n\n0\n1\n\n\n\n\n\n\n\n0\n0\n\n\n\n\n\n\n\n\nQue peut-on constater ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les booléens"
    ]
  },
  {
    "objectID": "02_python/python_bool.html#le-ou-exclusif",
    "href": "02_python/python_bool.html#le-ou-exclusif",
    "title": "Zoom sur les booléens",
    "section": "3. Le ou exclusif",
    "text": "3. Le ou exclusif\nLe OU logique étant inclusif, on définit un opérateur spécifique pour le ou exclusif, appelé opérateur XOR.\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(a\\) et \\(b\\) deux expressions :\n\\[a\\textrm{ XOR }b\\textrm{ est vrai }\\iff (a\\textrm{ est vrai et }b\\textrm{ est faux})\\textrm{ ou }(a\\textrm{ est faux et }b\\textrm{ est vrai})\\]\n\n\nTable de vérité de l’opérateur XOR :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(a\\) XOR \\(b\\)\n\n\n\n\n1\n1\n0\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n\nEn Python, l’opérateur xor n’existe pas. Le ou exclusif est noté ^.\n&gt;&gt;&gt; True ^ False\nTrue",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les booléens"
    ]
  },
  {
    "objectID": "02_python/python_bool.html#laddition-binaire-en-mode-booléen",
    "href": "02_python/python_bool.html#laddition-binaire-en-mode-booléen",
    "title": "Zoom sur les booléens",
    "section": "4. L’addition binaire en mode booléen",
    "text": "4. L’addition binaire en mode booléen\nLorsque nous posons l’addition de deux entiers écrits en base 2, nous avons besoin d’additionner des groupes de 3 bits (un pour chaque nombre et un pour la retenue).\nVoyons ce que donne l’addition de trois bits :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(a+b+c\\)\n\n\n\n\n0\n0\n0\n0\n\n\n1\n0\n0\n1\n\n\n0\n1\n0\n1\n\n\n0\n0\n1\n1\n\n\n1\n1\n0\n10\n\n\n1\n0\n1\n10\n\n\n0\n1\n1\n10\n\n\n1\n1\n1\n11\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nEn assimilant 0 à False et 1 à True écrire une fonction add_trois_bits(a, b, c) qui retourne la somme \\(a+b+c\\) en utilisant uniquement les opérateurs ET, OU et NON. On retournera la somme sous la forme d’une chaîne de deux caractères (\"01\" par exemple).\ndef add_3_bits(a, b, c) :\n    unite = int(...)\n    deuzaine = int(...)\n    return str(deuzaine)+str(unite)\n\nassert add_3_bits(0,0,0)==\"00\"\nassert add_3_bits(1,0,0)==\"01\"\nassert add_3_bits(0,1,0)==\"01\"\nassert add_3_bits(0,0,1)==\"01\"\nassert add_3_bits(1,1,0)==\"10\"\nassert add_3_bits(1,0,1)==\"10\"\nassert add_3_bits(0,1,1)==\"10\"\nassert add_3_bits(1,1,1)==\"11\"\nprint(\"C'est parfait !\")",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les booléens"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_3.html",
    "href": "02_python/python_bases_exos_3.html",
    "title": "Exercices - fiche 3",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.\nFiche d’exercices sur boucles.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 3"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_3.html#boucles-while",
    "href": "02_python/python_bases_exos_3.html#boucles-while",
    "title": "Exercices - fiche 3",
    "section": "Boucles while",
    "text": "Boucles while\n\n Exercice 1\nOn considère le programme suivant :\nA = 10\nwhile A &lt; 2000 :\n    A = A * 2\n    A = A + 3\nA = A - 5\n\nDonner les dix premières valeurs successives prises par la variable A.\nVérifier avec l’ordinateur et l’onglet variables ou l’explorateur de variables.\nCombien a-t-on fait de tours dans la boucle while lorsque le programme se termine ?\n\n\n\n\n Exercice 2\nOn considère le programme suivant :\nt = 1\ni = 0\nwhile t &lt; 100 :\n    t = t + 2 * i\n    i = i + 1\n\nDresser un tableau d’état faisant apparaître les valeurs successives des variables t et i.\nCombien a-t-on fait de tours dans la boucle while quand le programme se termine ?\n\n\n\n\n Exercice 3\nUne personne verse en 2017 la somme de 500 € sur un compte bancaire.\nCette somme augmente de 3,2% chaque année.\nÉcrire un programme qui affiche la somme qui se trouve sur le compte chaque année depuis 2017 jusqu’à ce que cette somme dépasse 1 000 €, sous la forme suivante :\n&gt;&gt;&gt; \nEn 2018, le capital sera de 516 €.\nEn 2019, le capital sera de 512.5120000000001 €.\n. . .\nEn 2040, le capital sera de 1031.8178626526687 €.\n\n\n\n Exercice 4\nOn donne ci dessous quatre programmes comportant une boucle while. Ces boucles se terminent-elles ou sont-elles des boucles infinies ?\n# Programme 1\nnombre = 10\nwhile nombre!=27 :\n    nombre = nombre+2\n# Programme 2\ni = 0\nwhile i&lt;10 :\n    print(i+1)\n# Programme 3\ni = 2\nwhile i&lt;10 :\n    i = 0\n    i = i+1\n# Programme 4\ni = 0\nwhile i&lt;1000000 :\n    i = i+0.001\n\n\n\n Exercice 5\nÉcrire un programme qui simule le lancer de trois dés et qui recommence jusqu’à ce qu’on obtienne un triple 6, et qui affiche le nombre d’essais qui ont été nécessaires pour obtenir ce résultat, de la manière présentée ci-dessous :\n&gt;&gt;&gt; \nJ’obtiens 5 4 2 Perdu !\nJ’obtiens 6 1 6 Perdu !\n. . .\nJ’obtiens 6 6 6 Gagné en 124 essais !\n\n\n\n\n\n\nIndication\n\n\n\nLa fonction randint de la bibliothèque random génère un entier aléatoire compris au sens large entre les deux entiers donnés en argument. Par exemple random(8,18) renvoie un entier aléatoire compris au sens large entre 8 et 18. Pour pouvoir être utilisée, cette fonction doit être importée en tapant par exemple from random import randint en début de programme.\n\n\n\n\n\n Exercice 6\nLe client d’une banque se présente devant un automate pour consulter son relevé de compte.\nPour y avoir accès, il doit saisir son code personnel qui est composé de 4 chiffres. Il devra ensuite confirmer sa saisie.\nÉcrire un programme qui demande à l’utilisateur de saisir son code, puis de confirmer sa saisie. Si les deux saisies sont différentes, un message d’erreur sera affiché et il devra recommencer, et si au bout de 10 essais il n’a toujours pas réussi, on lui dira que l’accès est refusé.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 3"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_3.html#boucles-for",
    "href": "02_python/python_bases_exos_3.html#boucles-for",
    "title": "Exercices - fiche 3",
    "section": "Boucles for",
    "text": "Boucles for\n\n Exercice 7\nÉcrire un programme qui affiche 50 fois les phrases suivantes :\n&gt;&gt;&gt;\nJe ne dois pas bavarder \nNi discuter\nNi chuchoter\nJe ne dois pas bavarder \nNi discuter\nNi chuchoter\n. . .\n\n\n\n Exercice 8\nÉcrire un programme qui affiche la phrase “Je rigole !”, puis “HaHaHa” 50 fois sur une même ligne :\n&gt;&gt;&gt;\nJe rigole !\nHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHaHa . . .\n\n\n\n Exercice 9\nÉcrire un programme qui affiche la phrase “Punition d’Albert :”, puis 20 fois la phrase “Je ne dois pas oublier ma trousse.”, puis 20 fois la phrase “Je ne dois pas oublier mon cahier.”, puis la phrase “C’est enfin fini !”.\n&gt;&gt;&gt;\nPunition d’Albert :\nJe ne dois pas oublier ma trousse. \nJe ne dois pas oublier ma trousse. \n    . . .\nJe ne dois pas oublier mon cahier. \nJe ne dois pas oublier mon cahier.\n    . . .\nC’est enfin fini !\n\n\n\n Exercice 10\nDans cet exercice, répondre à chaque question en écrivant un programme utilisant une boucle for, puis un programme utilisant une boucle while.\n\nÉcrire un programme qui affiche les 20 premiers termes de la table de multiplication par 6.\nÉcrire un programme qui affiche une suite de 12 nombres dont chacun est égal au triple du précédent.\n\n\n\n\n Exercice 11\nÉcrire un programme qui affiche un « damier » de croix et de ronds de 40 lignes et 40 colonnes (sans utiliser les opérations sur les chaînes de caractères mais en utilisant deux boucles imbriquées) :\n&gt;&gt;&gt;\nxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxo\noxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxox\nxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxo\noxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxox\n...\n\n\n\n\n\n\nIndication\n\n\n\nPour afficher une chaîne de caractères sans revenir à la ligne, on utilise : print(\"toto\", end=\"\").\n\n\n\n\n\n Exercice 12\nÉcrire un programme qui affiche un « rectangle » de croix creux de largeur 20 et hauteur 8 : (sans utiliser les opérations sur les chaînes de caractères) :\n&gt;&gt;&gt;\nxxxxxxxxxxxxxxxxxxxx\nx                  x\nx                  x\nx                  x\nx                  x\nx                  x\nx                  x\nxxxxxxxxxxxxxxxxxxxx\n\n\n\n Exercice 13\nOn considère le script suivant :\nfor compteur1 in range(1,5,1):\n    print(\"No\")\n    for compteur2 in range(1,4,1):\n        print(\"Plouf\")\n    print(\"Gloub\")\nprint(\"Yes\")\n\nCombien de fois affiche-t-il “No” ? Combien de fois affiche-t-il “Plouf” ?\nCombien de fois affiche-t-il “Gloub” ? Combien de fois affiche-t-il “Yes” ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 3"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_1.html",
    "href": "02_python/python_bases_exos_1.html",
    "title": "Exercices - fiche 1",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.\nFiche d’exercices sur les variables, les affectations et les chaînes de caractères.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 1"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_1.html#exercice-1",
    "href": "02_python/python_bases_exos_1.html#exercice-1",
    "title": "Exercices - fiche 1",
    "section": " Exercice 1",
    "text": "Exercice 1\nDans la console interactive Python, taper successivement les commandes suivantes :\na, b, c = 3, 2.5, \"toto\"\nprint(a)\nprint(b)\nprint(c)\nprint(type(a))\nprint(type(b))\nprint(type(c))\nExpliquer les résultats obtenus.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 1"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_1.html#exercice-2",
    "href": "02_python/python_bases_exos_1.html#exercice-2",
    "title": "Exercices - fiche 1",
    "section": " Exercice 2",
    "text": "Exercice 2\nOn considère le script suivant :\na = 50\nb = 30\na = b + 10\nb = a * 2\na = b\nb = b - 5\nCompléter le tableau d’état ci-dessous par les valeurs prises par les variables a et b à chaque étape.\n\n\n\nEtape\na\nb\n\n\n\n\n1\n\n\n\n\n2\n\n\n\n\n3\n\n\n\n\n4\n\n\n\n\n5\n\n\n\n\n6\n\n\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nDans Thonny, on peut utiliser la fenêtre “variables” et le débogueur pour suivre l’évolution des variables au cours de l’exécution d’un programme.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 1"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_1.html#exercice-3",
    "href": "02_python/python_bases_exos_1.html#exercice-3",
    "title": "Exercices - fiche 1",
    "section": " Exercice 3",
    "text": "Exercice 3\nParmi les 8 noms de variables suivants, quels sont ceux qui ne sont pas acceptés par un programme Python (expliquer pourquoi) ?\n\n\n\nprix.de.ma.voiture\nun-prix\n\n\nprix_de_ma_voiture\n1prix\n\n\nprix de ma voiture\nprixen€\n\n\nprixdemavoiture\nprix1",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 1"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_1.html#exercice-4",
    "href": "02_python/python_bases_exos_1.html#exercice-4",
    "title": "Exercices - fiche 1",
    "section": " Exercice 4",
    "text": "Exercice 4\nQue va produire l’exécution du programme suivant ?\na = 100\nb = 50\na = b\nb = a + 10\nprint(a)\nprint(b)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 1"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_1.html#exercice-5",
    "href": "02_python/python_bases_exos_1.html#exercice-5",
    "title": "Exercices - fiche 1",
    "section": " Exercice 5",
    "text": "Exercice 5\nQue va produire l’exécution du programme suivant ?\na = 100\na = a - 10\na = a * 2\na = a + 50\nprint(a)\nprint(\"a\")",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 1"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_1.html#exercice-6",
    "href": "02_python/python_bases_exos_1.html#exercice-6",
    "title": "Exercices - fiche 1",
    "section": " Exercice 6",
    "text": "Exercice 6\nAprès les affectations suivantes, quelles sont les valeurs des variables a et b ?\na = 1\nb = a + 5\na = 2 * b + 3\nb = 3 * a + 2\na = 2 * b + 3",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 1"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_1.html#exercice-7",
    "href": "02_python/python_bases_exos_1.html#exercice-7",
    "title": "Exercices - fiche 1",
    "section": " Exercice 7",
    "text": "Exercice 7\nCorriger le programme ci-dessous pour qu’il effectue l’action indiquée en commentaires. Deux solutions différentes sont attendues.\n# ce programme affiche la somme de a et de b\n\na = \"4\"\nb=\"5\"\nprint(\"La somme de\", a, \"et de\",b,\"est égale à\", a + b)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 1"
    ]
  },
  {
    "objectID": "02_python/index.html",
    "href": "02_python/index.html",
    "title": "Programme",
    "section": "",
    "text": "Les langages de programmation Turing-complets sont caractérisés par un corpus de « constructions élémentaires ». Sans introduire cette terminologie, il s’agit de montrer qu’il existe de nombreux langages de programmation, différents par leur style (impératif, fonctionnel, objet, logique, événementiel, etc.), ainsi que des langages formalisés de description ou de requêtes qui ne sont pas des langages de programmation.\nL’importance de la spécification, de la documentation et des tests est à présenter, ainsi que l’intérêt de la modularisation qui permet la réutilisation de programmes et la mise à disposition de bibliothèques. Pour les programmes simples écrits par les élèves, on peut se contenter d’une spécification rapide mais précise.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nConstructions élémentaires\nMettre en évidence un corpus de constructions élémentaires.\nSéquences, affectation, conditionnelles, boucles bornées, boucles non bornées, appels de fonction.\n\n\nUtilisation de bibliothèques\nUtiliser la documentation d’une bibliothèque.\nAucune connaissance exhaustive d’une bibliothèque particulière n’est exigible.\n\n\n\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nDiversité et unité des langages de programmation\nRepérer, dans un nouveau langage de programmation, les traits communs et les traits particuliers à ce langage.\nLes manières dont un même programme simple s’écrit dans différents langages sont comparées."
  },
  {
    "objectID": "01_os/OS_exos.html",
    "href": "01_os/OS_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "01_os/OS_exos.html#exercice-1",
    "href": "01_os/OS_exos.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\nEn utilisant l’arborescence ci-dessous, quelle est la commande à saisir si le répertoire courant est le répertoire “home” et que vous “voulez vous rendre” dans le répertoire “Documents” (vous utiliserez d’abord un chemin absolu puis un chemin relatif).\n\n\n\n\n\n\n\n\nConsignes pour les exercices 2 et 3\n\n\n\nLes exercices 2 et 3 doivent être réalisés sur un système Linux.\nRemarque : dans le terminal, la flèche “montante” du clavier permet de remonter dans l’historique des commandes et la touche de tabulation permet la complétion automatique des commandes et des chemins.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "01_os/OS_exos.html#exercice-2",
    "href": "01_os/OS_exos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nFaites les actions suivantes en utilisant des lignes de commande. Pour chaque question, recopier la liste des commandes utilisées.\n\nRendez-vous dans votre répertoire personnel /home ;\nCréez un répertoire doc ;\nPlacez-vous dans le répertoire doc ;\nCréez un répertoire texte ;\nCréez un répertoire mesDoc ;\nPlacez-vous dans le répertoire texte ;\nCréez un fichier toto.txt ;\nOuvrez l’éditeur de texte nano pour éditer le fichier toto.txt : pour cela, entrer la commande nano toto.txt dans le terminal.\nEntrez le texte “Bonjour Linux !”, enregistrez (CTRL O et valider) et quittez (CTRL X) nano.\nAffichez dans le terminal le contenu du fichier toto.txt.\nPlacez-vous dans le répertoire doc ;\nCopiez le fichier toto.txt dans le répertoire mesDoc ;\nPlacez-vous dans le répertoire mesDoc et vérifiez que le fichier toto.txt est bien présent dans ce répertoire ;\nPlacez-vous dans le répertoire doc ;\nEffacez le fichier toto.txt du répertoire texte ;\nDéplacez le fichier toto.txt du répertoire mesDoc vers le répertoire doc ;\nEffacez le répertoire mesDoc ;\nEffacez le répertoire texte ;\nEffacez le fichier toto.txt.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "01_os/OS_exos.html#exercice-3",
    "href": "01_os/OS_exos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\nFaites les actions suivantes en utilisant des lignes de commande (en partant de votre répertoire de travail). Recopier la liste des commandes utilisées.\n\nCréez un répertoire doc ;\nPlacez-vous dans le répertoire doc et créez un fichier toto.txt ;\nListez les droits (r, w et x) pour les différents utilisateurs (u, g et o) sur le fichier toto.txt ;\nSupprimez le droit en lecture pour les utilisateurs g sur le fichier toto.txt.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "01_os/OS_exos.html#exercice-4",
    "href": "01_os/OS_exos.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\nOn donne les éléments ci-dessous, obtenus en utilisant la commande ls -l :\n-rwx------ 1 toto eleves 512K sept. 10 10:53 fichier1\n-rw-r--r-- 1 lena eleves 41M sept. 10 10:27 fichier2\n-rwx--x--x 1 john profs 2M sept. 5 10:02 fichier3\nPour chacun des fichiers, donner le nom de l’utilisateur auquel il appartient, les droits qu’il a sur le fichier, ceux du groupe et des autres.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "01_os/OS_exos.html#exercice-5",
    "href": "01_os/OS_exos.html#exercice-5",
    "title": "Exercices",
    "section": " Exercice 5",
    "text": "Exercice 5\nCet exercice a pour objectif d’utiliser et de découvrir un certain nombre de commandes Linux en résolvant un escape game en ligne. Pour cela, rendez-vous sur le site https://luffah.xyz/bidules/Terminus/ et suivez les instructions.\nAu fur et à mesure du déroulement du jeu, notez les commandes que vous avez utilisées pour résoudre les énigmes et leur rôle. Réaliser également un plan du monde de Terminus sous la forme d’une arborescence de dossiers et de fichiers.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Exercices"
    ]
  },
  {
    "objectID": "15_parcours/parcours_exos.html",
    "href": "15_parcours/parcours_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Dans un premier temps, tous ces exercices doivent être recherchés en mode papier/crayon. Ensuite, vous pourrez les tester en Python dans Capytale en suivant le lien fourni.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "15_parcours/parcours_exos.html#exercice-1-recherche-de-doublons",
    "href": "15_parcours/parcours_exos.html#exercice-1-recherche-de-doublons",
    "title": "Exercices",
    "section": "Exercice 1 : Recherche de doublons",
    "text": "Exercice 1 : Recherche de doublons\nOn souhaite savoir si un tableau T d’éléments quelconques contient des doublons. Autrement dit, on souhaite savoir s’il existe deux indices i et j distincts tels que T[i] et T[j] sont égaux.\nÉcrire une fonction doublon qui prend comme argument un tableau T et qui renvoie True s’il existe (au moins) un doublon dans T et False dans le cas contraire.\nExemples :\n&gt;&gt;&gt; doublon([1, 2, 3, 4, 5])\nFalse\n&gt;&gt;&gt; doublon([1, 2, 3, 4, 5, 1])\nTrue",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "15_parcours/parcours_exos.html#exercice-2",
    "href": "15_parcours/parcours_exos.html#exercice-2",
    "title": "Exercices",
    "section": "Exercice 2",
    "text": "Exercice 2\nOn a relevé les valeurs moyennes annuelles des températures à Paris pour la période allant de 2013 à 2019. Les résultats ont été récupérés sous la forme de deux listes :\n\nl’une pour les températures, t_moy = [14.9, 13.3, 13.1, 12.5, 13.0, 13.6, 13.7]\nl’autre pour les années : annees = [2013, 2014, 2015, 2016, 2017, 2018, 2019]\n\nÉcrire la fonction mini qui prend en paramètres un tableau releve des relevés et un tableau date des dates et qui renvoie un couple formé de la plus petite valeur relevée au cours de la période et de l’année correspondante.\nExemple :\n&gt;&gt;&gt; mini(t_moy, annees)\n(12.5, 2016)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "15_parcours/parcours_exos.html#exercice-3",
    "href": "15_parcours/parcours_exos.html#exercice-3",
    "title": "Exercices",
    "section": "Exercice 3",
    "text": "Exercice 3\nÉcrire une fonction maxi qui prend en paramètre un tableau tab de nombres entiers et renvoie un couple donnant le plus grand élément de ce tableau, ainsi que l’indice de la première apparition de ce maximum dans le tableau.\nExemple :\n&gt;&gt;&gt; maxi([1,5,6,9,1,2,3,7,9,8])\n(9,3)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "15_parcours/parcours_exos.html#exercice-4",
    "href": "15_parcours/parcours_exos.html#exercice-4",
    "title": "Exercices",
    "section": "Exercice 4",
    "text": "Exercice 4\nÉcrire une fonction RechercheMinMax qui prend en paramètre un tableau de nombres non triés tab, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d’un dictionnaire à deux clés ‘min’ et ‘max’.\nExemples :\n&gt;&gt;&gt; RechercheMinMax([1,5,6,9,1,2,3,7,9,8])\n{'min': 1, 'max': 9}\n&gt;&gt;&gt; RechercheMinMax([2,2,2])\n{'min': 2, 'max': 2}\n&gt;&gt;&gt; RechercheMinMax([])\n{'min': None, 'max': None}",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "15_parcours/parcours_exos.html#exercice-5",
    "href": "15_parcours/parcours_exos.html#exercice-5",
    "title": "Exercices",
    "section": "Exercice 5",
    "text": "Exercice 5\nOn dit que dans un tableau de nombres, il y a un «saut en hauteur» lorsqu’une valeur est supérieure à la valeur précédente. Par exemple dans le tableau [7, 4, 3, 6, 7, 4, 3, 1, 8, 8], il y a trois sauts en hauteur :\n\nentre les indices 2 et 3 (pour passer de la valeur 3 à la valeur 6),\nentre les indices 3 et 4 (pour passer de la valeur 6 à la valeur 7),\net entre les indices 7 et 8 (pour passer de la valeur 1 à la valeur 8).\n\nPlus formellement, dans un tableau tab de taille n on dit qu’il y a un saut en hauteur à l’indice i lorsque tab[i] &lt; tab[i+1].\n\nQuel est le plus grand indice possible dans un tableau de taille n ?\nPour avoir le droit d’écrire tab[i] &lt; tab[i+1] avec un tableau tab de taille n, quelle est alors la plus grande valeur de i possible : n-2, n-1, n ou n+1 ?\nCompléter la fonction compter_sauts_en_hauteur ci-dessous qui prend en paramètre un tableau tab de nombres et renvoie le nombre de sauts en hauteur présents dans le tableau tab.\n\nLe parcours de tab sera fait par indices.\ndef compter_sauts_en_hauteur(tab):\n    compteur = 0\n\n    for i in range(...):\n        if ... :\n            ... = ... + ...\n    return ...\nExemples :\n&gt;&gt;&gt; tab = [7, 4, 3, 6, 7, 4, 3, 1, 8]\n&gt;&gt;&gt; compter_sauts_en_hauteur(tab)\n3\n&gt;&gt;&gt; tab = [7, 4, 3, 6, 7, 4, 3, 1, 8, 2, 5, 6, 5, 8, 1, 9, 0, 1, 5, 6, 3, 7, 8, 3, 3, 4, 5, 5, 2 ]\n&gt;&gt;&gt; compter_sauts_en_hauteur(tab)\n14\n&gt;&gt;&gt; tab = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; compter_sauts_en_hauteur(tab)\n8\n&gt;&gt;&gt; tab = []\n&gt;&gt;&gt; compter_sauts_en_hauteur(tab)\n0\n&gt;&gt;&gt; tab = [1]\n&gt;&gt;&gt; compter_sauts_en_hauteur(tab)\n0\n&gt;&gt;&gt; tab = [7, 7, 7, 7]\n&gt;&gt;&gt; compter_sauts_en_hauteur(tab)\n0",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "15_parcours/parcours_exos.html#exercice-6",
    "href": "15_parcours/parcours_exos.html#exercice-6",
    "title": "Exercices",
    "section": "Exercice 6",
    "text": "Exercice 6\nOn dispose ici de deux tableaux de même longueur. Il s’agit de calculer le nombre de différences entre les deux tableaux. Par exemple avec les deux tableaux suivants :\ntab_1  = ['a', 'g', 'u', 'u', 'c', 'o', 'p', 'l', 'm', 'v', 'p']\ntab_2  = ['a', 'g', 's', 'u', 'c', 'k', 'p', 'l', 't', 'v', 'p']\nil y a trois différences entre les deux tableaux : aux indices 2, 5 et 8.\nCompléter la fonction compter_differences ci-dessous qui prend en paramètre deux tableaux tab_1 et tab_2 de même longueur et qui renvoie le nombre de différences entre les deux tableaux.\ndef compter_differences(tab_1, tab_2):\n    compteur = ...\n\n    for ... in range(...) :\n        if ... != ...:\n            compteur = ... + ...\n    return ...\nExemples :\n&gt;&gt;&gt; tab_1  = ['a', 'g', 'u', 'u', 'c', 'o', 'p', 'l', 'm', 'v', 'p']\n&gt;&gt;&gt; tab_2  = ['a', 'g', 's', 'u', 'c', 'k', 'p', 'l', 't', 'v', 'p']\n&gt;&gt;&gt; compter_differences(tab_1, tab_2)\n3\n&gt;&gt;&gt; tab_1  = ['a', 'g', 'u', 'u', 'c', 'o', 'p', 'l', 'm', 'v', 'p']\n&gt;&gt;&gt; tab_2  = ['a', 'g', 'u', 'u', 'c', 'o', 'p', 'l', 'm', 'v', 'p']\n&gt;&gt;&gt; compter_differences(tab_1, tab_2)\n0\n&gt;&gt;&gt; tab_1  = ['a', 'g', 'u', 'u', 'c', 'o', 'p', 'l', 'm', 'v', 'p']\n&gt;&gt;&gt; tab_2  = ['g', 'u', 'u', 'c', 'o', 'p', 'l', 'm', 'v', 'p', 'a']\n&gt;&gt;&gt; compter_differences(tab_1, tab_2)\n10\n&gt;&gt;&gt; tab_1  = ['a']\n&gt;&gt;&gt; tab_2  = ['b']\n&gt;&gt;&gt; compter_differences(tab_1, tab_2)\n1\n&gt;&gt;&gt; tab_1  = []\n&gt;&gt;&gt; tab_2  = []\n&gt;&gt;&gt; compter_differences(tab_1, tab_2)\n0",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "15_parcours/parcours_exos.html#exercice-7",
    "href": "15_parcours/parcours_exos.html#exercice-7",
    "title": "Exercices",
    "section": "Exercice 7",
    "text": "Exercice 7\nOn dit qu’on écrête un signal lorsqu’on limite l’amplitude du signal entre deux valeurs \\(a\\) et \\(b\\). On peut également appliquer cela à des tableaux de valeurs. Voici par exemple un tableau tab que l’on a écrêté entre \\(- 150\\) et \\(150\\) pour donner le tableau tab_ec :\ntab =    [34, 56, 89, 134, 152, 250, 87, -34, -187, -310]\ntab_ec = [34, 56, 89, 134, 150, 150, 87, -34, -150, -150]\nÉtant donné un nombre \\(x\\) et deux entiers \\(a\\) et \\(b\\) tels que \\(a\\leqslant b\\), l’écrêtage consiste à :\n\nconserver \\(x\\) inchangé si \\(x\\) est compris entre \\(a\\) et \\(b\\),\nremplacer \\(x\\) par \\(a\\) si \\(x\\) est plus petit que \\(a\\),\nremplacer \\(x\\) par \\(b\\) si \\(x\\) est plus grand que \\(b\\).\n\nÉcrire une fonction ecrete qui prend en paramètres un tableau d’entiers tab de longueur quelconque ainsi que deux entiers a et b avec a &lt;= b et qui renvoie un nouveau tableau nv_tab correspondant à tab avec toutes ses valeurs écrêtées entre a et b.\ndef ecrete(tab):\n    pass\nExemples :\n&gt;&gt;&gt; ecrete([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], 5, 10)\n[5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 10, 10, 10, 10]\n&gt;&gt;&gt; ecrete([-13, -4, 6, 5, 8, -3, -12, -3, 0, 6, 7], -10, -5)\n[-10, -5, -5, -5, -5, -5, -10, -5, -5, -5, -5]\n&gt;&gt;&gt; ecrete([7, 8, 3, 9, 8, 7, 2, 4, 8, 9, 0, 1, 5, 8, 8, 8, 4, 5, 4, 5], 0, 10)\n[7, 8, 3, 9, 8, 7, 2, 4, 8, 9, 0, 1, 5, 8, 8, 8, 4, 5, 4, 5]\n&gt;&gt;&gt; ecrete([], 0, 10)\n[]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices"
    ]
  },
  {
    "objectID": "15_parcours/index.html",
    "href": "15_parcours/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "15_parcours/index.html#points-traités-dans-cette-séquence",
    "href": "15_parcours/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "15_parcours/parcours_cours.html",
    "href": "15_parcours/parcours_cours.html",
    "title": "Parcourir un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire la complexité de l’algorithme est proportionnelle à la taille \\(n\\) du tableau. Dans ce cas, on note ((n)) la complexité de l’algorithme.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Parcourir un tableau"
    ]
  },
  {
    "objectID": "15_parcours/parcours_cours.html#recherche-dune-occurrence",
    "href": "15_parcours/parcours_cours.html#recherche-dune-occurrence",
    "title": "Parcourir un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire la complexité de l’algorithme est proportionnelle à la taille \\(n\\) du tableau. Dans ce cas, on note ((n)) la complexité de l’algorithme.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Parcourir un tableau"
    ]
  },
  {
    "objectID": "15_parcours/parcours_cours.html#recherche-dun-extremum",
    "href": "15_parcours/parcours_cours.html#recherche-dun-extremum",
    "title": "Parcourir un tableau",
    "section": "2. Recherche d’un extremum",
    "text": "2. Recherche d’un extremum\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui recherche le plus grand élément du tableau. Pour cela, on commence par choisir comme maximum temporaire le premier élément du tableau. On parcourt ensuite le tableau en testant à chaque fois si la valeur courante est plus grande que le maximum temporaire. Si c’est le cas, on met à jour le maximum temporaire avec la valeur courante.\n\ndef max(tab):\n    \"\"\"Retourne le plus grand élément du tableau\"\"\"\n    m = tab[0]\n    for i in range(1, len(tab)):\n        if tab[i] &gt; m:\n            m = tab[i]\n    return m\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(max(tab))\n\n2023\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau, sauf la première. Il y a donc au total \\(n-1\\) itérations. Nous avons aussi \\(n-1\\) comparaisons. Au total, le nombre d’opérations est donc de \\(2n-2\\) (fonction affine de \\(n\\)). On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Parcourir un tableau"
    ]
  },
  {
    "objectID": "15_parcours/parcours_cours.html#calcul-dune-moyenne",
    "href": "15_parcours/parcours_cours.html#calcul-dune-moyenne",
    "title": "Parcourir un tableau",
    "section": "3. Calcul d’une moyenne",
    "text": "3. Calcul d’une moyenne\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui calcule la moyenne des éléments du tableau.\n\ndef moyenne(tab):\n    \"\"\"Retourne la moyenne des éléments du tableau\"\"\"\n    s = 0\n    for i in range(len(tab)):\n        s += tab[i]\n    return s / len(tab)\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(moyenne(tab))\n\n409.4\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. Nous avons aussi \\(n\\) additions et une division. Au total, le nombre d’opérations est donc de \\(2n+1\\). On peut donc dire que l’algorithme est encore de complexité \\(\\mathcal{O}(n)\\).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Parcourir un tableau"
    ]
  },
  {
    "objectID": "01_os/OS_cours.html",
    "href": "01_os/OS_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Un système informatique a pour objectif d’automatiser le traitement de l’information. Il est constitué de deux entités : le matériel (hardware) et le logiciel (software).\nDu côté matériel, un ordinateur est composé de:\n\nL’Unité Centrale (UC) pour les traitements\nLa Mémoire Centrale (MC) pour le stockage\nLes Périphériques : disque dur, clavier, souris, … , carte réseau… accessibles via des pilotes de périphériques\n\nCet aspect matériel sera étudié plus en détail dans le chapitre Modèle d’architecture de von Neumann.\nDu côté logiciel, il existe deux niveaux bien distincts : le système d’exploitation et les applications.\nL’objectif de la partie logicielle est d’offrir aux utilisateurs des fonctionnalités adaptées à leurs besoins.\n\n\n\n\n\n\nObjectifs d’un système d’exploitation\n\n\n\nLes trois objectifs majeurs d’un système d’exploitation sont :\n\nfaire l’interface entre le matériel et l’utilisateur (et par “utilisateur” on entend aussi bien l’utilisateur humain que des applications non système) ; exemples :\n\ncommunication de l’utilisateur vers le matériel : on appuie sur une touche du clavier et on s’attend à ce que le caractère concerné apparaisse à l’écran ;\ncommunication du matériel vers l’utilisateur : si un fichier qu’on essaye d’atteindre n’existe pas, on a un message d’erreur.\n\nisoler le code utilisateur du matériel, permettant ainsi par exemple :\n\nde changer le matériel de façon transparente (ou presque) pour l’utilisateur (il faudra parfois installer des modules ou drivers supplémentaires, mais une fois cela fait, on continue à fonctionner comme précédemment) ;\nd’assurer l’intégrité des données : par exemple le système assure qu’un utilisateur autre ne peut accéder à des données pour lesquelles il n’a pas les droits d’accès ; mais il assure aussi qu’aucun utilisateur ne puisse détruire la cohérence de l’ensemble des données ;\n\nfaire en sorte que tous les programmes puissent s’exécuter de façon équitable (un programme qui demande l’utilisation d’une ressource y aura accès en un temps “raisonnable”).\n\n\n\nLe troisième point sera approfondi en terminale.\n\nOn abrégera “Système d’exploitation” par SE (en français) ou pas OS (operating system en anglais).\nLe système d’exploitation est le premier logiciel qui démarre quand on allume un ordinateur. Aujourd’hui, il est installé sur le disque dur ou le disque SSD de l’ordinateur. Dans les années 80-90 du 20ᵉ siècle, les ordinateurs personnels n’avaient souvent pas de disque dur. Le SE était fourni sur une ou plusieurs disquettes de démarrage, support de mémoire amovible qui a disparu depuis, qui devait être insérée dans le lecteur de disquette à chaque démarrage.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours"
    ]
  },
  {
    "objectID": "01_os/OS_cours.html#à-quoi-sert-un-système-dexploitation",
    "href": "01_os/OS_cours.html#à-quoi-sert-un-système-dexploitation",
    "title": "Cours",
    "section": "",
    "text": "Un système informatique a pour objectif d’automatiser le traitement de l’information. Il est constitué de deux entités : le matériel (hardware) et le logiciel (software).\nDu côté matériel, un ordinateur est composé de:\n\nL’Unité Centrale (UC) pour les traitements\nLa Mémoire Centrale (MC) pour le stockage\nLes Périphériques : disque dur, clavier, souris, … , carte réseau… accessibles via des pilotes de périphériques\n\nCet aspect matériel sera étudié plus en détail dans le chapitre Modèle d’architecture de von Neumann.\nDu côté logiciel, il existe deux niveaux bien distincts : le système d’exploitation et les applications.\nL’objectif de la partie logicielle est d’offrir aux utilisateurs des fonctionnalités adaptées à leurs besoins.\n\n\n\n\n\n\nObjectifs d’un système d’exploitation\n\n\n\nLes trois objectifs majeurs d’un système d’exploitation sont :\n\nfaire l’interface entre le matériel et l’utilisateur (et par “utilisateur” on entend aussi bien l’utilisateur humain que des applications non système) ; exemples :\n\ncommunication de l’utilisateur vers le matériel : on appuie sur une touche du clavier et on s’attend à ce que le caractère concerné apparaisse à l’écran ;\ncommunication du matériel vers l’utilisateur : si un fichier qu’on essaye d’atteindre n’existe pas, on a un message d’erreur.\n\nisoler le code utilisateur du matériel, permettant ainsi par exemple :\n\nde changer le matériel de façon transparente (ou presque) pour l’utilisateur (il faudra parfois installer des modules ou drivers supplémentaires, mais une fois cela fait, on continue à fonctionner comme précédemment) ;\nd’assurer l’intégrité des données : par exemple le système assure qu’un utilisateur autre ne peut accéder à des données pour lesquelles il n’a pas les droits d’accès ; mais il assure aussi qu’aucun utilisateur ne puisse détruire la cohérence de l’ensemble des données ;\n\nfaire en sorte que tous les programmes puissent s’exécuter de façon équitable (un programme qui demande l’utilisation d’une ressource y aura accès en un temps “raisonnable”).\n\n\n\nLe troisième point sera approfondi en terminale.\n\nOn abrégera “Système d’exploitation” par SE (en français) ou pas OS (operating system en anglais).\nLe système d’exploitation est le premier logiciel qui démarre quand on allume un ordinateur. Aujourd’hui, il est installé sur le disque dur ou le disque SSD de l’ordinateur. Dans les années 80-90 du 20ᵉ siècle, les ordinateurs personnels n’avaient souvent pas de disque dur. Le SE était fourni sur une ou plusieurs disquettes de démarrage, support de mémoire amovible qui a disparu depuis, qui devait être insérée dans le lecteur de disquette à chaque démarrage.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours"
    ]
  },
  {
    "objectID": "01_os/OS_cours.html#différents-systèmes-dexploitation",
    "href": "01_os/OS_cours.html#différents-systèmes-dexploitation",
    "title": "Cours",
    "section": "2. Différents systèmes d’exploitation",
    "text": "2. Différents systèmes d’exploitation\nNous distinguerons les OS propriétaires et les OS libres.\nVoyons comment la notion de logiciel libre est définie par la Free Software Foundation (ONG américaine dont la mission est la promotion du logiciel libre et la défense des utilisateurs) :\n\n\n\n\n\n\nLogiciel libre\n\n\n\nUn logiciel est considéré comme libre, au sens de la Free Software Foundation, s’il confère à son utilisateur quatre libertés (numérotées de 0 à 3) :\n\n0 : la liberté d’exécuter le programme, pour tous les usages ;\n1 : la liberté d’étudier le fonctionnement du programme et de l’adapter à ses besoins ;\n2 : la liberté de redistribuer des copies du programme (ce qui implique la possibilité aussi bien de donner que de vendre des copies) ;\n3 : la liberté d’améliorer le programme et de distribuer ces améliorations au public, pour en faire profiter toute la communauté.\n\nL’accès au code source est une condition d’exercice des libertés 1 et 3.\n\n\nUn logiciel propriétaire, est tout simplement un logiciel qui n’est pas libre, c’est-à-dire qui ne respecte pas l’une ou plusieurs des quatre libertés énoncées ci-dessus.\nAttention à ne pas confondre libre et gratuit : un logiciel libre peut très bien être payant tout comme un logiciel propriétaire peut être gratuit. La confusion vient souvent de l’anglais où le terme free signifie à la fois libre et gratuit.\nLes systèmes d’exploitations les plus répandus sont :\n\nUnix (1970) : l’un des premiers OS multi-utilisateurs. Il s’agit d’un OS propriétaire : le code source n’est pas accessible.\nGNU-Linux (1991) : système d’exploitation libre, imitant Unix.\nMS-DOS (1981) : de l’entreprise Microsoft, OS propriétaire qui connaîtra différentes évolutions.\nWindows (1985) : de l’entreprise Microsoft, OS propriétaire qui connaîtra différentes évolutions. D’abord simple extension de MS-DOS, Windows est devenu un système d’exploitation indépendant avec les années et a connu de nombreuses évolutions.\nmacOS (OS X) (1998) : de l’entreprise Apple, OS propriétaire qui a connu différentes évolutions.\n\nVoici la répartition des parts de marché des principaux OS utilisés sur les ordinateurs de bureau en 2023 (source : LEPTIDIGITAL) :\n\nCompléments :\n\nvoir sur le blog la vidéo “Un système d’exploitation, c’est quoi ?” dans cet article.\ndes explications plus poussées dans cette vidéo.\nvidéo présentant l’histoire d’Unix.\nvidéo présentant l’histoire de Linux.\nvidéo plus complète pour approfondir l’histoire de GNU-Linux.\n\nLe programme de NSI nous incite à utiliser un système d’exploitation libre. Nous allons donc dans le paragraphe suivant étudier de plus près le système Linux.\n\nLinux est un système d’exploitation libre et open source créé en 1991 par l’étudiant finlandais Linus Torvalds, avec l’objectif de proposer une alternative fiable et ouverte à UNIX. Ce système est depuis en constante évolution. De nombreux systèmes utilisent le noyau Linux, comme Ubuntu, Debian, Fedora ou encore Android. Linux est disponible sous la forme de nombreuses distributions, ensemble cohérent de logiciels assemblés autour du noyau Linux pour former un OS pleinement opérationnel. Le site Distrowatch répertorie de très nombreuses distributions. Les plus connues sont Ubuntu, Mint, Debian et Fedora. Dans un système Linux, le gestionnaire d’affichage graphique (gestionnaire de fenêtre) peut être choisi par l’utilisateur parmi de nombreuses possibilités : Gnome, Kde, Xfce, etc.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours"
    ]
  },
  {
    "objectID": "01_os/OS_cours.html#la-ligne-de-commande",
    "href": "01_os/OS_cours.html#la-ligne-de-commande",
    "title": "Cours",
    "section": "3. La ligne de commande",
    "text": "3. La ligne de commande\nAux débuts des systèmes d’exploitation, ces derniers étaient dépourvus d’interface graphique (système de fenêtres “pilotables” à la souris), toutes les interactions “système d’exploitation - utilisateur” se faisaient par l’intermédiaire de lignes de commandes (suites de caractères saisies par l’utilisateur). Aujourd’hui, même si les interfaces graphiques modernes permettent d’effectuer la plupart des opérations, il est important de connaître quelques-unes de ces lignes de commandes.\nLes utilisateurs avancés, notamment ceux qui utilisent Linux, trouvent en effet un grand intérêt à la ligne de commande qui permet indubitablement, quand on en maîtrise la syntaxe, de réaliser certaines opérations plus rapidement qu’avec la souris, de manière plus contrôlée et sûre.\nPour saisir des lignes de commandes, nous allons utiliser une console, ou terminal. Tous les OS en possèdent une. Derrière ce logiciel s’en cache un autre : le shell qui est en fait l’interpréteur des lignes de commandes. Il s’agit d’un langage de programmation. Sous Linux, bash est un shell très répandu.\nSous Windows, nous avons par exemple le terminal PowerShell.\n\nSous Linux, suivant la distribution utilisée, le terminal peut posséder des noms différents (Terminal, Konsole, …). L’image ci-dessous montre le terminal de la distribution Ubuntu, appelé Gnome Terminal :\n\nRemarque : les commandes que nous allons étudier sont des commandes de base du shell pour Linux. Cependant, dans les versions récentes de Windows, PowerShell est capable d’interpréter ces commandes et elles fonctionneront donc parfaitement aussi.\nSur l’image ci-dessus, nous voyons le terminal de l’utilisateur “fabrice” qui utilise un ordinateur qui se nomme “inspiron” (“fabrice@inspiron”).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours"
    ]
  },
  {
    "objectID": "01_os/OS_cours.html#arborescence-du-système-de-fichier",
    "href": "01_os/OS_cours.html#arborescence-du-système-de-fichier",
    "title": "Cours",
    "section": "4. Arborescence du système de fichier",
    "text": "4. Arborescence du système de fichier\nOn a l’habitude de dire que sous Linux, tout est fichier. Les différents fichiers, répertoires, périphériques, liens sont en effet tous représentés par des fichiers de différents types rangés dans une arborescence bien précise de répertoires. Cette organisation est héritée du système Unix et se retrouve dans tous les systèmes apparentés, comme macOs.\nSur la figure ci-dessous, une partie de l’arborescence est présentée.\n\nDans le schéma ci-dessus on trouve des répertoires (noms entourés d’un rectangle, exemple : “home”) et des fichiers (uniquement des noms “grub.cfg”).\nOn parle d’arborescence, car ce système de fichier ressemble à un arbre à l’envers.\nComme vous pouvez le constater, la base de l’arbre s’appelle la racine de l’arborescence et se représente par un “/”\n\nChemin absolu et chemin relatif\nPour indiquer la position d’un fichier (ou d’un répertoire) dans l’arborescence, il existe 2 méthodes : indiquer un chemin absolu ou indiquer un chemin relatif.\n\nLe chemin absolu doit indiquer “le chemin” depuis la racine. Par exemple le chemin absolu du fichier compte_rendu.odt sera : /home/marie/Documents/compte_rendu.odt\nRemarquez que nous démarrons bien de la racine / (attention les symboles de séparation sont aussi des /)\nLe chemin relatif indique le chemin non pas depuis la racine, mais depuis un répertoire quelconque : le chemin relatif permettant d’accéder au fichier “img_486.jpg” depuis le répertoire “home” est : “fabrice/Images/img_486.jpg”\nRemarquez l’absence du / au début du chemin (c’est cela qui nous permettra de distinguer un chemin relatif et un chemin absolu).\nImaginons maintenant que nous désirions indiquer le chemin relatif pour accéder au fichier “mon_film.mp4” depuis le répertoire “Documents”. Il faut “remonter” d’un “niveau” dans l’arborescence pour se retrouver dans le répertoire “marie” et ainsi pouvoir repartir vers la bonne “branche”. Pour ce faire il faut utiliser 2 points : ..\nOn écrira : “../Vidéos/mon_film.mp4”.\nIl est tout à fait possible de remonter de plusieurs “crans” : “../../” depuis le répertoire “Documents” permet de “remonter” dans le répertoire “home”.\n\nComme déjà évoqué plus haut, les systèmes de type “Unix” sont des systèmes “multi-utilisateurs” : chaque utilisateur possède son propre compte. Chaque utilisateur possède un répertoire à son nom, ces répertoires personnels se situent traditionnellement dans le répertoire “home”. Dans l’arborescence ci-dessus, nous avons 2 utilisateurs : “fabrice” et “marie”. Par défaut, quand un utilisateur ouvre une console, il se trouve dans son répertoire personnel.\n\n\n\n\n\n\nÀ retenir\n\n\n\nLe symbole ~ représente le dossier personnel de l’utilisateur connecté. Par exemple, si l’utilisateur “marie” est connecté, ~ représente /home/marie/.\n\n\nAttention : les systèmes de type “Unix” sont “sensibles à la casse” (il faut différencier les caractères majuscules et les caractères minuscules) : le répertoire “Documents” et le répertoire “documents” sont 2 répertoires différents.\nIl est important de savoir que si le double point (“../”) permet de remonter d’un cran dans l’arborescence, le simple point “./” représente le répertoire courant. Si vous vous trouvez dans le répertoire “home” un “./document” représente le répertoire “document” qui se trouve dans le répertoire “home”.\n\n\n\n\n\n\nTouche Tab\n\n\n\nDans un terminal, on peut compléter automatiquement une commande ou un chemin en utilisant la touche de tabulation. Par exemple, si vous tapez cd /home/fab puis que vous appuyez sur la touche de tabulation, le chemin sera complété automatiquement en cd /home/fabrice.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours"
    ]
  },
  {
    "objectID": "01_os/OS_cours.html#les-commandes-pour-manipuler-les-fichiers-et-les-répertoires",
    "href": "01_os/OS_cours.html#les-commandes-pour-manipuler-les-fichiers-et-les-répertoires",
    "title": "Cours",
    "section": "5. Les commandes pour manipuler les fichiers et les répertoires",
    "text": "5. Les commandes pour manipuler les fichiers et les répertoires\n\na. La commande cd\nLa commande cd permet de changer le répertoire courant (cd = change directory). Il suffit d’indiquer le chemin (relatif ou absolu) qui permet d’atteindre le nouveau répertoire.\nPar exemple (en utilisant l’arborescence ci-dessous) :\n\nsi le répertoire courant est le répertoire “marie” et que vous “voulez vous rendre” dans le répertoire “Documents”, il faudra saisir la commande : cd Documents (relatif) ou cd /home/marie/Documents (absolu).\nsi le répertoire courant est le répertoire “Documents” et que vous “voulez vous rendre” dans le répertoire “Vidéos”, il faudra saisir la commande : cd ../Vidéos (relatif) ou cd /home/marie/Vidéos (absolu)\nsi le répertoire courant est le répertoire “Images” et que vous “voulez vous rendre” dans le répertoire “fabrice”, il faudra saisir la commande : cd .. (relatif) ou cd /home/fabrice (absolu)\n\n\n\nb. La commande ls\nLa commande ls permet de lister le contenu du répertoire courant.\n\nDans l’exemple ci-dessus, depuis le répertoire personnel de l’utilisateur “fabrice”, nous passons dans le répertoire “Documents” à l’aide d’un cd Documents, puis nous affichons le contenu de ce répertoire “Documents” à l’aide de la commande ls. Nous trouvons dans le répertoire “Documents” : 3 fichiers (adresses.txt, Nouvelles.odt et screen.jpg) et deux répertoires (Travail et Loisirs).\n\n\nc. La commande pwd\nLa commande pwd permet de connaître le répertoire courant (permet d’afficher le chemin d’accès vers le répertoire courant depuis la racine, pwd = path to working directory).\n\n\nd. La commande mkdir\nLa commande mkdir permet de créer un répertoire dans le répertoire courant. La commande est de la forme mkdir nom_du_répertoire.\n\nRemarque : il est préférable de ne pas utiliser de caractères accentués dans les noms de répertoire (ou de fichier). Il en est de même pour les espaces (à remplacer par des caractères tirets bas “_“).\n\n\ne. La commande rm\nLa commande rm permet de supprimer un fichier ou un répertoire. La commande est de la forme rm nom_du_répertoire_ou_nom_du_fichier.\n\nLa plupart des commandes Linux peuvent être utilisées avec une ou des options. Par exemple, pour supprimer un répertoire non vide, il est nécessaire d’utiliser la commande rm avec l’option -r : rm -r nom_du_répertoire.\n\nEn fait l’option -r permet de supprimer un répertoire et ses sous répertoire.\nATTENTION : cette commande est relativement “dangereuse”, il faut donc la manipuler prudemment. Par exemple la commande rm * efface tous les fichiers du répertoire courant (le * signifie tous les fichiers et tous les répertoires). Pour effacer tous les fichiers et tous les répertoires présents dans le répertoire courant il faut donc utiliser rm -r *.\n\n\nf. La commande touch\nLa commande touch permet de créer un fichier vide. La commande est de la forme touch nom_du_fichier_à_créer.\n\n\n\ng. La commande cat\nLa commande cat permet d’afficher dans la console le contenu d’un fichier.\n\n\n\nh. La commande cp\nLa commande cp permet de copier un fichier. La commande est de la forme cp /répertoire_source/nom_fichier_à_copier /répertoire_destination/nom_fichier.\n\n\n\ni. La commande mv\nLa commande mv (move) permet de déplacer un fichier dans un répertoire. Par exemple un mv toto.txt titi déplacera le fichier toto.txt dans le répertoire titi (attention on parle bien de déplacement pas de copie). Elle permet aussi de renommer un fichier ou un répertoire s’il n’y a pas de déplacement.\n\n\nj. La commande man\nLa commande man permet d’obtenir la documentation d’une autre commande. Par exemple, man ls vous donnera la documentation de la commande ls dans laquelle vous apprendrez par exemple que l’option -l permet d’afficher les informations sur les fichiers et les répertoires sous forme de liste.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours"
    ]
  },
  {
    "objectID": "01_os/OS_cours.html#gestion-des-utilisateurs-et-des-groupes",
    "href": "01_os/OS_cours.html#gestion-des-utilisateurs-et-des-groupes",
    "title": "Cours",
    "section": "6. Gestion des utilisateurs et des groupes",
    "text": "6. Gestion des utilisateurs et des groupes\nLes systèmes de type “Unix” sont des systèmes multi-utilisateurs, plusieurs utilisateurs peuvent donc partager un même ordinateur, chaque utilisateur possédant un environnement de travail qui lui est propre.\nChaque utilisateur possède certains droits lui permettant d’effectuer certaines opérations et pas d’autres. Le système d’exploitation permet de gérer ces droits très finement. Un utilisateur un peu particulier est autorisé à modifier tous les droits : ce super utilisateur est appelé administrateur ou root. L’administrateur pourra donc attribuer ou retirer des droits aux autres utilisateurs. Au lieu de gérer les utilisateurs un par un, il est possible de créer des groupes d’utilisateurs. L’administrateur attribue des droits à un groupe au lieu d’attribuer des droits particuliers à chaque utilisateur.\nComme nous venons de le voir, chaque utilisateur possède des droits qui lui ont été octroyés par le “super utilisateur”. Nous nous intéresserons ici uniquement aux droits liés aux fichiers, mais vous devez savoir qu’il existe d’autres droits liés aux autres éléments du système d’exploitation (imprimante, installation de logiciels…).\nLes fichiers et les répertoires possèdent 3 types de droits :\n\nles droits en lecture (symbolisés par la lettre r pour Read) : est-il autorisé de lire le contenu de ce fichier ?\nles droits en écriture (symbolisés par la lettre w pour Write) : est-il autorisé de modifier le contenu de ce fichier ?\nles droits en exécution (symbolisés par la lettre x pour eXecute) : est-il autorisé d’exécuter le contenu de ce fichier (quand le fichier contient du code exécutable) ?\n\nIl existe 3 types d’utilisateurs pour un fichier ou un répertoire :\n\nle propriétaire du fichier (par défaut c’est la personne qui a créé le fichier), il est symbolisé par la lettre u (User) ;\nle groupe, tous les utilisateurs appartenant à ce groupe possèdent des droits particuliers sur ce fichier. Le groupe est symbolisé par la lettre g ;\nles autres utilisateurs (ceux qui ne sont pas le propriétaire du fichier et qui n’appartiennent pas au groupe associé au fichier). Ces utilisateurs sont symbolisés la lettre o (Other).\n\nIl est possible d’utiliser la commande ls avec l’option -l afin d’avoir des informations supplémentaires concernant les droits des fichiers.\n\nPrenons la première ligne :\n-rw-rw-r-- 1 fabrice fabrice     0 sept.  4 06:57 exercice.txt\nLisons cette ligne de gauche à droite :\n\nle premier symbole “-” signifie que l’on a affaire à un fichier, dans le cas d’un répertoire, nous aurions un “d” (voir la 2e ligne) ;\nles 3 symboles suivants “rw-”donnent les droits du propriétaire du fichier : lecture autorisée (r), écriture autorisée (w), exécution interdite (- à la place de x) ;\nles 3 symboles suivants “rw-”donnent les droits du groupe lié au fichier : lecture autorisée (r), écriture autorisée (w), exécution interdite (- à la place de x) ;\nles 3 symboles suivants “r–”donnent les droits des autres utilisateurs : lecture autorisée (r), écriture interdite (- à la place de w), exécution interdite (- à la place de x) ;\nle caractère suivant “1” donne le nombre de liens (nous n’étudierons pas cette notion ici) ;\nle premier “fabrice” représente le nom du propriétaire du fichier ;\nle second “fabrice” représente le nom du groupe lié au fichier ;\nle “0” représente la taille du fichier en octet (ici notre fichier est vide) ;\n“sept. 4 06:57” donne la date et l’heure de la dernière modification du fichier ;\n“exercice.txt” est le nom du fichier.\n\nPrenons la deuxième ligne :\ndrwxrwxr-x 2 fabrice fabrice  4096 sept.  4 06:48 Loisirs\nLisons cette ligne de gauche à droite :\n\nle premier symbole “d” signifie que l’on a un répertoire ;\nles 3 symboles suivants “rwx” donnent les droits du propriétaire du répertoire : lecture du contenu du répertoire autorisée (r), modification du contenu du répertoire autorisée (w), il est possible de parcourir le répertoire (voir le contenu du répertoire) (x) ;\nles 3 symboles suivants “rwx” donnent les mêmes droits au groupe lié au répertoire ;\nles 3 symboles suivants “r-x”donnent les droits des autres utilisateurs : modification du contenu du répertoire interdite (- à la place de w) ;\nle caractère suivant “2” donne le nombre de liens (nous n’étudierons pas cette notion ici) ;\nle premier “fabrice” représente le nom du propriétaire du répertoire ;\nle second “fabrice” représente le nom du groupe lié au répertoire ;\nle “4096” représente la taille du répertoire en octets ;\n“sept. 4 06:48” donne la date et l’heure de la dernière modification du contenu du répertoire ;\n“Loisirs” est le nom du répertoire\n\nIl est important de ne pas perdre de vue que l’utilisateur root a la possibilité de modifier les droits de tous les utilisateurs.\nLe propriétaire d’un fichier peut modifier les permissions d’un fichier ou d’un répertoire à l’aide de la commande chmod. Pour utiliser cette commande, il est nécessaire de connaître certains symboles :\n\nles symboles liés aux utilisateurs : “u” correspond au propriétaire, “g” correspond au groupe lié au fichier (ou au répertoire), “o” correspond aux autres utilisateurs et “a” correspond à “tout le monde” (all : permet de modifier “u”, “g” et “o” en même temps) ;\nles symboles liés à l’ajout ou la suppression des permissions : “+” on ajoute une permission, “-” on supprime une permission, “=” les permissions sont réinitialisées (permissions par défaut) ;\nles symboles liés aux permissions : “r” : lecture, “w” : écriture, “x” : exécution.\n\nLa commande chmod à cette forme :\nchmod [u g o a] [+ - =] [r w x] nom_du_fichier\npar exemple\nchmod o+w toto.txt\nattribuera la permission “écriture” pour le fichier “toto.txt” aux autres utilisateurs.\nIl est possible de combiner les symboles :\nchmod g-wx toto.txt\nLa commande chmod ci-dessus permet de supprimer la permission “écriture” et la permission “exécution” pour le fichier toto.txt au groupe lié au fichier.\nUne fois de plus, “root” a tous les droits sur l’ensemble des fichiers et des répertoires, il peut donc utiliser la commande chmod sur tous les répertoires et tous les fichiers.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours"
    ]
  },
  {
    "objectID": "01_os/quiz.html",
    "href": "01_os/quiz.html",
    "title": "Questionnaire : avez-vous bien étudié le cours ?",
    "section": "",
    "text": "Quel est le rôle des applications dans un système informatique ?\n\n\nFaire l’interface entre le matériel et l’utilisateur\nOffrir des fonctionnalités adaptées aux besoins des utilisateurs\nIsoler le code utilisateur du matériel\n\n\nPourquoi est-il important d’isoler le code utilisateur du matériel ?\n\n\nPour permettre de changer le matériel de façon transparente pour l’utilisateur\nPour assurer l’intégrité des données\nPour permettre à tous les programmes de s’exécuter de façon équitable\n\n\nQuel est le rôle de l’Unité Centrale (UC) dans un ordinateur ?\n\n\nStocker les données\nTraiter les informations\nAssurer la communication avec les périphériques\n\n\nQu’est-ce que les pilotes de périphériques ?\n\n\nDes logiciels permettant de stocker des données\nDes logiciels permettant de traiter les informations\nDes logiciels permettant de communiquer avec les périphériques\n\n\nQuelle est la différence entre un OS propriétaire et un OS libre ?\n\n\nUn OS propriétaire est gratuit, tandis qu’un OS libre est payant\nUn OS propriétaire est développé par une communauté de développeurs, tandis qu’un OS libre est développé par une entreprise\nUn OS propriétaire est soumis à des restrictions d’utilisation, tandis qu’un OS libre peut être utilisé, modifié et distribué librement\n\n\nQuel est le premier logiciel qui démarre lorsqu’on allume un ordinateur ?\n\n\nUne application\nUn système d’exploitation\nUn pilote de périphérique\n\n\nComment était fourni le système d’exploitation des ordinateurs personnels dans les années 80-90 du 20ᵉ siècle ?\n\n\nSur un disque dur\nSur une disquette de démarrage\nSur une clé USB\n\n\nQuelle est la différence entre un chemin absolu et un chemin relatif ?\n\n\nUn chemin absolu indique le chemin depuis la racine, tandis qu’un chemin relatif indique le chemin depuis un répertoire quelconque\nUn chemin absolu indique le chemin depuis un répertoire quelconque, tandis qu’un chemin relatif indique le chemin depuis la racine\nUn chemin absolu est utilisé pour accéder à un fichier, tandis qu’un chemin relatif est utilisé pour accéder à un répertoire\n\n\nComment indiquer le chemin absolu d’un fichier dans l’arborescence ?\n\n\nEn indiquant le chemin depuis un répertoire quelconque\nEn indiquant le chemin depuis la racine\nEn utilisant des points pour remonter dans l’arborescence\n\n\nComment indiquer le chemin relatif pour accéder à un fichier depuis un répertoire quelconque ?\n\n\nEn indiquant le chemin depuis la racine\nEn utilisant des points pour remonter dans l’arborescence\nEn indiquant le chemin depuis le répertoire courant\n\n\nSupposons que vous ayez un fichier nommé “mon_cv.pdf” dans le répertoire “Documents” de votre compte utilisateur “pierre”. Quel est le chemin absolu pour accéder à ce fichier ?\n\n\n/home/pierre/Documents/mon_cv.pdf\n/Documents/pierre/mon_cv.pdf\n/pierre/Documents/mon_cv.pdf\n\n\nSupposons que vous soyez dans le répertoire “Images” et que vous vouliez accéder au fichier “photo.jpg” qui se trouve dans le répertoire “Vacances” qui est lui-même dans le répertoire “Documents”. Les répertoires “Images” et “Documents” sont tous les deux situés dans votre dossier utilisateur. Quel est le chemin relatif pour accéder à ce fichier ?\n\n\n../Documents/Vacances/photo.jpg\n../Vacances/Documents/photo.jpg\n../Documents/photo.jpg/Vacances\n\n\nSupposons que vous soyez dans le répertoire “Musique” et que vous vouliez accéder au fichier “mon_film.mp4” qui se trouve dans le répertoire “Vidéos”. Les dossiers “Musique” et “Vidéos” sont tous les deux dans le répertoire “marie”. Quel est le chemin absolu et le chemin relatif pour accéder à ce fichier ?\n\n\nChemin absolu : /home/marie/Vidéos/mon_film.mp4 ; Chemin relatif : ../../marie/Vidéos/mon_film.mp4\nChemin absolu : /home/Vidéos/marie/mon_film.mp4 ; Chemin relatif : ../../marie/Vidéos/mon_film.mp4\nChemin absolu : /home/marie/musique/Vidéos/mon_film.mp4 ; Chemin relatif : ../../marie/Vidéos/mon_film.mp4\n\n\nQue permet de faire la commande “cd” ?\n\n\nElle permet de créer un répertoire\nElle permet de supprimer un fichier\nElle permet de changer le répertoire courant\n\n\nComment utiliser la commande “cd” pour accéder au répertoire “Documents” depuis le répertoire personnel de l’utilisateur “pierre” ?\n\n\ncd /Documents/pierre\ncd Documents/pierre\ncd /home/pierre/Documents\n\n\nQue permet de faire la commande “ls” ?\n\n\nElle permet de créer un répertoire\nElle permet de supprimer un fichier\nElle permet d’afficher le contenu d’un répertoire\n\n\nQue permet de faire la commande “pwd” ?\n\n\nElle permet de connaître le répertoire courant\nElle permet de créer un répertoire\nElle permet de supprimer un fichier\n\n\nQue permet de faire la commande “mkdir” ?\n\n\nElle permet de créer un fichier\nElle permet de supprimer un répertoire\nElle permet de créer un répertoire\n\n\nSupposons que vous soyez dans le répertoire “Documents” et que vous vouliez accéder au répertoire “Images” qui se trouve dans le répertoire “pierre”. Quelle commande “cd” devez-vous utiliser ?\n\n\ncd /pierre/Images\ncd Images/pierre\ncd /home/pierre/Images\n\n\nSupposons que vous soyez dans le répertoire “Musique” et que vous vouliez afficher le contenu du répertoire “Photos” qui se trouve dans le répertoire “pierre”. Quelle commande “ls” devez-vous utiliser ?\n\n\nls /pierre/Photos\nls Photos/pierre\nls /home/pierre/Photos\n\n\nSupposons que vous vouliez créer un répertoire nommé “Photos” dans le répertoire “pierre”. Quelle commande “mkdir” devez-vous utiliser ?\n\n\nmkdir /pierre/Photos\nmkdir Photos/pierre\nmkdir /home/pierre/Photos\n\n\nSupposons que vous vouliez supprimer le fichier “mon_fichier.txt” qui se trouve dans le répertoire “Documents” de votre compte utilisateur “pierre”. Quelle commande “rm” devez-vous utiliser ?\n\n\nrm /home/pierre/Documents/mon_fichier.txt\nrm Documents/pierre/mon_fichier.txt\nrm /pierre/Documents/mon_fichier.txt\n\n\nQu’est-ce qu’un système multi-utilisateurs ?\n\n\nUn système qui permet à plusieurs ordinateurs de travailler ensemble\nUn système qui permet à plusieurs utilisateurs de partager un même ordinateur\nUn système qui permet à un utilisateur de se connecter à plusieurs ordinateurs en même temps\n\n\nQu’est-ce qu’un super utilisateur ?\n\n\nUn utilisateur qui a des droits limités sur le système\nUn utilisateur qui peut modifier tous les droits sur le système\nUn utilisateur qui ne peut pas se connecter au système\n\n\nComment peut-on gérer les droits des utilisateurs sur un système d’exploitation ?\n\n\nEn créant des groupes d’utilisateurs\nEn attribuant des droits particuliers à chaque utilisateur\nLes deux réponses précédentes sont correctes\n\n\nQuelle est la commande pour obtenir la documentation d’une autre commande ?\n\n\ncd\nls\nman\n\n\nSupposons que vous soyez l’utilisateur “marie” et que vous vouliez modifier le contenu du fichier “mon_fichier.txt” qui se trouve dans le répertoire “Documents”. Cependant, vous n’avez pas les droits en écriture sur ce fichier. Comment pouvez-vous obtenir ces droits ?\n\n\nEn demandant à l’administrateur de vous les attribuer\nEn modifiant les droits du fichier avec la commande “chmod”\nEn copiant le fichier dans votre répertoire personnel et en modifiant la copie\n\n\nSupposons que vous exécutiez la commande “ls -l” dans le répertoire “Documents” de votre compte utilisateur et que vous obteniez le résultat suivant pour le fichier “mon_fichier.txt” : -rw-r–r– 1 marie marie 1024 sept. 10 14:30 mon_fichier.txt Quels sont les droits de lecture, d’écriture et d’exécution pour l’utilisateur “marie” sur ce fichier ?\n\n\nLecture et écriture\nLecture seulement\nLecture, écriture et exécution\n\n\nSupposons que vous exécutiez la commande “ls -l” dans le répertoire “Images” de votre compte utilisateur et que vous obteniez le résultat suivant pour le fichier “photo.jpg” : -rwxr-x— 1 pierre amis 2048 sept. 10 15:00 photo.jpg Quels sont les droits de lecture, d’écriture et d’exécution pour le groupe “amis” sur ce fichier ?\n\n\nLecture seulement\nLecture et exécution\nLecture, écriture et exécution\n\n\nSupposons que vous exécutiez la commande “ls -l” dans le répertoire “Musique” de votre compte utilisateur et que vous obteniez le résultat suivant pour le fichier “chanson.mp3” : -rw-rw—- 1 marie amis 4096 sept. 10 16:00 chanson.mp3 Quels sont les droits de lecture, d’écriture et d’exécution pour les autres utilisateurs (ceux qui ne sont ni l’utilisateur “marie” ni membres du groupe “amis”) sur ce fichier ?\n\n\nLecture seulement\nLecture et écriture\nAucun droit"
  },
  {
    "objectID": "02_python/python_bases.html",
    "href": "02_python/python_bases.html",
    "title": "Variables et types",
    "section": "",
    "text": "Python est un langage de programmation, il s’agit donc d’un ensemble d’instructions qui va nous permettre d’écrire des programmes informatiques.\nUn programme est une suite d’instructions données à un ordinateur afin qu’il effectue une tâche déterminée.\nNous prendrons garde à différencier les termes programme et algorithme. Observons pour cela les définitions données dans l’encyclopédie Wikipedia :\n\n algorithme\n\nUn algorithme est une suite finie et non ambiguë d’instructions et d’opérations permettant de résoudre un type de problèmes.\n\n programme informatique\n\nUn programme informatique est un ensemble d’instructions et d’opérations destinées à être exécutées par un ordinateur.\n\n\nUn algorithme ne relève donc pas a priori du domaine de l’informatique. Cependant, la plupart des programmes informatiques sont la traduction d’un algorithme dans un certain langage de programmation.\nRemarquons enfin que le mot algorithme vient d’Al-Khwârizmî (en arabe : الخوارزمي), nom d’un mathématicien persan du IXe siècle.\nIl existe de nombreux langages de programmation et, même en utilisant un même langage, un algorithme peut être programmé de différentes façons. Un algorithme donné peut donc correspondre à de très nombreux programmes informatiques différents.\nCependant, un ordinateur n’est qu’une machine électrique qui ne peut directement comprendre que des suites d’instructions exprimées en langage machine par des suites de 0 et de 1. Le rôle d’un langage de programmation est de fournir au programmeur une syntaxe et une grammaire pour lui permettre d’exprimer des instructions de manière plus facilement compréhensible pour un être humain. Ce programme est ensuite traduit en langage machine puis exécuté.\nCette traduction est faite, suivant les langages, par un compilateur (programme qui crée un fichier exécutable à partir du code source) ou par un interpréteur (programme qui lit, traduit et exécute immédiatement une à une les instructions du code source).\nEn NSI, nous allons nous focaliser sur le langage Python.\n\nLe langage Python a été créé en 1989 par l’informaticien néerlandais Guido van Rossum qui l’a nommé ainsi en hommage à la série télévisée des Monty Python dont il était fan.\n\n\n\nGuido van Rossum",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#introduction",
    "href": "02_python/python_bases.html#introduction",
    "title": "Variables et types",
    "section": "",
    "text": "Python est un langage de programmation, il s’agit donc d’un ensemble d’instructions qui va nous permettre d’écrire des programmes informatiques.\nUn programme est une suite d’instructions données à un ordinateur afin qu’il effectue une tâche déterminée.\nNous prendrons garde à différencier les termes programme et algorithme. Observons pour cela les définitions données dans l’encyclopédie Wikipedia :\n\n algorithme\n\nUn algorithme est une suite finie et non ambiguë d’instructions et d’opérations permettant de résoudre un type de problèmes.\n\n programme informatique\n\nUn programme informatique est un ensemble d’instructions et d’opérations destinées à être exécutées par un ordinateur.\n\n\nUn algorithme ne relève donc pas a priori du domaine de l’informatique. Cependant, la plupart des programmes informatiques sont la traduction d’un algorithme dans un certain langage de programmation.\nRemarquons enfin que le mot algorithme vient d’Al-Khwârizmî (en arabe : الخوارزمي), nom d’un mathématicien persan du IXe siècle.\nIl existe de nombreux langages de programmation et, même en utilisant un même langage, un algorithme peut être programmé de différentes façons. Un algorithme donné peut donc correspondre à de très nombreux programmes informatiques différents.\nCependant, un ordinateur n’est qu’une machine électrique qui ne peut directement comprendre que des suites d’instructions exprimées en langage machine par des suites de 0 et de 1. Le rôle d’un langage de programmation est de fournir au programmeur une syntaxe et une grammaire pour lui permettre d’exprimer des instructions de manière plus facilement compréhensible pour un être humain. Ce programme est ensuite traduit en langage machine puis exécuté.\nCette traduction est faite, suivant les langages, par un compilateur (programme qui crée un fichier exécutable à partir du code source) ou par un interpréteur (programme qui lit, traduit et exécute immédiatement une à une les instructions du code source).\nEn NSI, nous allons nous focaliser sur le langage Python.\n\nLe langage Python a été créé en 1989 par l’informaticien néerlandais Guido van Rossum qui l’a nommé ainsi en hommage à la série télévisée des Monty Python dont il était fan.\n\n\n\nGuido van Rossum",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#variables-et-affectation",
    "href": "02_python/python_bases.html#variables-et-affectation",
    "title": "Variables et types",
    "section": "2. Variables et affectation",
    "text": "2. Variables et affectation\nDans un programme, on utilise des variables pour stocker des données.\nUne variable est déterminée par un nom de variable que l’on peut librement choisir. Il est néanmoins conseillé de choisir un nom court et auto-descriptif afin de comprendre à la lecture le rôle de cette variable.\nUn nom de variable ne peut pas commencer par un chiffre et ne doit pas contenir de caractères spéciaux autres que “_” ou d’espace.\nIl est conseillé d’utiliser plutôt des lettres minuscules, en séparant les mots par le caractère ”_” ou en utilisant des majuscules à l’intérieur du nom. Une variable prévue pour contenir un prix de revient pourra par exemple être nommée prix_de_revient ou prixDeRevient. Des recommandations précises de style de programmation Python sont rassemblées à cette adresse : https://peps.python.org/pep-0008/.\n\n\n\n\n\n\nÀ retenir\n\n\n\nPour affecter une valeur à une variable, on utilise simplement le signe ”=”.\n\n\nL’instruction pi = 3.14 a pour effet de :\n\ncréer le nom de variable pi dans la mémoire de l’ordinateur ;\ncréer la valeur 3.14 dans la mémoire de l’ordinateur ;\nétablir un lien entre le nom pi et l’emplacement de la valeur 3.14 dans la mémoire de l’ordinateur.\n\nOn dira donc qu’une variable est l’association d’un nom et d’une valeur\nEn mode interactif, il suffit de taper le nom d’une variable et de valider pour afficher sa valeur. En mode programme, on utilisera la fonction print() pour afficher le contenu d’une variable à l’exécution.\nIl est possible d’affecter des valeurs à plusieurs variables simultanément.\nLa commande a, b, c = 2, 2.5, \"toto\" affecte par exemple la valeur 2 à la variable a, la valeur 2.5 à la variable b et la valeur ”toto” à la variable c . Ces trois variables sont de types différents : a est un entier, b est un nombre à virgule et c est une chaîne de caractères.\nLors de la définition d’une variable, ou lors d’une nouvelle affectation, python détecte automatiquement le type de variable à définir en fonction de la valeur affectée. On parle de typage dynamique. D’autres langages de programmation imposent que les noms des variables et leur type soient déclarés avant toute affectation : on parle alors de typage statique.\nLa fonction type() permet de connaître le type d’une variable déjà définie.\n\n\n\n\n\n\nÀ retenir\n\n\n\nLes types de base sont :\n\ntype int : ce sont les nombres entiers (integer). Ils supportent les opérations +, −, *, /, ** (puissance), // (quotient entier), % (reste entier), abs() (valeur absolue) ;\ntype float : ce sont les nombres à virgule (on parle de virgule flottante), qui supportent les opérations usuelles ;\ntype string : ce sont les chaines de caractères.\n\n\n\nRemarque : on peut effectuer un calcul et en même temps affecter le résultat à une variable, ou en même temps afficher le résultat en composant les instructions. Par exemple, la commande prix = 64 * (1 + 19.6 / 100) effectue d’abord le calcul indiqué après le signe =, puis affecte le résultat à la variable prix. On peut aussi exécuter la commande print(\"Le prix est : \", 64 * (1 + 19.6 / 100)).\nRemarque : en Python, il est très facile d’échanger le contenu de deux variables, en utilisant une double affectation :\npython linenums=\"1\" a = \"Bonjour\" b = \"NSI\" a, b = b, a\nAprès l’exécution de ces trois lignes, la variable a renvoie la valeur \"NSI\" et b correspond à \"Bonjour\".\n\n\n\n\n\n\nMéthode utile\n\n\n\nPour bien comprendre un programme, on peut dresser un tableau d’état dans lequel on affiche les valeurs successives des variables.\nLe tableau d’état du programme ci-dessus s’écrit :\n\n\n\nEtape\na\nb\n\n\n\n\n1\n\"Bonjour\"\n\n\n\n2\n\"Bonjour\"\n\"NSI\"\n\n\n3\n\"NSI\"\n\"Bonjour\"",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#opérations-sur-les-chaînes-de-caractères",
    "href": "02_python/python_bases.html#opérations-sur-les-chaînes-de-caractères",
    "title": "Variables et types",
    "section": "3. Opérations sur les chaînes de caractères",
    "text": "3. Opérations sur les chaînes de caractères\nL’utilisation du signe + ne se limite pas à l’addition. Appliqué à des chaînes de caractères, il réalise l’opération de concaténation.\n\n Concaténation\n\nLe terme concaténation (substantif féminin), du latin cum («avec») et catena («chaîne, liaison»), désigne l’action de mettre bout à bout au moins deux chaînes. (Wikipédia)\n\n\nSi on considère le programme suivant :\na = \"Hello\"\nb = \"World\"\nmon_expression = a + b\naprès l’exécution de ce programme, la variable mon_expression aura pour valeur \"HelloWorld\".\nIl est aussi possible de concaténer une chaîne de caractères et une ou plusieurs variables de type str :\nma_chaine_1 = \"Bonjour \"\nma_chaine_2 = \"le \"\nres = ma_chaine_1 + ma_chaine_2 + \"monde !\"\nAprès l’exécution de ce programme, la variable res aura pour valeur \"Bonjour le  monde !.\nLes deux noms ma_chaine_1 et ma_chaine_2 sont associés à deux chaînes de caractères, nous avons donc bien ici une concaténation.\nQue se passe-t-il si nous avons ce cas de figure :\na = \"Nombre de pommes : \"\nb = 4 \nc = a + b\na est de type str, alors que b est de type int. Le signe + représente une addition ou une concaténation ? Ni l’un, ni l’autre, puisque Python vous renverra une erreur : il ne peut pas concaténer, ni additionner un entier et une chaîne de caractère.\nLa solution : transformer le nombre 4 en caractère 4 à l’aide de la fonction str() :\na = \"Nombre de pommes : \"\nb = 4 \nc = a + str(b)\nNous avons maintenant une concaténation, car str(4) est de type string.\nAutre solution pour faire cohabiter des variables de type int ou float avec des variables de type str : les fstring (attention les fstring sont uniquement disponibles à partir de Python 3.5)\nIl est possible d’écrire :\na = \"Nombre de pommes :\"\nb = 4 \nc = f\"{a} {b}\"\naprès l’exécution du programme ci-dessus, la variable c aura pour valeur \"Nombre de pommes : 4\".\nDans la chaîne de caractère, {a} sera remplacé par la valeur de la variable a, c’est-à-dire \"Nombre de pommes :\". Même chose avec {b} qui sera remplacé par la valeur de b, c’est-à-dire 4.\nAutre exemple d’utilisation des fstring :\nnum_train = 4232\ndest = \"Paris\" \nc = f\"Le train n°{num_train} à destination de {dest} entre en gare\" \nAprès l’exécution du programme ci-dessus, la variable c aura pour valeur \"Le train n°4232 à destination de Paris entre en gare\".\nNotez la présence du “f” juste avant le guillemet et des accolades qui encadrent le nom de la variable. Il est nécessaire d’ajouter ce “f” pour avoir une fstring.\n\n\n\n\n\n\nEntrées utilisateurs avec input()\n\n\n\nLa fonction input() permet de demander à l’utilisateur d’entrer une valeur dans la console et de récupérer cette valeur en l’affectant à une variable.\nOn pourra par exemple tester le script suivant :\nnom = input(\"Quel est votre nom ? : \")\nprint(\"Bonjour\", nom, \" ! \")\nUne erreur courante consiste à demander l’entrée d’une valeur numérique et à l’utiliser directement dans un calcul. Le script suivant, par exemple :\nrayon = input(\"Entrer le rayon du cercle : \")\nperi = 2 * 3.14 * rayon\nprint(\"La longueur du cercle est :\", peri)\nconduit à :\nTypeError: can't multiply sequence by non-int of type 'float'\nLa fonction input() retourne toujours une chaîne de caractères. Pour une entrée numérique, cette chaîne de caractère doit être évaluée, par exemple avec la fonction eval() qui retournera un type numérique int ou float selon les cas.\nLe script ci-dessous produit le résultat attendu :\nrayon = eval(input(\"Entrer le rayon du cercle : \"))\nperi = 2 * 3.14 * rayon\nprint(\"La longueur du cercle est :\", peri)\n\n\n\n\n\n\n\n\nExercices\n\n\n\n Fiche d’exercices sur les variables, les affectations et les chaînes de caractères.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#booléens",
    "href": "02_python/python_bases.html#booléens",
    "title": "Variables et types",
    "section": "4. Booléens",
    "text": "4. Booléens\nPour l’instant nous avons vu deux grands types de données : les nombres (entier ou flottant) et les chaînes de caractères, il existe un troisième type tout aussi important que les deux premiers : les booléens. Un booléen est un type de données qui ne peut prendre que deux valeurs : vrai (True) ou faux (False). Une expression est soit True, soit False.\nLes opérateurs de comparaison renvoient des booléens.\n\n\n\n\n\n\nOpérateurs de comparaison\n\n\n\n\na == 0 : teste si a est égal à 0 ;\na != 0 : teste si a est différent de 0 ;\na &lt; 0 : teste si a est strictement inférieur à 0 ;\na &gt; 0 : teste si a est strictement supérieur à 0 ;\na &lt;= 0 : teste si a est inférieur ou égal à 0 ;\na &gt;= 0 : teste si a est supérieur ou égal à 0.\n\n\n\n\n\n\n\n\n\nATTENTION\n\n\n\nNotez le double égal == qui permet de distinguer un test d’égalité d’une affectation (association d’une valeur à un nom (variable)). Le fait de confondre le “simple égal” et le “double égal” est une erreur classique qu’il faut éviter.\n\n\nIl est aussi possible de combiner plusieurs opérateurs booléens grâce aux opérateurs logiques or et and. On peut représenter le fonctionnement de ces opérateurs dans un tableau, appelé table de vérité :\nTable de vérité pour or\n\n\n\nexp1\nexp2\nexp1 or exp2\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\n\n\n\nTable de vérité pour and\n\n\n\nexp1\nexp2\nexp1 and exp2\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nFalse\nFalse\nFalse\n\n\n\nOn trouve aussi not comme opérateur logique de négation avec la table de vérité suivante :\n\n\n\nexp\nnot (exp)\n\n\n\n\nTrue\nFalse\n\n\nFalse\nTrue\n\n\n\n\n\n\n\n\n\nAttention !\n\n\n\nOn peut combiner des opérateurs arithmétiques, de comparaison et logiques pour créer des expressions booléennes complexes. Il faut prêter attention aux règles de priorité. Les parenthèses sont prioritaires sur tous les autres opérateurs donc on peut les utiliser quand on n’est pas certain des règles de priorité ou pour s’en affranchir.\n\n\nNous reviendrons sur les booléens en cours d’année dans un chapitre ultérieur.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#instructions-conditionnelles",
    "href": "02_python/python_bases.html#instructions-conditionnelles",
    "title": "Variables et types",
    "section": "5. Instructions conditionnelles",
    "text": "5. Instructions conditionnelles\nDans les scripts précédents, les séquences d’instructions sont exécutées ligne après ligne, dans l’ordre où elles sont écrites, suivant un organigramme simple du type ci-dessous.\n\nUne instruction conditionnelle permet d’indiquer à python de ne pas exécuter une suite de commandes dans l’ordre où elles sont écrites, mais de suivre différents chemins selon les circonstances.\nL’idée de base est la suivante :\nif test:\n    instruction1\nelse:\n    instruction2\nSi “test” est True alors “instruction1” est exécutée et “instruction2” est ignorée.\nSinon (sous-entendu que “test” est False) “instruction2” est exécutée et “instruction1” est ignorée.\n\nPlusieurs conditions peuvent être testées : on utilise pour cela le mot-clef elif, contraction de else if :\nif test1:\n    instruction1\nelif test2:\n    instruction2\nelif test3:\n    instruction3\nelse:\n    instruction4\nDans ce cas, si test1 est True, instruction1 est exécutée et tout le reste est ignoré. Sinon, si test2 est True, alors instruction2 est exécutée et tout le reste est ignoré. Si test1 et test2 sont False et test3 True, alors instruction3 est exécutée. Si les trois tests sont False, c’est instruction4 qui est exécutée.\n\n\n\n\n\n\n\nRemarques\n\n\n\n\nSeul if est nécessaire dans une instruction conditionnelle. Les commandes elif et else sont optionnelles.\nLe bloc d’instructions conditionnelles est introduit par une ligne se terminant par une instruction if, elif ou else suivie d’un double point.\nCe bloc est délimité par une indentation spécifique : décalage de 4 espaces vers la droite.\nDans tout éditeur de programme digne de ce nom, cette indentation se fait automatiquement quand on tape “Entrée” à la fin d’une ligne se terminant par un double point.\n\n\n\nSi on considère le programme suivant :\na = 4\nb = 7\nif a &lt; b:\n    print(\"Je suis toto.\");\n    print(\"Je n'aime pas titi.\")\nelse:\n    print(\"Je suis titi.\")\n    print(\"Je n'aime pas toto.\")\nprint(\"En revanche, j'aime le Python.\")\nnous avons a &lt; b qui est True, nous allons donc exécuter les 2 lignes\nprint(\"Je suis toto.\");\nprint(\"Je n'aime pas titi.\")\nles lignes\nprint(\"Je suis titi.\")\nprint(\"Je n'aime pas toto.\")\nseront ignorées.\nEn revanche la ligne\nprint(\"En revanche, j'aime le Python.\")\nsera systématiquement exécutée.\nL’exécution de ce programme permettra d’afficher à l’écran :\nJe suis toto.\nJe n'aime pas titi.\nEn revanche, j'aime le Python.\nSi maintenant on considère ce programme :\na = 8\nb = 7\nif a &lt; b:\n    print(\"Je suis toto.\");\n    print(\"Je n'aime pas titi.\")\nelse:\n    print(\"Je suis titi.\")\n    print(\"Je n'aime pas toto.\")\nprint(\"En revanche, j'aime le Python.\")\nL’exécution de ce programme entraînera l’affichage suivant :\nJe suis titi.\nJe n'aime pas toto.\nEn revanche, j'aime le Python.\n\n\n\n\n\n\nExercices\n\n\n\n Fiche d’exercices sur les instructions conditionnelles.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#boucle-conditionnelle",
    "href": "02_python/python_bases.html#boucle-conditionnelle",
    "title": "Variables et types",
    "section": "6. Boucle conditionnelle",
    "text": "6. Boucle conditionnelle\nLa notion de boucle est fondamentale en informatique. Une boucle permet d’exécuter plusieurs fois des instructions qui ne sont présentes qu’une seule fois dans le code.\nDeux types de boucles sont à distinguer : la boucle conditionnelle, introduite par le mot-clef while et le boucle bornée, introduite par le mot-clef for.\nLa structure de la boucle while est la suivante :\nwhile expression:\n    instruction1\n    instruction2\nsuite programme\nTant que expression sera True, on exécutera encore et encore instruction1 et instruction2. Après chaque exécution de instruction1 et instruction2 (on dit souvent “après chaque tour de boucle”), expression sera de nouveau évaluée (pour savoir si elle est toujours True ou si elle est devenue False)\nQuand expression deviendra False on passera directement à suite programme (sans entrer de nouveau dans la boucle), la boucle sera terminée.\n\nQue se passe-t-il si expression ne devient jamais False ? On entre alors dans une boucle “infinie” : c’est une erreur classique en programmation (aucun programme “bien fait” ne tombe dans une boucle infinie, s’il y a une boucle infinie, c’est qu’il y a forcément une erreur dans votre programme). C’est la raison pour laquelle on n’appelle pas ces boucles des boucles non bornées : en effet, une boucle while est bornée, mais on ne sait pas à l’avance combien de fois on va passer dans la boucle. Ce nombre de passages dans la boucle dépend de l’évaluation de expression.\nConsidérons le programme suivant :\ni = 0\nwhile i &lt; 3  :\n    print(i)\n    i = i + 1\nprint(\"FIN\")\nVoici comment analyser ce programme :\n\nAu début de l’exécution de ce programme nous avons la variable i qui a pour valeur 0.\nNous arrivons ensuite au niveau du while : l’expression i &lt; 3 est True, on “entre” donc dans la boucle : on affiche la valeur de i : 0 et on incrémente i de 1 (i a maintenant pour valeur 1)\nNous passons au 2e tour de boucle : l’expression i &lt; 3 est True, on “entre” donc dans la boucle : on affiche la valeur de i : 1 et on incrémente i de 1 (i a maintenant pour valeur 2).\nNous passons au 3e tour de boucle : l’expression i &lt; 3 est True, on “entre” donc dans la boucle : on affiche la valeur de i : 2 et on incrémente i de 1 (i a maintenant pour valeur 3).\nNous passons au 4e tour de boucle : l’expression i &lt; 3 est False (3 n’est pas strictement inférieur à 3), on n’entre pas dans la boucle et on passe à l’instruction qui suit immédiatement la boucle : on exécute print(\"FIN\") et le programme s’arrête (il n’y a plus d’instruction après)\n\nAprès l’exécution de ce programme, nous aurons à l’écran :\n0\n1\n2\nFIN\nIl est très important que vous soyez capable d’effectuer l’analyse d’un programme comme nous venons de la faire ci-dessus, cela vous permettra d’éviter beaucoup d’erreurs. Cette analyse peut se faire à l’aide d’un tableau d’état (étape 0 : initialisation, étape 1 : état du programme après le premier passage dans la boucle):\n\n\n\nEtape\ni\ni&lt;3\n\n\n\n\n0\n0\nTrue\n\n\n1\n1\nTrue\n\n\n2\n2\nTrue\n\n\n3\n3\nFalse",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#boucle-bornée",
    "href": "02_python/python_bases.html#boucle-bornée",
    "title": "Variables et types",
    "section": "7. Boucle bornée",
    "text": "7. Boucle bornée\nUne boucle bornée for peut être utilisée lorsque l’on connaît le nombre d’itérations au moment de la programmation.\nLa structure de la boucle for est la suivante :\nfor truc in machin:\n    instruction1\n    instruction2\nsuite programme\nLes instructions instruction1 et instruction2 sont exécutées autant de fois qu’il y a de truc dans machin. machin doit être un objet itérable, c’est-à-dire à partir duquel on peut générer une suite de valeurs bien déterminées. Pour l’instant, nous nous contenterons de deux situations :\n\nitération sur une chaîne de caractère : la variable truc prend alors successivement pour valeur tous les caractères de la chaîne machin ;\n\nfor lettre in \"ciao\":\n    print(lettre)\n\nitération sur une séquence d’entiers générée par la fonction range() : par exemple si machin est range(10), alors truc prendra successivement toutes les valeurs entières de 0 à 9.\n\nfor i in range(5):\n    print(3*i)\n\n\n\n\n\n\nUtilisation de la fonction range()\n\n\n\n\nrange(n) génère une séquence de nombres entiers en commençant par 0 et jusqu’à \\(n\\) exclu ;\nrange(k, n) génère une séquence de nombres entiers en commençant par \\(k\\) et jusqu’à \\(n\\) exclu ;\nrange(k, n, p)génère une séquence de nombres entiers en commençant par \\(k\\) et jusqu’à \\(n\\) exclu, avec un pas de \\(p\\) ;\n\n\n\nSi \\(p\\) est négatif et \\(k&gt;n\\), on peut définir une séquence décroissante d’entiers.\nRemarques\n\nUne boucle for peut toujours être remplacée par une boucle while. Le programme suivant est équivalent au précédent :\n\ni = 0\nwhile i&lt;5:\n    print(3*i)\n    i = i + 1\n\nLa réciproque est fausse : pourquoi ?\nLes boucles peuvent être imbriquées. Par exemple, le programme ci-dessous affichera la liste des couples d’entiers \\((i;j)\\) avec \\(0\\leqslant i&lt;j\\leqslant 4\\).\n\nfor i in range(5):\n    for j in range(i+1,5):\n        print(i, j)\n\n\n\n\n\n\nExercices\n\n\n\n Fiche d’exercices sur boucles.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#fonctions",
    "href": "02_python/python_bases.html#fonctions",
    "title": "Variables et types",
    "section": "8. Fonctions",
    "text": "8. Fonctions\nLors du développement d’un projet informatique, de nombreuses lignes de programme sont souvent nécessaires.\nPour clarifier le code et rendre sa compréhension, et donc sa correction, plus faciles, il est possible de le décomposer en plusieurs sous-programmes plus simples qui peuvent être étudiés séparément.\nD’autre part, il arrivera souvent qu’une même séquence d’instructions doive être utilisée à plusieurs reprises dans un programme, et on souhaitera bien évidemment ne pas avoir à la reproduire systématiquement.\nPour cela, nous pouvons définir de nouvelles fonctions, c’est-à-dire donner un nom à un groupe d’instructions, qui pourra être appelé à plusieurs reprises dans le programme principal. Cela revient à définir de nouvelles instructions.\nEn python, la syntaxe est la suivante :\ndef ma_fonction(liste des arguments de la fonction) :\n    ...\n    # groupe d'instructions\n    ...\nRemarquez les deux points et l’indentation. La première ligne, introduite par def est l’entête ou la signature de la fonction.\nVoici un premier exemple de fonction qui prend en paramètre un nombre entier \\(n\\) :\ndef table(n) :\n    for k in range(11) :\n        print(n, \"fois\", k, \"font\", n * k)\nPour exécuter cette fonction, il suffit d’écrire par exemple table(4) et on obtient l’affichage suivant :\n4 fois 0 font 0\n4 fois 1 font 4\n4 fois 2 font 8\n4 fois 3 font 12\n4 fois 4 font 16\n4 fois 5 font 20\n4 fois 6 font 24\n4 fois 7 font 28\n4 fois 8 font 32\n4 fois 9 font 36\n4 fois 10 font 40\nUne fonction peut avoir plusieurs paramètres. Ils doivent alors être séparés par des virgules.\nPar exemple, la fonction ci-dessous affiche le prix TTC en fonction du prix hors taxes et du taux de la taxe, donné en pourcentage :\ndef prixTTC(prixHT, taux) :\n    print(prixHT*(1+taux/100))\nOn a souvent besoin de définir une fonction qui calcule une valeur ou qui retourne le résultat d’un algorithme. Il faut alors utiliser l’instruction return suivie du nom de la variable contenant la valeur à retourner.\n# definition d'une fonction\ndef aire_triangle(base, hauteur) :\n    aire = base * hauteur / 2\n    return aire\n\n# programme principal\na = aire_triangle(2, 3)\nprint(a)\nRemarque : Python propose des fonction prêtes à être utilisées par le programmeur : les fonctions natives (built-in functions en anglais). Nous avons déjà eu l’occasion d’en voir deux avec type (qui renvoie le type d’une variable) et str qui renvoie la chaîne de caractère obtenue à partir d’un nombre (str(4) renvoie le caractère “4”). Il existe beaucoup d’autres fonctions natives Python (il en existe plus de 50). Nous pouvons en citer deux autres :\n\nla fonction len prend en paramètre une chaîne de caractères et renvoie le nombre de caractères présents dans cette chaîne de caractères (par exemple len(\"azerty\") renvoie 5)\nla fonction print permet d’afficher à l’écran la valeur qui lui est passée en paramètre.\n\n\n\n\n\n\n\nPoint de vocabulaire\n\n\n\nDans ce qui précède, nous avons utilisé le terme fonction de manière très générale. Nous devons différencier deux types de “fonctions”.\n\nun groupe d’instruction qui retourne une valeur au programme principal est appelé une fonction. Une fonction ne réalise pas d’affichage : elle communique avec le programme principal par ses arguments et la valeur retournée.\nun groupe d’instruction qui ne retourne pas de valeur et qui peut éventuellement effectuer des affichages sera appelé une procédure.\n\nPar exemple, le script ci-dessus qui affiche une table de multiplication et celui qui est nommé prixTTC sont des procédures. Par contre aire_triangle est une fonction.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#utilisation-de-bibliothèques",
    "href": "02_python/python_bases.html#utilisation-de-bibliothèques",
    "title": "Variables et types",
    "section": "9. Utilisation de bibliothèques",
    "text": "9. Utilisation de bibliothèques\nIl est possible d’utiliser d’autres fonctions “prêtes à l’emploi” en important des bibliothèques, aussi appelées modules. Un module est un fichier contenant des fonctions qui pourront être utilisées dans d’autres programmes.\nDe nombreuses bibliothèques sont fournies avec une installation standard de Python, d’autres doivent être installées séparément.\nLe module math est un module très important puisqu’il comporte toutes les fonctions mathématiques classiques : cosinus, sinus, exposant, racine carrée…\nPour utiliser les fonctions présentes dans un module, il est nécessaire d’importer le module dans notre programme. Par exemple, pour pouvoir utiliser les fonctions du module math il faudra écrire :\nimport math\nau début de son programme.\nPour utiliser une fonction d’un module importé, il faudra préciser le nom du module qui propose cette fonction. Par exemple, pour déterminer le sinus de 3.14, il faudra écrire :\nmath.sin(3.14)\nVoici une série de calculs qui fait appel à des fonctions issues du module maths :\nimport math\n\na = 5\nb = 16\nc = 3.14\npuis = math.pow(a,3)\nracine = math.sqrt(b)\ns = math.sin(c)\nAprès l’exécution de ce programme :\n\nla variable puis aura pour valeur \\(5^3 = 125\\) ;\nla variable racine aura pour valeur \\(\\sqrt{16}=4\\) :\nla variable s aura pour valeur \\(\\sin(3.14)\\approx 0.05\\).\n\nPour alléger l’écriture, on peut aussi importer toutes les fonctions du module directement dans notre programme en tapant : from math import *. Il n’est alors plus nécessaire de spécifier math. devant chaque fonction utilisée.\nParmi les modules que nous utiliserons pour débuter se trouvent :\n\nle module math déjà cité ;\nle module random introduisant des fonctions permettant de générer des nombres aléatoires ;\n\n\n\n\nFonction\nEffet\n\n\n\n\nrandrange(a,b)\nrenvoie un entier aléatoire dans \\([a;b[\\)\n\n\nrandint(a,b)\nrenvoie un entier aléatoire dans \\([a;b]\\)\n\n\nrandom()\nrenvoie un flottant aléatoire dans \\([0;1[\\)\n\n\nuniform(a,b)\nrenvoie un flottant aléatoire dans \\([a;b]\\)\n\n\n\n\nle module turtle est une implémentation en Python du langage Logo créé dans les années 1970 pour l’enseignement de l’informatique à l’école. Il est disponible dans la distribution standard de Python. En déplaçant une pointe de stylo qui peut être matérialisée par une tortue, on peut tracer des figures géométriques dans un repère cartésien dont l’origine est au centre de la fenêtre et dont l’unité par défaut est le pixel. Lorsqu’on déplace le crayon, il laisse une trace s’il est baissé ou pas de trace s’il est levé. Nous utiliserons les fonctions suivantes de turtle :\n\n\n\n\n\n\n\n\nFonction\nEffet\n\n\n\n\ngoto(x,y)\ndéplace la tortue jusqu’au point de coordonnées (x, y)\n\n\npenup()\nlever le crayon\n\n\npendown()\nbaisser le crayon\n\n\nsetheading(angle)\nchoisir l’angle d’orientation de la tortue en degrés\n\n\nforward(n)\navancer de n pixels selon l’orientation de la tortue\n\n\nleft(a)\ntourne à gauche de a degrés\n\n\nright(a)\ntourne à droite de a degrés\n\n\ncolor(“red”)\nchoisir la couleur rouge (ou “black”, “green”, “blue” . . . )\n\n\n\nPour connaître toutes les fonctions contenues dans une bibliothèque, on peut, après avoir tapé import math dans la console interactive, taper ensuite help(math). On peut aussi consulter la documentation officielle.\nVoici par exemple un programme qui génère la figure ci-dessous :\nimport turtle as tt\n\ndef spirale(n):\n    tt.penup()\n    tt.goto(0,0)\n    tt.pendown()\n    c = 5\n    for i in range(4):\n        for j in range(4):\n            tt.forward(c)\n            c = 10 + c\n            tt.left(90)\nspirale(4)\ntt.exitonclick()\n\nQuelques remarques complémentaires sur ce programme :\n\nà la ligne 1, on importe le module turtle en le renommant tt afin d’alléger l’appel aux fonctions de cette bibliothèque. Cette pratique est très courante.\nà la ligne 14, la fonction exitonclick() permet de fermer la fenêtre graphique en cliquant une fois à l’intérieur.\n\n\n\n\n\n\n\nCréation d’une bibliothèque personnelle\n\n\n\nIl est aussi possible de créer un module personnel, regroupant toutes les fonctions que vous avez créées pour un projet particulier.\nSupposons par exemple que nous avons créé un fichier MesFonc.py dans lequel nous avons mis les définitions des fonctions fonc1 et fonc2.\nPour réutiliser ces fonctions dans un autre programme, on pourra importer le module MesFonc en tapant :\n\nfrom MesFonc import * : import de toutes les fonctions du module, utilisables sans préfixe.\nfrom MesFonc import fonc1 : import uniquement de la fonction fonc1, utilisable sans préfixe.\nimport MesFonc : import de toutes les fonctions du module, utilisables avec préfixe. Pour appeler la fonction fonc1, on tapera MesFonc.fonc1().\nimport MesFonc as MF : import de toutes les fonctions du module, utilisables avec préfixe alias, par commodité. Pour appeler la fonction fonc1, on tapera MF.fonc1().\n\nLes deux dernières possibilités sont intéressantes, par exemple, lorsqu’une fonction du module a le même nom qu’une autre fonction Python.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases.html#variables-locales-et-variables-globales",
    "href": "02_python/python_bases.html#variables-locales-et-variables-globales",
    "title": "Variables et types",
    "section": "10. Variables locales et variables globales",
    "text": "10. Variables locales et variables globales\nConsidérons le programme suivant:\ndef ma_fonc():\n    i = 5\nma_fonc()\nprint (i)\nNous commençons par définir une fonction ma_fonc qui ne prend aucun paramètre et qui ne renvoie aucune valeur (absence du mot-clef return). Cette fonction attribue juste la valeur 5 a la variable ayant pour nom i.\nA la 3e ligne du programme, nous exécutons la fonction ma_fonc.\nRappelons que la fonction print permet d’afficher à l’écran la valeur qui lui est passée en paramètre. La 4e ligne de ce programme permet donc d’afficher la valeur de la variable i à l’écran.\nOn pourrait penser que ce programme va donc afficher 5 ! Pas du tout, nous avons le droit à l’erreur suivante :\nNameError: name 'i' is not defined\nLe message d’erreur est suffisamment parlant, inutile de s’attarder dessus : la variable i n’est pas définie. A noter que cette erreur est déclenchée par la 4e ligne (le print).\nPourquoi cette erreur, la variable i est bien définie dans la fonction ma_fonc et la fonction ma_fonc est bien exécutée, où est donc le problème ?\nEn fait, la variable i est une variable dite locale : elle a été définie dans une fonction et elle “restera” dans cette fonction. Une fois que l’exécution de la fonction sera terminée, la variable i sera “détruite” (supprimée de la mémoire). Elle n’est donc pas accessible depuis “l’extérieur” de la fonction (ce qui explique le message d’erreur que nous obtenons, car le print est en dehors la fonction ma_fonc, la variable i n’est donc plus accessible).\nÉtudions maintenant un cas un peu plus complexe :\ni = 3\ndef ma_fonc():\n    i = 5\nma_fonc()\nprint (i)  \nOn pourrait s’attendre à voir s’afficher la valeur 5 à l’écran. Pas du tout, nous ne rencontrons pas d’erreur cette fois, mais c’est la valeur 3 qui s’affiche à l’écran.\nEn fait dans cet exemple nous avons 2 variables i différentes : la variable i “globale” (celle qui a été définie en dehors de toute fonction) et la variable i “locale” (celle qui a été définie dans la fonction). Ces 2 variables portent le même nom, mais sont différentes (elles correspondent à des cases mémoire différentes). Au moment de l’exécution du print à la 5e ligne seule la variable globale existe encore (celle définie à la première ligne du programme), d’où l’affichage du 3.\nUne variable globale peut être “utilisée” à l’intérieur d’une fonction :\ni = 3\ndef ma_fonc():\n    print (i)\nma_fonc()\nAttention, le print se situe dans la fonction (la ligne du print est bien indentée)\nCe programme permet d’afficher la valeur 3 à l’écran.\nQuand on cherche à utiliser une variable dans une fonction, le système va d’abord chercher si cette variable se “trouve” dans l’espace local de la fonction, puis, s’il ne la trouve pas dans cet espace local, le système va aller rechercher la variable dans l’espace global. Pour le print(i) situé dans la fonction le système ne trouve pas de variable i dans l’espace local de la fonction ma_fonc, il passe donc à l’espace global et trouve la variable i (nous avons donc 3 qui s’affiche).\nIl est important de bien comprendre que dans le programme ci-dessous le système trouve une variable i dans l’espace local de la fonction, la “recherche” de la variable i se serait arrêtée là :\ni = 3\ndef ma_fonc():\n    i = 5\n    print (i)\nma_fonc()\net ce programme affiche la valeur 5 à l’écran. i a été trouvée dans l’espace local de la fonction ma_fonc, la recherche ne va donc pas plus loin (inutile de remonter jusqu’à l’espace global)\nEn revanche le programme ci-dessous génère une erreur : “UnboundLocalError: local variable ‘i’ referenced before assignment”\ni = 3\ndef ma_fonc():\n    i = i + 1\nma_fonc()\nprint(i)\nIl n’est à priori pas possible de modifier une variable globale (ici la variable i) dans une fonction.\nPour pouvoir modifier une variable globale dans une fonction, il faut le déclarer explicitement en utilisant le mot-clef global :\ni = 3\ndef ma_fonc():\n    global i\n    i = i + 1\nma_fonc()\nprint(i)\nIci, aucune erreur la valeur 4 est bien affichée à l’écran.\nIl est fortement déconseillé de donner le même nom à une variable locale et à une variable globale pour éviter ce genre de confusions.\nOn évitera également l’emploi du mot-clef global car cette utilisation peut entraîner des “effets de bord”.\n\n\n\n\n\n\nÀ retenir\n\n\n\nLorsqu’on écrit un programme, python crée un espace de noms ( namespace ) dans lequel les noms des variables et des fonctions définies dans ce programme sont stockés.\nÀ l’intérieur de chaque fonction, il est possible de définir aussi des variables. Un nouvel espace de noms, complètement indépendant de l’espace de noms principal est créé pour chaque fonction.\nPar conséquent, une variable définie à l’intérieur d’une fonction n’est pas accessible depuis le programme principal et elle n’existe plus lorsque l’exécution de la fonction est terminée (même si elle porte le même nom qu’une variable du programme principal). On dit qu’il s’agit d’une variable locale.\n\n\nOn parle d’effet de bord quand une fonction modifie l’état d’une variable globale. Dans notre exemple ci-dessus, la fonction ma_fonc modifie bien la valeur de i : avant l’exécution de ma_fonc, i a la valeur 3, après l’exécution de la fonction ma_fonc, i est associé à la valeur 4. Nous avons donc bien un effet de bord.\nLes effets de bords provoquent parfois des comportements non désirés par le programmeur (évidemment dans des programmes très complexes, pas dans des cas simplistes comme celui que nous venons de voir). Ils rendent aussi parfois les programmes difficilement lisibles (difficilement compréhensibles). À cause des effets de bord, on risque de se retrouver avec des variables qui auront des valeurs qui n’étaient pas prévues par le programmeur. On dit aussi qu’à un instant donné, l’état futur des variables est difficilement prévisible à cause des effets de bord. En résumé, on évitera autant que possible l’utilisation du “global”.\n\n\n\n\n\n\nExercices\n\n\n\n Fiche d’exercices sur fonctions et la portée des variables.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Variables et types"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_2.html",
    "href": "02_python/python_bases_exos_2.html",
    "title": "Exercices - fiche 2",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.\nFiche d’exercices sur les instructions conditionnelles.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 2"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_2.html#exercice-1",
    "href": "02_python/python_bases_exos_2.html#exercice-1",
    "title": "Exercices - fiche 2",
    "section": " Exercice 1",
    "text": "Exercice 1\nÉcrire un programme qui demande le poids, en grammes, d’une lettre prioritaire destinée à la France et qui retourne le prix du timbre adéquat. Vous pourrez consulter les tarifs postaux sur le site de la Poste.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 2"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_2.html#exercice-2",
    "href": "02_python/python_bases_exos_2.html#exercice-2",
    "title": "Exercices - fiche 2",
    "section": " Exercice 2",
    "text": "Exercice 2\nOn considère la fonction suivante écrite dans un script qui a été exécuté.\ndef ma_fct(a,b):\n    if a &lt; 5 or b &gt; 2 :\n        return 42\n    else :\n        return 24\n\nDans la console interactive, on tape ma_fct(6,3). Quel résultat obtient-on ?\nQuels valeurs de b peut-on choisir pour que l’appel ma_fct(6,b) retourne 24 ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 2"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_2.html#exercice-3",
    "href": "02_python/python_bases_exos_2.html#exercice-3",
    "title": "Exercices - fiche 2",
    "section": " Exercice 3",
    "text": "Exercice 3\nOn considère la fonction suivante écrite dans un script qui a été exécuté.\ndef ma_fct(a,b):\n    if a &lt; 5 and b &gt; 2 :\n        return 42\n    else :\n        return 24\n\nDans la console interactive, on tape ma_fct(6,3). Quel résultat obtient-on ?\nQuels valeurs de b peut-on choisir pour que l’appel ma_fct(6,b) retourne 42 ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 2"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_2.html#exercice-4",
    "href": "02_python/python_bases_exos_2.html#exercice-4",
    "title": "Exercices - fiche 2",
    "section": " Exercice 4",
    "text": "Exercice 4\nOn considère le script suivant :\na = 10\nb = int(input())\nif b &lt; 10 :\n    if b &gt;= 5 :\n        a = a + 2\n    else :\n        a = a - 2\n    a = a * 2\na = a - 1\n\nQuelle est la valeur finale de a avec b=12 ?\nQuelle est la valeur finale de a avec b=6 ?\n\nOn trouvera d’autres exercices dans la fiche n°4",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 2"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_4.html",
    "href": "02_python/python_bases_exos_4.html",
    "title": "Exercices - fiche 4",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.\nFiche d’exercices sur fonctions et la portée des variables",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 4"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_4.html#exercice-1",
    "href": "02_python/python_bases_exos_4.html#exercice-1",
    "title": "Exercices - fiche 4",
    "section": " Exercice 1",
    "text": "Exercice 1\n\nÉcrire une fonction prixTTC qui calcule un prix TVA comprise (au taux de 20 %) en fonction du prix hors taxes.\nÉcrire une procédure qui écrit à l’écran 50 fois la phrase “Je ne dois pas faire le pitre en classe”.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 4"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_4.html#exercice-2",
    "href": "02_python/python_bases_exos_4.html#exercice-2",
    "title": "Exercices - fiche 4",
    "section": " Exercice 2",
    "text": "Exercice 2\n\nEntrer le programme suivant dans une fenêtre de l’éditeur.\n\n#  definition  d’une  procédure\ndef ma_proc() :\n    phrase = \"Il fait beau\" \n    print(phrase)\n\n#  programme  principal \nphrase = \"Il y a du soleil\" \nma_proc() \nprint(phrase)\n\nEnregistrer et exécuter ce programme. Expliquer précisément ce qu’il se passe.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 4"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_4.html#exercice-3",
    "href": "02_python/python_bases_exos_4.html#exercice-3",
    "title": "Exercices - fiche 4",
    "section": " Exercice 3",
    "text": "Exercice 3\nÉcrire une procédure lapin(nom) qui affiche un lapin tenant une pancarte :\n|￣￣￣￣￣￣￣￣￣|\n| Bonjour       |\n| nom !         |       \n|_______________|\n        ||\n(\\__/) ||\n(•ㅅ•) || \n/ 　 づ\"",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 4"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_4.html#exercice-4",
    "href": "02_python/python_bases_exos_4.html#exercice-4",
    "title": "Exercices - fiche 4",
    "section": "  Exercice 4",
    "text": "Exercice 4\nOn considère le programme suivant :\nfrom random import randint\n\ndef LancerDeuxDes(): \n    print(\"Lancer de deux dés ...\")\n    de1 = randint(1, 6)\n    de2 = randint(1, 6)\n    total = de1 + de2\n    print(f\"J'obtiens un total de {total} !\")\n\nLancerDeuxDes( )\nif total == 2:\n    print(\"C'est un petit score !\")\nelif total == 12:\n    print(\"J'ai fait mon maximum !\")\n\nSans ordinateur : Essayer de prévoir ce qu’il va se passer à l’exécution de ce programme.\nTaper ce programme dans une fenêtre de l’éditeur et l’exécuter. Expliquer ce qu’il se passe.\nModifier le programme pour qu’il ait le comportement attendu.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 4"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_4.html#exercice-5",
    "href": "02_python/python_bases_exos_4.html#exercice-5",
    "title": "Exercices - fiche 4",
    "section": " Exercice 5",
    "text": "Exercice 5\nLa procédure suivante affiche une ligne d’étoiles :\ndef LigneEtoiles(NombreEtoiles) :\n    for i in range(NombreEtoiles) :\n        print(\"*\", end = \"\")\n    print()\nUtiliser cette procédure pour écrire une deuxième procédure : def  TriangleEtoiles(n) qui affiche un triangle d’étoiles comportant \\(n\\) étoiles sur la première ligne.\nPar exemple, l’appel : TriangleEtoiles(4) affichera :\n****\n***\n**\n*",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 4"
    ]
  },
  {
    "objectID": "02_python/python_bases_exos_4.html#exercice-6",
    "href": "02_python/python_bases_exos_4.html#exercice-6",
    "title": "Exercices - fiche 4",
    "section": " Exercice 6",
    "text": "Exercice 6\nLe jeu du TicTacToe (morpion) se joue sur une grille de 3x3 cases, numérotées de 1 à 9 (de gauche à droite et de haut en bas).\nLes cases sont au départ remplies avec des chiffres (symboles “1” à “9”), qui seront au fur et à mesure du jeu remplacés par le symbole d’un des deux joueurs (“X” ou “O”).\nLes états des cases sont enregistrés dans 9 variables c1 à c9.\nÉcrire une procédure AfficheGrille(c1,c2,c3,c4,c5,c6,c7,c8,c9) qui prend en paramètres les états des cases c1 à c9 et affiche la grille.\nPar exemple, l’appel AfficheGrille(1,2,3,4,5,6,7,8,9) affichera :\n----------\n 1 | 2 | 3 \n----------\n 4 | 5 | 6 \n----------\n 7 | 8 | 9 \n----------",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices - fiche 4"
    ]
  },
  {
    "objectID": "02_python/python_boucles.html",
    "href": "02_python/python_boucles.html",
    "title": "Instructions répétitives",
    "section": "",
    "text": "La notion de boucle est fondamentale en informatique. Une boucle permet d’exécuter plusieurs fois des instructions qui ne sont présentes qu’une seule fois dans le code.\nDeux types de boucles sont à distinguer : la boucle conditionnelle, introduite par le mot-clef while et le boucle bornée, introduite par le mot-clef for.\nLa structure de la boucle while est la suivante :\nwhile expression:\n    instruction1\n    instruction2\nsuite programme\nTant que expression sera True, on exécutera encore et encore instruction1 et instruction2. Après chaque exécution de instruction1 et instruction2 (on dit souvent “après chaque tour de boucle”), expression sera de nouveau évaluée (pour savoir si elle est toujours True ou si elle est devenue False)\nQuand expression deviendra False on passera directement à suite programme (sans entrer de nouveau dans la boucle), la boucle sera terminée.\n\nQue se passe-t-il si expression ne devient jamais False ? On entre alors dans une boucle “infinie” : c’est une erreur classique en programmation (aucun programme “bien fait” ne tombe dans une boucle infinie, s’il y a une boucle infinie, c’est qu’il y a forcément une erreur dans votre programme). C’est la raison pour laquelle on n’appelle pas ces boucles des boucles non bornées : en effet, une boucle while est bornée, mais on ne sait pas à l’avance combien de fois on va passer dans la boucle. Ce nombre de passages dans la boucle dépend de l’évaluation de expression.\nConsidérons le programme suivant :\ni = 0\nwhile i &lt; 3  :\n    print(i)\n    i = i + 1\nprint(\"FIN\")\nVoici comment analyser ce programme :\n\nAu début de l’exécution de ce programme, nous avons la variable i qui a pour valeur 0.\nNous arrivons ensuite au niveau du while : l’expression i &lt; 3 est True, on “entre” donc dans la boucle : on affiche la valeur de i : 0 et on incrémente i de 1 (i a maintenant pour valeur 1)\nNous passons au 2e tour de boucle : l’expression i &lt; 3 est True, on “entre” donc dans la boucle : on affiche la valeur de i : 1 et on incrémente i de 1 (i a maintenant pour valeur 2).\nNous passons au 3e tour de boucle : l’expression i &lt; 3 est True, on “entre” donc dans la boucle : on affiche la valeur de i : 2 et on incrémente i de 1 (i a maintenant pour valeur 3).\nNous passons au 4e tour de boucle : l’expression i &lt; 3 est False (3 n’est pas strictement inférieur à 3), on n’entre pas dans la boucle et on passe à l’instruction qui suit immédiatement la boucle : on exécute print(\"FIN\") et le programme s’arrête (il n’y a plus d’instruction après)\n\nAprès l’exécution de ce programme, nous aurons à l’écran :\n0\n1\n2\nFIN\nIl est très important que vous soyez capable d’effectuer l’analyse d’un programme comme nous venons de la faire ci-dessus, cela vous permettra d’éviter beaucoup d’erreurs. Cette analyse peut se faire à l’aide d’un tableau d’état (étape 0 : initialisation, étape 1 : état du programme après le premier passage dans la boucle) :\n\n\n\nEtape\ni\ni&lt;3\n\n\n\n\n0\n0\nTrue\n\n\n1\n1\nTrue\n\n\n2\n2\nTrue\n\n\n3\n3\nFalse",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Instructions répétitives"
    ]
  },
  {
    "objectID": "02_python/python_boucles.html#boucle-while",
    "href": "02_python/python_boucles.html#boucle-while",
    "title": "Instructions répétitives",
    "section": "",
    "text": "La notion de boucle est fondamentale en informatique. Une boucle permet d’exécuter plusieurs fois des instructions qui ne sont présentes qu’une seule fois dans le code.\nDeux types de boucles sont à distinguer : la boucle conditionnelle, introduite par le mot-clef while et le boucle bornée, introduite par le mot-clef for.\nLa structure de la boucle while est la suivante :\nwhile expression:\n    instruction1\n    instruction2\nsuite programme\nTant que expression sera True, on exécutera encore et encore instruction1 et instruction2. Après chaque exécution de instruction1 et instruction2 (on dit souvent “après chaque tour de boucle”), expression sera de nouveau évaluée (pour savoir si elle est toujours True ou si elle est devenue False)\nQuand expression deviendra False on passera directement à suite programme (sans entrer de nouveau dans la boucle), la boucle sera terminée.\n\nQue se passe-t-il si expression ne devient jamais False ? On entre alors dans une boucle “infinie” : c’est une erreur classique en programmation (aucun programme “bien fait” ne tombe dans une boucle infinie, s’il y a une boucle infinie, c’est qu’il y a forcément une erreur dans votre programme). C’est la raison pour laquelle on n’appelle pas ces boucles des boucles non bornées : en effet, une boucle while est bornée, mais on ne sait pas à l’avance combien de fois on va passer dans la boucle. Ce nombre de passages dans la boucle dépend de l’évaluation de expression.\nConsidérons le programme suivant :\ni = 0\nwhile i &lt; 3  :\n    print(i)\n    i = i + 1\nprint(\"FIN\")\nVoici comment analyser ce programme :\n\nAu début de l’exécution de ce programme, nous avons la variable i qui a pour valeur 0.\nNous arrivons ensuite au niveau du while : l’expression i &lt; 3 est True, on “entre” donc dans la boucle : on affiche la valeur de i : 0 et on incrémente i de 1 (i a maintenant pour valeur 1)\nNous passons au 2e tour de boucle : l’expression i &lt; 3 est True, on “entre” donc dans la boucle : on affiche la valeur de i : 1 et on incrémente i de 1 (i a maintenant pour valeur 2).\nNous passons au 3e tour de boucle : l’expression i &lt; 3 est True, on “entre” donc dans la boucle : on affiche la valeur de i : 2 et on incrémente i de 1 (i a maintenant pour valeur 3).\nNous passons au 4e tour de boucle : l’expression i &lt; 3 est False (3 n’est pas strictement inférieur à 3), on n’entre pas dans la boucle et on passe à l’instruction qui suit immédiatement la boucle : on exécute print(\"FIN\") et le programme s’arrête (il n’y a plus d’instruction après)\n\nAprès l’exécution de ce programme, nous aurons à l’écran :\n0\n1\n2\nFIN\nIl est très important que vous soyez capable d’effectuer l’analyse d’un programme comme nous venons de la faire ci-dessus, cela vous permettra d’éviter beaucoup d’erreurs. Cette analyse peut se faire à l’aide d’un tableau d’état (étape 0 : initialisation, étape 1 : état du programme après le premier passage dans la boucle) :\n\n\n\nEtape\ni\ni&lt;3\n\n\n\n\n0\n0\nTrue\n\n\n1\n1\nTrue\n\n\n2\n2\nTrue\n\n\n3\n3\nFalse",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Instructions répétitives"
    ]
  },
  {
    "objectID": "02_python/python_boucles.html#boucle-for",
    "href": "02_python/python_boucles.html#boucle-for",
    "title": "Instructions répétitives",
    "section": "2. Boucle for",
    "text": "2. Boucle for\nUne boucle bornée for peut être utilisée lorsque l’on connaît le nombre d’itérations au moment de la programmation.\nLa structure de la boucle for est la suivante :\nfor truc in machin:\n    instruction1\n    instruction2\nsuite programme\nLes instructions instruction1 et instruction2 sont exécutées autant de fois qu’il y a de truc dans machin. machin doit être un objet itérable, c’est-à-dire à partir duquel on peut générer une suite de valeurs bien déterminées. Pour l’instant, nous nous contenterons de deux situations :\n\nitération sur une chaîne de caractère : la variable truc prend alors successivement pour valeur tous les caractères de la chaîne machin ;\n\nfor lettre in \"ciao\":\n    print(lettre)\n\nitération sur une séquence d’entiers générée par la fonction range() : par exemple si machin est range(10), alors truc prendra successivement toutes les valeurs entières de 0 à 9.\n\nfor i in range(5):\n    print(3*i)\n\n\n\n\n\n\nUtilisation de la fonction range()\n\n\n\n\nrange(n) génère une séquence de nombres entiers en commençant par 0 et jusqu’à \\(n\\) exclu ;\nrange(k, n) génère une séquence de nombres entiers en commençant par \\(k\\) et jusqu’à \\(n\\) exclu ;\nrange(k, n, p)génère une séquence de nombres entiers en commençant par \\(k\\) et jusqu’à \\(n\\) exclu, avec un pas de \\(p\\) ;\n\n\n\nSi \\(p\\) est négatif et \\(k&gt;n\\), on peut définir une séquence décroissante d’entiers.\nRemarques\n\nUne boucle for peut toujours être remplacée par une boucle while. Le programme suivant est équivalent au précédent :\n\ni = 0\nwhile i&lt;5:\n    print(3*i)\n    i = i + 1\n\nLa réciproque est fausse : pourquoi ?\nLes boucles peuvent être imbriquées. Par exemple, le programme ci-dessous affichera la liste des couples d’entiers \\((i;j)\\) avec \\(0\\leqslant i&lt;j\\leqslant 4\\).\n\nfor i in range(5):\n    for j in range(i+1,5):\n        print(i, j)\n\n\n\n\n\n\nExercices\n\n\n\n Fiche d’exercices sur boucles.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Instructions répétitives"
    ]
  },
  {
    "objectID": "02_python/python_if_else.html",
    "href": "02_python/python_if_else.html",
    "title": "Instructions conditionnelles",
    "section": "",
    "text": "Dans les scripts précédents, les séquences d’instructions sont exécutées ligne après ligne, dans l’ordre où elles sont écrites, suivant un organigramme simple du type ci-dessous.\n\nUne instruction conditionnelle permet d’indiquer à python de ne pas exécuter une suite de commandes dans l’ordre où elles sont écrites, mais de suivre différents chemins selon les circonstances.\nL’idée de base est la suivante :\nif test:\n    instruction1\nelse:\n    instruction2\nSi “test” est True alors “instruction1” est exécutée et “instruction2” est ignorée.\nSinon (sous-entendu que “test” est False) “instruction2” est exécutée et “instruction1” est ignorée.\n\nPlusieurs conditions peuvent être testées : on utilise pour cela le mot-clef elif, contraction de else if :\nif test1:\n    instruction1\nelif test2:\n    instruction2\nelif test3:\n    instruction3\nelse:\n    instruction4\nDans ce cas, si test1 est True, instruction1 est exécutée et tout le reste est ignoré. Sinon, si test2 est True, alors instruction2 est exécutée et tout le reste est ignoré. Si test1 et test2 sont False et test3 True, alors instruction3 est exécutée. Si les trois tests sont False, c’est instruction4 qui est exécutée.\n\n\n\n\n\n\n\nRemarques\n\n\n\n\nSeul if est nécessaire dans une instruction conditionnelle. Les commandes elif et else sont optionnelles.\nLe bloc d’instructions conditionnelles est introduit par une ligne se terminant par une instruction if, elif ou else suivie d’un double point.\nCe bloc est délimité par une indentation spécifique : décalage de 4 espaces vers la droite.\nDans tout éditeur de programme digne de ce nom, cette indentation se fait automatiquement quand on tape “Entrée” à la fin d’une ligne se terminant par un double point.\n\n\n\nSi on considère le programme suivant :\na = 4\nb = 7\nif a &lt; b:\n    print(\"Je suis toto.\");\n    print(\"Je n'aime pas titi.\")\nelse:\n    print(\"Je suis titi.\")\n    print(\"Je n'aime pas toto.\")\nprint(\"En revanche, j'aime le Python.\")\nnous avons a &lt; b qui est True, nous allons donc exécuter les 2 lignes\nprint(\"Je suis toto.\");\nprint(\"Je n'aime pas titi.\")\nles lignes\nprint(\"Je suis titi.\")\nprint(\"Je n'aime pas toto.\")\nseront ignorées.\nEn revanche la ligne\nprint(\"En revanche, j'aime le Python.\")\nsera systématiquement exécutée.\nL’exécution de ce programme permettra d’afficher à l’écran :\nJe suis toto.\nJe n'aime pas titi.\nEn revanche, j'aime le Python.\nSi maintenant on considère ce programme :\na = 8\nb = 7\nif a &lt; b:\n    print(\"Je suis toto.\");\n    print(\"Je n'aime pas titi.\")\nelse:\n    print(\"Je suis titi.\")\n    print(\"Je n'aime pas toto.\")\nprint(\"En revanche, j'aime le Python.\")\nL’exécution de ce programme entraînera l’affichage suivant :\nJe suis titi.\nJe n'aime pas toto.\nEn revanche, j'aime le Python.\n\n\n\n\n\n\nExercices\n\n\n\n Fiche d’exercices sur les instructions conditionnelles.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Instructions conditionnelles"
    ]
  },
  {
    "objectID": "02_python/supplements.html",
    "href": "02_python/supplements.html",
    "title": "Exercices supplémentaires",
    "section": "",
    "text": "Pour vous entraîner ou pour vérifier que vous maîtrisez les bases, voici des notebooks d’exercices supplémentaires.\n\nPartie 1 : bases du langage\nPartie 2 : instructions conditionnelles\nPartie 3 : boucles for\nPartie 4 : boucles while\nPartie 5 : les fonctions",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Exercices supplémentaires"
    ]
  },
  {
    "objectID": "03_spec/spec_cours.html",
    "href": "03_spec/spec_cours.html",
    "title": "Mise au point de programmes, prendre de bonnes habitudes !",
    "section": "",
    "text": "Une fonction peut être considérée comme une boîte noire qui, à partir de données, renvoie une sortie.\n\n\n\n\n\ngraph LR\n  A(Entrées) --&gt; F[Fonction];\n  F --&gt; B(Sortie);\n  style F fill:#000,color:#fff\n  style A fill:#fff\n  style B fill:#fff\n\n\n\n\n\n\nLa fonction ne gère pas la provenance des entrées ni la destination des sorties (variable, affichage, fichier, …) : elle peut donc être utilisée dans différentes configurations d’entrées/sorties.\n\n\n\n\n\n\nÀ savoir\n\n\n\nLes entrées d’une fonction sont appelées ses paramètres ou ses arguments.\n\n\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nSpécifier une fonction, c’est la documenter en :\n\ndécrivant ce qu’elle fait\nénumérant les entrées attendues et leur type\nprécisant des conditions sur les entrées : on parle de préconditions\ndonnant le type de la valeur retournée\nprécisant des conditions sur la valeur retournée : on parle de postconditions\n\n\n\nEn Python, la spécification d’une fonction se fait juste sous sa signature sous la forme d’une chaîne de caractères encadrée de triples guillemets (appelée en anglais docstring), comme dans l’exemple ci-dessous :\ndef add_trois_nombres(m, n, p):\n    \"\"\"\n    Renvoie la somme des trois entiers m, n et p\n\n    Parameters\n    ----------\n    m : type int\n    n : type int\n    p : type int\n\n    Returns\n    -------\n    type int\n\n    \"\"\"\n    return m + n + p\nDepuis la version 3.5 de Python, on peut préciser les types attendus pour les entrées et le type de la sortie avec des annotations simples. Cela permet d’alléger la spécification et d’écrire une docstring plus compacte.\ndef add_trois_nombres(m: int, n: int, p: int) -&gt; int:\n    \"\"\"Renvoie la somme des trois entiers m, n et p\"\"\"\n    return m + n + p\nLa chaîne de documentation d’une fonction est utilisée par la fonction help de Python pour renseigner l’utilisateur.\n&gt;&gt;&gt;help(add_trois_nombres)\nHelp on function add_trois_nombres in module __main__:\n\nadd_trois_nombres(m: int, n: int, p: int) -&gt; int\n    Renvoie la somme des trois entiers m, n et p\nLes fonctions Python prédéfinies possèdent également une spécification que l’on peut consulter avec la fonction help.\n\n\n\nLa spécification d’une fonction telle qu’elle est présentée ci-dessus est juste indicative et n’empêche pas un utilisateur de notre fonction de l’appeler avec des paramètres qui ne vérifient pas les préconditions, ce qui peut, dans la suite du programme, engendrer des erreurs.\nIl est possible de vérifier les préconditions à l’intérieur de la fonction avec l’instruction assert.\nUne telle instruction se compose d’une condition (une expression booléenne) éventuellement suivie d’une virgule et d’une phrase en langue naturelle, sous forme d’une chaîne de caractères. L’instruction assert teste si sa condition est satisfaite. Si c’est le cas, elle ne fait rien et sinon elle arrête immédiatement l’exécution du programme en affichant éventuellement la phrase qui lui est associée.\nTester par exemple la fonction ci-dessous avec des arguments entiers, puis avec des arguments non entiers.\ndef add_trois_nombres(m: int, n: int, p: int) -&gt; int:\n    \"\"\"Renvoie la somme des trois entiers n, m et p\"\"\"\n    assert type(m) == int, 'm doit être un entier'\n    assert type(n) == int, 'n doit être un entier'\n    assert type(p) == int, 'p doit être un entier'\n    return m + n + p\n\n\n\n\n\n\nRemarque\n\n\n\nLorsqu’on vérifie les préconditions sur les arguments au début du code d’une fonction, on parle de programmation défensive.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Mise au point de programmes, prendre de bonnes habitudes !"
    ]
  },
  {
    "objectID": "03_spec/spec_cours.html#prototyper-une-fonction",
    "href": "03_spec/spec_cours.html#prototyper-une-fonction",
    "title": "Mise au point de programmes, prendre de bonnes habitudes !",
    "section": "",
    "text": "Une fonction peut être considérée comme une boîte noire qui, à partir de données, renvoie une sortie.\n\n\n\n\n\ngraph LR\n  A(Entrées) --&gt; F[Fonction];\n  F --&gt; B(Sortie);\n  style F fill:#000,color:#fff\n  style A fill:#fff\n  style B fill:#fff\n\n\n\n\n\n\nLa fonction ne gère pas la provenance des entrées ni la destination des sorties (variable, affichage, fichier, …) : elle peut donc être utilisée dans différentes configurations d’entrées/sorties.\n\n\n\n\n\n\nÀ savoir\n\n\n\nLes entrées d’une fonction sont appelées ses paramètres ou ses arguments.\n\n\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nSpécifier une fonction, c’est la documenter en :\n\ndécrivant ce qu’elle fait\nénumérant les entrées attendues et leur type\nprécisant des conditions sur les entrées : on parle de préconditions\ndonnant le type de la valeur retournée\nprécisant des conditions sur la valeur retournée : on parle de postconditions\n\n\n\nEn Python, la spécification d’une fonction se fait juste sous sa signature sous la forme d’une chaîne de caractères encadrée de triples guillemets (appelée en anglais docstring), comme dans l’exemple ci-dessous :\ndef add_trois_nombres(m, n, p):\n    \"\"\"\n    Renvoie la somme des trois entiers m, n et p\n\n    Parameters\n    ----------\n    m : type int\n    n : type int\n    p : type int\n\n    Returns\n    -------\n    type int\n\n    \"\"\"\n    return m + n + p\nDepuis la version 3.5 de Python, on peut préciser les types attendus pour les entrées et le type de la sortie avec des annotations simples. Cela permet d’alléger la spécification et d’écrire une docstring plus compacte.\ndef add_trois_nombres(m: int, n: int, p: int) -&gt; int:\n    \"\"\"Renvoie la somme des trois entiers m, n et p\"\"\"\n    return m + n + p\nLa chaîne de documentation d’une fonction est utilisée par la fonction help de Python pour renseigner l’utilisateur.\n&gt;&gt;&gt;help(add_trois_nombres)\nHelp on function add_trois_nombres in module __main__:\n\nadd_trois_nombres(m: int, n: int, p: int) -&gt; int\n    Renvoie la somme des trois entiers m, n et p\nLes fonctions Python prédéfinies possèdent également une spécification que l’on peut consulter avec la fonction help.\n\n\n\nLa spécification d’une fonction telle qu’elle est présentée ci-dessus est juste indicative et n’empêche pas un utilisateur de notre fonction de l’appeler avec des paramètres qui ne vérifient pas les préconditions, ce qui peut, dans la suite du programme, engendrer des erreurs.\nIl est possible de vérifier les préconditions à l’intérieur de la fonction avec l’instruction assert.\nUne telle instruction se compose d’une condition (une expression booléenne) éventuellement suivie d’une virgule et d’une phrase en langue naturelle, sous forme d’une chaîne de caractères. L’instruction assert teste si sa condition est satisfaite. Si c’est le cas, elle ne fait rien et sinon elle arrête immédiatement l’exécution du programme en affichant éventuellement la phrase qui lui est associée.\nTester par exemple la fonction ci-dessous avec des arguments entiers, puis avec des arguments non entiers.\ndef add_trois_nombres(m: int, n: int, p: int) -&gt; int:\n    \"\"\"Renvoie la somme des trois entiers n, m et p\"\"\"\n    assert type(m) == int, 'm doit être un entier'\n    assert type(n) == int, 'n doit être un entier'\n    assert type(p) == int, 'p doit être un entier'\n    return m + n + p\n\n\n\n\n\n\nRemarque\n\n\n\nLorsqu’on vérifie les préconditions sur les arguments au début du code d’une fonction, on parle de programmation défensive.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Mise au point de programmes, prendre de bonnes habitudes !"
    ]
  },
  {
    "objectID": "03_spec/spec_cours.html#mise-au-point-de-programmes",
    "href": "03_spec/spec_cours.html#mise-au-point-de-programmes",
    "title": "Mise au point de programmes, prendre de bonnes habitudes !",
    "section": "2. Mise au point de programmes",
    "text": "2. Mise au point de programmes\n\nJeux de tests\nLors du développement d’un programme, il est nécessaire de savoir localiser les erreurs afin d’en comprendre l’origine et de pouvoir les corriger.\nOutre les messages d’erreurs standard retournés pas Python, l’utilisation d’assertions sur des jeux de tests permet aussi d’aider à la mise au point d’une fonction ou d’un programme.\nIl s’agit de tester les postconditions de la fonction sur une série d’exemples bien choisis. On parle alors de tests unitaires. Si l’un des tests unitaires est faux, alors il y a une erreur dans la fonction. Si tous les tests unitaires sont validés, il reste des risques de bugs, car un jeu de tests ne peut en général pas couvrir toutes les possibilités existantes.\nOn peut rassembler ces tests unitaires dans une fonction ou un module.\ndef add_trois_nombres(m: int, n: int, p: int) -&gt; int:\n    \"\"\"Renvoie la somme des trois entiers n, m et p\"\"\"\n    assert type(m) == int, 'm doit être un entier'\n    assert type(n) == int, 'n doit être un entier'\n    assert type(p) == int, 'p doit être un entier'\n    return m + n + p\n\n\ndef test_add():\n    \"\"\"Jeu de tests unitaires pour la fonction add_trois_nombres\"\"\"\n    assert add_trois_nombres(1, 2, 3) == 6\n    assert add_trois_nombres(4, 5, 6) == 15\n    assert add_trois_nombres(7, 8, 9) == 24\n    print(\"Tests unitaires réussis\")\n\n\ntest_add()\n\n\n\n\n\n\nRemarques et compléments\n\n\n\nSi l’une des instructions assert n’était pas vérifiée, alors l’exécution de la fonction de test serait interrompue et le message final ne serait pas affiché.\nOn peut traiter de façon plus fine les erreurs dans un script Python en utilisant les instructions du type :\ntry:\n    instruction1\nexcept nom_de_l_exception:\n    instruction2\noù nom_de_l_exception est une des exceptions (erreurs) natives de Python dont la liste se trouve dans la documentation.\nPour plus d’informations sur try ... except, voir la documentation.\n\n\n\n\nUtilisation des fonctionnalités de l’IDE\nSelon l’éditeur utilisé pour écrire le programme, il est souvent possible d’exécuter un programme an mode débogage (debug), pas à pas, et d’observer en temps réel l’évolution du contenu des variables. Ces fonctionnalités facilitent grandement la mise au point d’un programme.\n\n\n\nExplorateur de variable dans Thonny\n\n\n\n\nDocumentation du programme\nLors du développement d’un programme ou d’un projet, il est souvent utile, pour comprendre et corriger des erreurs, d’ajouter dans le code des sorties et des affichages (fonction print) qui peuvent permettre de connaître l’état d’une variable particulière à un endroit précis du programme. C’est une méthode très simple et très efficace pour trouver des erreurs dans un programme !",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Mise au point de programmes, prendre de bonnes habitudes !"
    ]
  },
  {
    "objectID": "03_spec/TP_dessine_ta_rue.html",
    "href": "03_spec/TP_dessine_ta_rue.html",
    "title": "Projet - Dessine ta rue !",
    "section": "",
    "text": "Objectifs\n\n\n\n\nExplorer l’utilisation d’une bibliothèque (exemple de la bibliothèque turtle).\nUtiliser la documentation d’une bibliothèque.\nAppliquer les connaissances du cours : création de fonctions, spécifications, …\nTravailler en autonomie, travailler en groupe.\n\n\n\nL’objectif de ce projet est de construire un programme qui génère une illustration du type ci-dessous.\n\nLe travail doit se faire en groupes. Il y a beaucoup de fonctions à coder, il faut donc se partager le travail ! À vous de vous organiser sachant que :\n\nle diagramme présent dans l’énoncé vous permet de comprendre quelles fonctions dépendent les unes des autres ;\nil faut prendre garde à ne pas programmer deux fois la même chose : bien comprendre ce qui est déjà fait quand on appelle une fonction et ce qu’il reste à faire ;\nvous devrez vous documenter sur la librairie turtle : cela fait partie de l’exercice ! Rien ne vaut la documentation officielle !\nle dossier joint au TP contient :\n\nl’énonce en PDF ;\nune fiche de synthèse sur le module turtle ;\ndes fichiers Python à compléter : les entêtes et les spécifications des fonctions sont déjà préparées ;\ndes images représentant le rendu attendu pour chaque fonction.\n\n\n\n\n\n\n\n\nCritères d’évaluation\n\n\n\n\nCapacité à s’organiser et à travailler en groupe.\nRespect des contraintes du sujet.\nConcision du code : plus c’est long, moins c’est bon.\n\n\n\n Dossier zip à télécharger \n \nSource : MathémaTICE n°80, mai 2022, d’après une idée d’Adrien Willm, avec quelques modifications effectuées par l’équipe d’Aurillac.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Projet - Dessine ta rue !"
    ]
  },
  {
    "objectID": "05_base/base_cours.html",
    "href": "05_base/base_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Un ordinateur est une machine qui traite de l’information. Pour comprendre comment, nous devons d’abord expliquer comment l’information est représentée.\nEn effet, il faut bien faire la différence entre l’information et sa représentation. Par exemple, si on considère la valeur 17, tout le monde pensera à représenter cette valeur par les chiffres 1 et 7.\nMais on peut imaginer beaucoup d’autres possibilités, par exemple, les chiffres romains, la numération inca, ou encore le binaire. Et bien d’autres…",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "05_base/base_cours.html#introduction",
    "href": "05_base/base_cours.html#introduction",
    "title": "Cours",
    "section": "",
    "text": "Un ordinateur est une machine qui traite de l’information. Pour comprendre comment, nous devons d’abord expliquer comment l’information est représentée.\nEn effet, il faut bien faire la différence entre l’information et sa représentation. Par exemple, si on considère la valeur 17, tout le monde pensera à représenter cette valeur par les chiffres 1 et 7.\nMais on peut imaginer beaucoup d’autres possibilités, par exemple, les chiffres romains, la numération inca, ou encore le binaire. Et bien d’autres…",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "05_base/base_cours.html#la-base-10",
    "href": "05_base/base_cours.html#la-base-10",
    "title": "Cours",
    "section": "2. La base 10",
    "text": "2. La base 10\nLa représentation usuelle des nombres est une représentation décimale et positionnelle. Cela signifie :\n\nque les nombres sont représentés par une séquence de chiffres de \\(0\\) à \\(9\\) inclus. Il y a bien dix chiffres différents utilisés, d’où le terme décimal ;\nque la position de chaque chiffre dans la séquence permet d’associer ce chiffre à une puissance de 10.\n\nDans cette représentation usuelle, 10 est appelé la base. On parle aussi de représentation en base 10.\n\n\n\n\n\n\nExemple\n\n\n\nPar exemple, la représentation :\n\\[1234\\]\nsignifie que le nombre est composé de:\n\n\\(4\\) unités, ou \\(4\\times 10^0\\);\n\\(3\\) dizaines, ou \\(3\\times 10^1\\);\n\\(2\\) centaines, ou \\(2\\times 10^2\\);\n\\(1\\) millier, ou \\(1\\times 10^3\\);\n\nCe qui s’écrit : \\(1234 = 1\\times 10^3 + 2\\times 10^2 + 3\\times 10^1 + 4\\times 10^0\\)\n\n\nOn voit donc que les puissances de \\(10\\) associées aux différentes positions (aux différents chiffres) vont en décroissant quand on lit le nombre de gauche à droite, et que la puissance \\(10^0\\) correspond au chiffre des unités.\nOn note également que la base donne le nombre de chiffres que l’on peut utiliser pour représenter les nombres. En base 10, on peut utiliser 10 chiffres différents, à savoir les chiffres de \\(0\\) à \\(9\\) inclus.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "05_base/base_cours.html#généralisation",
    "href": "05_base/base_cours.html#généralisation",
    "title": "Cours",
    "section": "3. Généralisation",
    "text": "3. Généralisation\nCes idées se généralisent dans n’importe quelle base. Fixons à partir de maintenant une base \\(b\\geq 2\\).\nNous allons maintenant rencontrer des nombres écrits dans différentes bases. Pour éviter les confusions, nous indiquerons la base utilisée en indice. Le nombre de l’exemple ci-dessous s’écrit donc \\(1234_{10}\\).\nEn base \\(b\\), nous utiliserons \\(b\\) chiffres : \\(0\\), \\(1\\), \\(2\\), …, \\(b-1\\).\nLe nombre :\n\\[{d_n\\cdots d_0}_b\\]\nreprésente la valeur :\n\\[N = d_n\\times b^n + d_{n-1}\\times b^{n-1}+\\cdots+d_0\\times b^0\\]\noù tous les \\(d_i\\) sont des chiffres dans \\(\\{0,\\ldots b-1\\}\\).\n\n\n\n\n\n\nExemple\n\n\n\nEn base 5, il y a cinq chiffres : 0, 1, 2, 3 et 4.\nComptons un peu en base 5 :\n\n\n\n\n\n\n\n\nBase 10\nBase 5\n\n\n\n\n\n0\n0\nPas de différence …\n\n\n1\n1\nPas de différence …\n\n\n2\n2\nPas de différence …\n\n\n3\n3\nPas de différence …\n\n\n4\n4\nPas de différence …\n\n\n5\n10\nPlus de possibilité pour les unités, on ajoute un chiffre à gauche\n\n\n6\n11\nOn augmente les unités\n\n\n7\n12\nOn augmente les unités\n\n\n8\n13\nOn augmente les unités\n\n\n9\n14\nOn augmente les unités\n\n\n10\n20\nOn ne peut plus augmenter les unités, on augmente le chiffre de rang suivant\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nQuel sera le premier entier, en base 10, qui s’écrit en base 5 avec trois chiffres ? Avec quatre chiffres ?\n\n\n\nPassage de la base \\(b\\) à la base 10\nPour passer de la base \\(b\\) à la base 10, c’est facile, il suffit d’utiliser la définition :\n\\[{d_n\\cdots d_0}_b = (d_n\\times b^n + d_{n-1}\\times b^{n-1}+\\cdots+d_0\\times b^0)_{10}\\]\n\n\n\n\n\n\nExemple\n\n\n\nExemple avec la base 5.\nConsidérons le nombre \\(N=134_5\\). Par définition, on a :\n\\[N=4\\times 5^0 + 3\\times 5^1 + 1\\times 5^2 = 4+15+25=44_{10}\\]\n\n\n\n\nPassage de la base 10 à la base \\(b\\)\nC’est un peu plus difficile. Pour convertir un nombre donné en base 10 dans une base \\(b\\), on procède par divisions euclidiennes successives par \\(b\\). Les restes obtenus sont les chiffres de l’écriture du nombre en base \\(b\\).\n\n\n\n\n\n\nExemple\n\n\n\nOn reste avec \\(b=5\\). Soit \\(N=64_{10}\\) : on souhaite écrire \\(N\\) en base 5.\nOn effectue pour cela la suite de divisions suivante :\n\nOn continue les divisions successives jusqu’à obtenir un quotient nul.\nLes restes successifs (sur fond bleu) forment le nombre en base 5, en les lisant de la droite vers la gauche : \\(64_{10}=224_5\\).\n\n\nVoyons maintenant les exemples de la base 2 et de la base 16 qui sont les plus utilisées en informatique.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "05_base/base_cours.html#la-base-2",
    "href": "05_base/base_cours.html#la-base-2",
    "title": "Cours",
    "section": "4. La base 2",
    "text": "4. La base 2\nEn base 2, nous ne disposons donc que des deux chiffres 0 et 1. On parle de système binaire.\nUn chiffre binaire, binary digit en anglais est appelé en abrégé un bit.\nVoir cet article du blog au sujet des unités de mesures binaires.\nVoici comment compter jusqu’à 10 en base 2 :\n\n\n\n\n\n\n\n\nNombre en décimal\nNombre en binaire\n\n\n\n\n\n0\n0\nPas de différence …\n\n\n1\n1\nPas de différence …\n\n\n2\n10\nLe premier rang ayant été rempli, on passe au suivant !\n\n\n3\n11\nOn re-remplit le rang 1.\n\n\n4\n100\nLe rang 2 est plein, le rang 1 aussi, qu’à cela ne tienne, on passe au suivant.\n\n\n5\n101\nOn continue en suivant la même méthode.\n\n\n6\n110\nOn continue en suivant la même méthode.\n\n\n7\n111\nOn continue en suivant la même méthode.\n\n\n8\n1000\nOn commence le rang 4.\n\n\n9\n1001\nOn continue comme tout à l’heure.\n\n\n10\n1010\nOn continue comme tout à l’heure.\n\n\n…\n…\n…\n\n\n\nLes nombres en base 2 ont très vite beaucoup de chiffres. Pour faciliter la lecture, on a l’habitude de regrouper ces chiffres par paquets de 4 à partir de la droite.\n\nConversion de la base 2 à la base 10\nDans ce sens, la conversion est facile, il suffit d’appliquer la définition.\nPrenons le nombre \\(1101\\; 0011_2\\). Il s’étale sur 8 bits, on applique la méthode générale :\n\\(1101\\; 0011_2 = 1\\times 2^7 + 1\\times 2^6 + 0\\times 2^5 + 1\\times 2^4 + 0\\times 2^3 + 0\\times 2^2 + 1\\times 2^1 + 1\\times 2^1 = 211_{10}\\).\n\n\nConversion de la base 10 à la base 2\nOn procède par divisions euclidiennes successives.\nConvertissons \\(47_{10}\\) en base 2 :\n\nOn a donc \\(47_{10}=10\\;1111_2\\).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "05_base/base_cours.html#la-base-16",
    "href": "05_base/base_cours.html#la-base-16",
    "title": "Cours",
    "section": "5. La base 16",
    "text": "5. La base 16\nComme nous l’avons déjà vu, l’écriture d’un nombre en base 2 est longue. Pour avoir des nombres plus “compacts” tout en restant lié au binaire, les informaticiens utilisent souvent la base 16 : c’est le système hexadécimal.\nEn base 16, on utilise 16 chiffres, alors que notre numération usuelle, en base 10, n’en possède que 10. Quels symboles choisir pour les 6 chiffres manquants ? On utilise les six premières lettres de l’alphabet !\n\n\n\nBinaire (base 2)\nDécimal (base 10)\nHexadécimal (base 16)\n\n\n\n\n0\n0\n0\n\n\n1\n1\n1\n\n\n10\n2\n2\n\n\n11\n3\n3\n\n\n100\n4\n4\n\n\n101\n5\n5\n\n\n110\n6\n6\n\n\n111\n7\n7\n\n\n1000\n8\n8\n\n\n1001\n9\n9\n\n\n1010\n10\nA\n\n\n1011\n11\nB\n\n\n1100\n12\nC\n\n\n1101\n13\nD\n\n\n1110\n14\nE\n\n\n1111\n15\nF\n\n\n\nOn observe que tous les chiffres de la base 16 sont tous les nombres que l’on peut coder en binaire sur 4 bits. Dans l’écriture en base 2 d’un nombre, on a vu que les bits sont regroupés par quatre pour plus de lisibilité : \\(1101\\; 0011_2\\). Chaque groupe de quatre correspond donc à un chiffre en base 16. On a donc \\(1101\\; 0011_2 = D3_{16}\\).\nLes méthodes de conversion restent les mêmes.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "05_base/base_cours.html#quelques-remarques-pour-finir",
    "href": "05_base/base_cours.html#quelques-remarques-pour-finir",
    "title": "Cours",
    "section": "6. Quelques remarques pour finir",
    "text": "6. Quelques remarques pour finir\n\nChiffres de poids fort, de poids faible\nDans la représentation positionnelle usuelle, le chiffre le plus à gauche est associé à une puissance plus élevée de la base. On parle donc de chiffre de “poids fort” ; le chiffre étant associé à la puissance la plus faible est appel chiffre de “poids faible”. En particulier, en binaire, on parle de bit de poids fort et bit de poids faible.\n\n\nMultiplier par la base\nDans toutes les bases, on peut aisément multiplier par la base en ajoutant des zéros à droite :\n\n\n\n\n\n\nÀ retenir\n\n\n\nDans toute base \\(b\\), ajouter \\(k\\) zéros à droite revient à multiplier par \\(b^k\\).\n\n\nPar exemple, en binaire, multiplier par 2 revient à ajouter un zéro à la fin du nombre tout comme on ajoute un zéro à la fin du nombre écrit en base 10 quand on la multiplie par 10.\n\n\nCombien de nombres représentables sur \\(n\\) bits ?\nEnfin, l’observation suivante aura toute son importance dans la suite.\nConsidérons par exemple la base 2 : combien de nombres différents peut-on écrire avec \\(n\\) bits ?\nChaque bit ayant deux valeurs possibles (0 ou 1), nous obtenons \\(2^n\\) nombres distincts.\n\\[\\underbrace{0\\cdots 0_2}_{n\\text{ chiffres}} = 0\\]\nà:\n\\[\\underbrace{1\\cdots 1_b}_{n\\text{ chiffres}} = 2^n-1.\\]\n\n\n\n\n\n\nÀ retenir\n\n\n\nEn base \\(2\\), il y a \\(2^n\\) nombres (entiers positifs) représentables sur \\(n\\) bits : les nombres de \\(0\\) à \\(2^n-1\\).\n\n\n\n\n\n\n\n\nExercice\n\n\n\nDémontrer que \\(\\underbrace{1\\cdots 1_2}_{n\\text{ chiffres}} = 2^n-1.\\)\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nNous allons démontrer le résultat général en base \\(b\\).\nOn a : \\(\\underbrace{(b-1)\\cdots (b-1)_b}_{n\\text{ chiffres}} = (b-1)\\times b^{n-1}+\\ldots+(b-1)\\times b^1+(b-1)\\times b^0\\). D’où, en développant chacun des produits :\n\\[\\underbrace{(b-1)\\cdots (b-1)_b}_{n\\text{ chiffres}} = b^{n}-b^{n-1}+b^{n-1}-b^{n-2}+\\ldots+b^2-b+b-1.\\]\nLes termes se simplifient tous, sauf le premier et le dernier. On a donc :\n\\[\\underbrace{(b-1)\\cdots (b-1)_b}_{n\\text{ chiffres}} = b^n-1.\\]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "05_base/base_cours.html#addition-posée-en-binaire",
    "href": "05_base/base_cours.html#addition-posée-en-binaire",
    "title": "Cours",
    "section": "7. Addition posée en binaire",
    "text": "7. Addition posée en binaire\nOn peut poser une addition en base 2 avec la même technique que pour l’addition des nombres écrits en base 10. L’addition des bits suit les règles suivantes :\n\n\\(0+0\\) donne \\(0\\) avec une retenue égale à \\(0\\) ;\n\\(0+1\\) donne \\(1\\) avec une retenue égale à \\(0\\) ;\n\\(1+0\\) donne \\(1\\) avec une retenue égale à \\(0\\) ;\n\\(1+1\\) donne \\(0\\) avec une retenue égale à \\(1\\).\n\nExemple de l’addition de \\(11_{10}=1011_2\\) et de \\(13_{10}=1101_2\\) (les retenues sont en rouge) :\n\nLa somme obtenue \\(1\\;1000_2\\) correspond bien à l’entier \\(24_{10}\\) codé en binaire. On remarque qu’il a fallu un bit supplémentaire pour coder la somme. Si on travaille avec une taille d’entiers fixe de 4 bits, alors le bit de poids fort sera ignoré, et on obtiendra seulement \\(1000_2\\) comme résultat, c’est-à-dire 8. Autrement dit, sur 4 bits, quand on dépasse la capacité de \\(2^4-1=15\\), on repart de zéro : \\(24=2^4+8\\). On dit que le calcul se fait modulo \\(2^4\\).\nEn complément, vous pouvez regarder la vidéo “Le binaire, c’est quoi ?” dans cet article.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "05_base/index.html",
    "href": "05_base/index.html",
    "title": "Programme",
    "section": "",
    "text": "Toute machine informatique manipule une représentation des données dont l’unité minimale est le bit 0/1, ce qui permet d’unifier logique et calcul. Les données de base sont représentées selon un codage dépendant de leur nature : entiers, flottants, caractères et chaînes de caractères. Le codage conditionne la taille des différentes valeurs en mémoire.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nÉcriture d’un entier positif dans une base b ⩾ 2\nPasser de la représentation d’une base dans une autre.\nLes bases 2, 10 et 16 sont privilégiées.\n\n\nReprésentation binaire d’un entier relatif\nÉvaluer le nombre de bits nécessaires à l’écriture en base 2 d’un entier, de la somme ou du produit de deux nombres entiers. Utiliser le complément à 2.\nIl s’agit de décrire les tailles courantes des entiers (8, 16, 32 ou 64 bits). Il est possible d’évoquer la représentation des entiers de taille arbitraire de Python.\n\n\nReprésentation approximative des nombres réels : notion de nombre flottant\nCalculer sur quelques exemples la représentation de nombres réels : 0.1, 0.25 ou 1/3.\n0.2 + 0.1 n’est pas égal à 0.3. Il faut éviter de tester l’égalité de deux flottants. Aucune connaissance précise de la norme IEEE-754 n’est exigible.\n\n\nValeurs booléennes : 0, 1. Opérateurs booléens : and, or, not. Expressions booléennes\nDresser la table d’une expression booléenne.\nLe ou exclusif (xor) est évoqué. Quelques applications directes comme l’addition binaire sont présentées. L’attention des élèves est attirée sur le caractère séquentiel de certains opérateurs booléens.\n\n\nReprésentation d’un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode\nIdentifier l’intérêt des différents systèmes d’encodage. Convertir un fichier texte dans différents formats d’encodage.\nAucune connaissance précise des normes d’encodage n’est exigible."
  },
  {
    "objectID": "05_base/index.html#programme",
    "href": "05_base/index.html#programme",
    "title": "Programme",
    "section": "",
    "text": "Toute machine informatique manipule une représentation des données dont l’unité minimale est le bit 0/1, ce qui permet d’unifier logique et calcul. Les données de base sont représentées selon un codage dépendant de leur nature : entiers, flottants, caractères et chaînes de caractères. Le codage conditionne la taille des différentes valeurs en mémoire.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nÉcriture d’un entier positif dans une base b ⩾ 2\nPasser de la représentation d’une base dans une autre.\nLes bases 2, 10 et 16 sont privilégiées.\n\n\nReprésentation binaire d’un entier relatif\nÉvaluer le nombre de bits nécessaires à l’écriture en base 2 d’un entier, de la somme ou du produit de deux nombres entiers. Utiliser le complément à 2.\nIl s’agit de décrire les tailles courantes des entiers (8, 16, 32 ou 64 bits). Il est possible d’évoquer la représentation des entiers de taille arbitraire de Python.\n\n\nReprésentation approximative des nombres réels : notion de nombre flottant\nCalculer sur quelques exemples la représentation de nombres réels : 0.1, 0.25 ou 1/3.\n0.2 + 0.1 n’est pas égal à 0.3. Il faut éviter de tester l’égalité de deux flottants. Aucune connaissance précise de la norme IEEE-754 n’est exigible.\n\n\nValeurs booléennes : 0, 1. Opérateurs booléens : and, or, not. Expressions booléennes\nDresser la table d’une expression booléenne.\nLe ou exclusif (xor) est évoqué. Quelques applications directes comme l’addition binaire sont présentées. L’attention des élèves est attirée sur le caractère séquentiel de certains opérateurs booléens.\n\n\nReprésentation d’un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode\nIdentifier l’intérêt des différents systèmes d’encodage. Convertir un fichier texte dans différents formats d’encodage.\nAucune connaissance précise des normes d’encodage n’est exigible."
  },
  {
    "objectID": "06_relatif/relatifs_cours.html",
    "href": "06_relatif/relatifs_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Nous allons maintenant étudier la représentation des entiers relatifs en base 2.\nTout le problème est de coder le signe du nombre, et plus seulement sa valeur.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "06_relatif/relatifs_cours.html#première-idée-le-bit-de-signe",
    "href": "06_relatif/relatifs_cours.html#première-idée-le-bit-de-signe",
    "title": "Cours",
    "section": "1. Première idée : le bit de signe",
    "text": "1. Première idée : le bit de signe\nUne première idée consiste à décider que : lorsqu’on travaille avec une représentation binaire sur \\(n\\) bits, on réserve le bit de poids fort pour coder le signe. 1 va coder le signe \\(-\\) et 0 le signe \\(+\\). Les \\(n-1\\) bits restants codent la valeur absolue du nombre.\n\n\n\n\n\n\nExemple\n\n\n\nEn travaillant sur 8 bits (soit 1 octet), l’entier positif \\(5_{10}\\) sera codé par \\(0000\\;0101_2\\) et l’entier négatif \\(-5_{10}\\) sera codé par \\(1000\\;0101_2\\).\n\n\nCette première idée est une mauvaise idée ! En effet, que dire des deux entiers \\(0000\\;0000_2\\) et \\(1000\\;0000_2\\) ? Ils sont égaux, respectivement à \\(+0\\) et à \\(-0\\), donc ils sont égaux. Il n’est pas souhaitable qu’un même nombre possède deux représentations différentes.\nDe plus, cette représentation pose un autre problème plus grave ! Considérons par exemple le codage de \\(3_{10}\\) sur 4 bits. On a \\(3_{10} = 0011_2\\) et donc \\(-3_{10} = 1011_2\\). Calculons maintenant leur somme : on s’attend à trouver zéro :\n\nmais le résultat correspond à la représentation de \\(-4\\) !",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "06_relatif/relatifs_cours.html#le-complément-à-2",
    "href": "06_relatif/relatifs_cours.html#le-complément-à-2",
    "title": "Cours",
    "section": "2. Le complément à 2",
    "text": "2. Le complément à 2\n\nLe principe\nPour représenter un entier relatif \\(R\\) en base 2, on commence par choisir le nombre de bits \\(n\\) de la représentation.\n\n\n\n\n\n\nDéfinition et règles de représentation\n\n\n\n\nLe complément à \\(2\\) d’un nombre \\(R\\) est le nombre \\(2^n-R\\).\nLes nombres positifs sont représentés par leur codage binaire usuel.\nLes nombres négatifs sont représentés par le complément à \\(2\\) de leur valeur absolue.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nConsidérons le codage de l’entier \\(+12\\) sur 8 bits. Il s’agit d’un entier positif, on le code donc comme vu précédemment et on obtient : \\(+12_{10} = 0000\\;1100_2\\).\nConsidérons \\(-12\\) maintenant. Son complément à 2 vaut \\(2^8-12=244\\) dont la représentation binaire est \\(1111\\;0100_2\\). \\(-12\\) est donc représenté par le nombre \\(1111\\;0100_2\\) en binaire sur 8 bits.\n\n\n“Truc” pratique : pour obtenir la représentation d’un nombre négatif, par exemple de \\(-12\\) :\n\non commence par coder sa valeur absolue 12 : \\(0000\\;1100\\) ;\non inverse tous les bits : \\(1111\\;0011\\) ;\non ajoute 1 (attention aux retenues !) : \\(1111\\;0100\\).\n\nDe plus, ce truc fonctionne dans les deux sens : en partant d’un nombre négatif, on retrouve aussi son opposé :\n\non considère \\(-12\\) : \\(1111\\;0100\\) ;\non inverse tous les bits : \\(0000\\;1011\\) ;\non ajoute 1 : \\(1111\\;1100\\). On retrouve bien 12.\n\nAvec cette convention, zéro n’a plus qu’une seule représentation. De plus, on peut poser des additions de façon habituelle.\nReprenons l’exemple de l’entier \\(3_{10} = 0011_2\\) codé sur 4 bits. \\(-3_{10}\\) sera codé par \\(2^4-3=13\\), donc par \\(1101_2\\). On obtient bien zéro en les additionnant (on oublie la dernière retenue car on reste sur 4 bits) :\n\n\n\nCombien de nombres ?\nNous savons que, sur \\(n\\) bits, nous pouvons représenter \\(2^n\\) entiers naturels : tous les entiers de \\(0\\) à \\(2^n-1\\).\nAvec le complément à 2 :\n\nla première moitié de ces entiers va représenter les \\(2^{n-1}\\) premiers entiers positifs : de \\(0\\) à \\(2^{n-1}-1\\),\nla seconde moitié va représenter les \\(2^{n-1}\\) premiers entiers négatifs : de \\(-1\\) à \\(-2^{n-1}\\).\n\nAvec le complément à deux, \\(-1\\) sera représenté par \\(2^n-1\\), soit \\(11111\\ldots 1111\\).\nSur un axe gradué, voici comment les nombres relatifs s’organisent :\n\nOn remarque que :\n\nla représentation d’un nombre positif commence par un bit de poids fort égal à 0.\nla représentation d’un nombre négatif commence par un bit de poids fort égal à 1.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "06_relatif/relatifs_cours.html#cas-concrets",
    "href": "06_relatif/relatifs_cours.html#cas-concrets",
    "title": "Cours",
    "section": "3. Cas concrets",
    "text": "3. Cas concrets\nCouramment, les entiers sont codés sur 8, 16, 32 ou 64 bits dans les langages de programmation usuels.\n\n\n\nEn codant sur …\nOn peut aller de …\njusqu’à …\n\n\n\n\n8 bits\n-128\n127\n\n\n16 bits\n-32 768\n32 767\n\n\n32 bits\n-2 147 483 648\n2 147 483 647\n\n\n64 bits\n-9 223 372 036 854 775 808\n9 223 372 036 854 775 807\n\n\n\nEn Python, la taille des entiers avec lesquels on peut travailler n’est limitée que par la mémoire disponible. Dans d’autres langages, il faut déclarer des variables de types différents en fonction des limites de valeurs envisagées. Par exemple en C, un char codera sur un octet un entier compris entre \\(-128\\) et \\(127\\), et un short int codera sur 2 octets un entier compris entre \\(-32\\; 768\\) et \\(32\\;767\\). long int utilisera 4 octets.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "07_flottants/flottants_cours.html",
    "href": "07_flottants/flottants_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Commençons tout de suite ce chapitre par une triste nouvelle : il est impossible de représenter en binaire tous les nombres réels. Certains d’entre eux, en effet, ont des caractéristiques problématiques, comme \\(\\sqrt{2}\\) ou \\(\\pi\\) par exemple : ce sont des nombres irrationnels, c’est-à-dire des nombres réels que l’on ne peut pas écrire sous la forme d’une fraction de deux entiers \\(\\frac{a}{b}\\). L’écriture décimale de ces nombres, avec une virgule, comporte une infinité de chiffres après la virgule, sans régularité ni schéma périodique. Une représentation en machine ne pouvant être infinie, ces nombres ne peuvent pas être codés dans un ordinateur.\nParmi les nombres rationnels, seuls les nombres décimaux peuvent être codés de manière exacte en binaire. Les nombres décimaux sont en effet ceux qui ont un nombre fini de chiffres après la virgule. Pour les autres nombres, on aura une représentation approchée.\nLes nombres à virgule, sont ici appelés des flottants.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "07_flottants/flottants_cours.html#conversion-en-base-2",
    "href": "07_flottants/flottants_cours.html#conversion-en-base-2",
    "title": "Cours",
    "section": "1. Conversion en base 2",
    "text": "1. Conversion en base 2\nComment écrire un nombre décimal en base 2 ?\n\n\n\n\n\n\nExemple\n\n\n\nPrenons par exemple \\(x=10,125_{10}\\). Tout comme pour les entiers, cette écriture peut se décomposer suivant les puissances de 10 : \\(x=10,125 = 1\\times 10^1 + 0\\times 10^0 + 1\\times 10^{-1} + 2\\times 10^{-2} + 5\\times 10^{-3}\\).\nL’écriture sous forme de flottant en base 2 repose sur le même type de décomposition, mais avec des puissances de 2.\nPour la partie entière, nous savons faire : \\(10_{10}=1010_2\\).\nPour la partie décimale :\n\non multiplie \\(0,125\\) par \\(2\\) : \\(0,125\\times 2 = 0,25\\) : partie entière \\(0\\).\non multiplie \\(0,25\\) par \\(2\\) : \\(0,25\\times 2 = 0,5\\) : partie entière \\(0\\).\non multiplie \\(0,5\\) par \\(2\\) : \\(0,5\\times 2 = 1\\) : partie entière \\(1\\).\non s’arrête car il n’y a plus de partie décimale.\n\nLa suite des parties entières obtenues forme la partie décimale de l’écriture binaire :\n\\[10,125_{10} = 1010,001_2 = 1\\times 2^3 + 0\\times 2^2 + 1\\times 2^1 + 0\\times 2^0 + 0\\times 2^{-1}+0\\times 2^{-2}+1\\times 2^{-3}\\]\n\n\nIl se peut que l’algorithme précédent ne se termine jamais. Par exemple pour \\(x=0,35\\) nous obtenons \\(0\\) pour la partie entière, puis :\n\n\\(0,35\\times 2 = 0,7\\) donc \\(0\\) ;\n\\(0,7\\times 2 = 1,4\\) donc \\(1\\) pour la partie entière ;\n\\(0,4\\times 2 = 0,8\\) donc \\(0\\) ;\n\\(0,8\\times 2 = 1,6\\) donc \\(1\\) ;\n\\(0,6\\times 2 = 1,2\\) donc \\(1\\) ;\n\\(0,2\\times 2 = 0,4\\) donc \\(0\\) : on retrouve donc le résultat de la troisième étape et donc l’algorithme va boucler indéfiniment :\n\n\\[0,35_{10} =  0,0101100110110110110110...\\]\n\n\n\n\n\n\nÀ retenir\n\n\n\nLa représentation binaire est parfois infinie. En machine, elle est donc forcément tronquée et limitée à un certain nombre de bits. La représentation est alors approximative !\nExemple pour vous en convaincre :\n&gt;&gt;&gt; x = 0.1 + 0.2\n&gt;&gt;&gt; y = 0.3\n&gt;&gt;&gt; x == y\nFalse\nMorale :    On évitera toujours de comparer des flottants en Python.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "07_flottants/flottants_cours.html#conversion-de-la-base-2-à-la-base-10",
    "href": "07_flottants/flottants_cours.html#conversion-de-la-base-2-à-la-base-10",
    "title": "Cours",
    "section": "2. Conversion de la base 2 à la base 10",
    "text": "2. Conversion de la base 2 à la base 10\nDans ce sens, il suffit d’appliquer la définition de la décomposition du nombre en fonction des puissances de 2.\nPar exemple :\n\\[\\begin{array}{ccl}\n    11,1011_2 & = & 1\\times 2^1 + 1\\times 2^0+1\\times 2^{-1}+0\\times 2^{-2}+1\\times 2^{-3}+1\\times 2^{-4}\\\\\n              & = & 2 + 1 + 0,5 + 0,125 + 0,0625\\\\\n              & = & 3,6875_{10}\n\\end{array}\\]",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "07_flottants/flottants_cours.html#virgule-flottante",
    "href": "07_flottants/flottants_cours.html#virgule-flottante",
    "title": "Cours",
    "section": "3. Virgule flottante",
    "text": "3. Virgule flottante\nPour la représentation en machine, le principe s’inspire de l’idée de la notation scientifique d’un réel. En base 10 tout nombres réel peut s’écrire sous la forme \\(x=a\\times 10^p\\) où \\(a\\in[1;10[\\) et \\(p\\) est un entier relatif.\nPar exemple : \\(2022 = 2,022\\times 10^3\\).\nL’exposant de 10 représente le nombre de décalages de la virgule à effectuer (vers la droite pour un exposant positif, vers la gauche pour un exposant négatif) de la virgule qu’il faut affecter au nombre \\(2,022\\) pour retrouver le nombre d’origine.\nLe principe de la représentation binaire des décimaux est le même, mais tout est en base 2, les puissances de 10 sont donc remplacées par des puissances de 2.\nC’est la norme internationale IEEE-754 définit les formats de représentation des nombres à virgule flottante.\nConsidérons un nombre binaire \\(x\\). Nous l’écrivons sous la forme \\(\\pm 1,XXXXXX\\times 2^e\\) : c’est la “notation scientifique binaire”. Dans cette écriture, nous avons le signe, la suite des chiffres après la virgule qui s’appelle la mantisse \\(m=XXXXXX\\) et l’exposant \\(e\\).\n\n\n\n\n\n\nReprésentation des flottants\n\n\n\nAvant de pouvoir représenter un flottant, il faut choisir un format. Considérons une représentation sur 32 bits (usuellement on utilise 32 bits ou 64 bits).\n\nLe bit de poids fort est le bit de signe : si ce bit est à 1, le nombre est négatif, et s’il est à 0, le nombre est positif.\nLes 8 bits suivants représentent l’exposant.\nLes 23 bits suivants (bits de poids faible) représentent la mantisse.\n\n\n\n\nOn a bien au total \\(1+8+23 = 32\\) bits.\nReste à voir comment est codé l’exposant. Il faut en effet prévoir que celui-ci peut être négatif. La norme ne code pas l’exposant comme nous l’avons vu pour les entiers relatifs.\n\n\n\n\n\n\nCalcul de l’exposant\n\n\n\nPour un codage sur 32 bits, l’exposant est codé en excès à 127 : cela signifie que l’on peut coder uniquement les exposants compris entre \\(-126\\) et \\(+127\\) et qu’un exposant \\(e\\) est codé par la représentation binaire de \\(e+127\\).\n\n\nOn peut coder 256 entiers sur 8 bits : on pourrait donc aller de \\(-127\\) à \\(+128\\) mais ces deux valeurs sont des valeurs réservées qui ne doivent donc pas être utilisées.\nLe principe de l’excès à 127 permet de se ramener à un nombre positif pour l’exposant.\n\n\n\n\n\n\nExemple\n\n\n\nConsidérons le nombre \\(10,125_{10} = 1010,001_2\\) obtenu au début de ce chapitre. Cherchons quelle est sa représentation sur 32 bits (tout ce qui suit est écrit en base 2) :\n\nTout d’abord nous l’écrivons sous la forme “scientifique” : \\(1010,001=1,010001\\times 2^3\\).\nLe signe est positif : le bit de poids fort sera donc 0.\nL’exposant vaut 3, codé par \\(3+127=130\\) sur 8 bits (1 octet), ce qui donne : \\(130_{10}=1000 0010_2\\) codage auquel on ajoute des zéros à gauche pour obtenir 8 bits si le nombre de chiffres est inférieur à 8.\nLa mantisse est égale à \\(010001\\) : on complète par des zéros à droite pour arriver à 23 bits. On met cette fois-ci des zéros à droites : ils ne changent pas la valeur de la mantisse car il ne faut pas oublier qu’il s’agit de chiffres après la virgule ! Cela donne : \\(0100 0100 0000 0000 0000 000\\).\nOn met tout ensemble : le nombre \\(10,125\\) est codé par :\n\n\\[0100\\; 0001\\; 0010\\; 0010\\; 0000\\; 0000\\; 0000\\; 0000\\]\n\n\nCette écriture est un peu longue. On peut la compacter en écrivant ce nombre en hexadécimal. On rappelle que chaque bloc de 4 bit donne un chiffre de l’écriture en base 16.\nCela donne : \\(41220000_{16}\\).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "07_flottants/index.html",
    "href": "07_flottants/index.html",
    "title": "Programme",
    "section": "",
    "text": "Toute machine informatique manipule une représentation des données dont l’unité minimale est le bit 0/1, ce qui permet d’unifier logique et calcul. Les données de base sont représentées selon un codage dépendant de leur nature : entiers, flottants, caractères et chaînes de caractères. Le codage conditionne la taille des différentes valeurs en mémoire.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nÉcriture d’un entier positif dans une base b ⩾ 2\nPasser de la représentation d’une base dans une autre.\nLes bases 2, 10 et 16 sont privilégiées.\n\n\nReprésentation binaire d’un entier relatif\nÉvaluer le nombre de bits nécessaires à l’écriture en base 2 d’un entier, de la somme ou du produit de deux nombres entiers. Utiliser le complément à 2.\nIl s’agit de décrire les tailles courantes des entiers (8, 16, 32 ou 64 bits). Il est possible d’évoquer la représentation des entiers de taille arbitraire de Python.\n\n\nReprésentation approximative des nombres réels : notion de nombre flottant\nCalculer sur quelques exemples la représentation de nombres réels : 0.1, 0.25 ou 1/3.\n0.2 + 0.1 n’est pas égal à 0.3. Il faut éviter de tester l’égalité de deux flottants. Aucune connaissance précise de la norme IEEE-754 n’est exigible.\n\n\nValeurs booléennes : 0, 1. Opérateurs booléens : and, or, not. Expressions booléennes\nDresser la table d’une expression booléenne.\nLe ou exclusif (xor) est évoqué. Quelques applications directes comme l’addition binaire sont présentées. L’attention des élèves est attirée sur le caractère séquentiel de certains opérateurs booléens.\n\n\nReprésentation d’un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode\nIdentifier l’intérêt des différents systèmes d’encodage. Convertir un fichier texte dans différents formats d’encodage.\nAucune connaissance précise des normes d’encodage n’est exigible."
  },
  {
    "objectID": "07_flottants/TP_Bases_CORR.html",
    "href": "07_flottants/TP_Bases_CORR.html",
    "title": "TP : Bases 2, 10 et 16 en Python - Correction",
    "section": "",
    "text": "Lire la documentation des fonctions Python bin(), hex() et int().\nPrévoir ce qui s’affichera après chacune des instructions ci-dessous, puis tester en console :\n\n&gt;&gt;&gt; bin(123)\n&gt;&gt;&gt; int(\"0b1111\")\n&gt;&gt;&gt; int(\"0b10101\", 2)\n&gt;&gt;&gt; bin(0)\n&gt;&gt;&gt; int(\"0b101211\", 2)\n&gt;&gt;&gt; hex(2022)\n&gt;&gt;&gt; int(\"0xABC\", 16)\n\nbin(123)\n\n'0b1111011'\n\n\n\nint(b'1111')  # erreur dans l'énoncé\n\n1111\n\n\n\nint(\"0b10101\", 2)\n\n21\n\n\n\nbin(0)\n\n'0b0'\n\n\n\nint(\"0b101211\", 2) # le chiffre 2 n'existe pas en base 2 !\n\n47\n\n\n\nhex(2022)\n\n'0x7e6'\n\n\n\nint(\"0xABC\", 16)\n\n2748"
  },
  {
    "objectID": "07_flottants/TP_Bases_CORR.html#exercice-1",
    "href": "07_flottants/TP_Bases_CORR.html#exercice-1",
    "title": "TP : Bases 2, 10 et 16 en Python - Correction",
    "section": "",
    "text": "Lire la documentation des fonctions Python bin(), hex() et int().\nPrévoir ce qui s’affichera après chacune des instructions ci-dessous, puis tester en console :\n\n&gt;&gt;&gt; bin(123)\n&gt;&gt;&gt; int(\"0b1111\")\n&gt;&gt;&gt; int(\"0b10101\", 2)\n&gt;&gt;&gt; bin(0)\n&gt;&gt;&gt; int(\"0b101211\", 2)\n&gt;&gt;&gt; hex(2022)\n&gt;&gt;&gt; int(\"0xABC\", 16)\n\nbin(123)\n\n'0b1111011'\n\n\n\nint(b'1111')  # erreur dans l'énoncé\n\n1111\n\n\n\nint(\"0b10101\", 2)\n\n21\n\n\n\nbin(0)\n\n'0b0'\n\n\n\nint(\"0b101211\", 2) # le chiffre 2 n'existe pas en base 2 !\n\n47\n\n\n\nhex(2022)\n\n'0x7e6'\n\n\n\nint(\"0xABC\", 16)\n\n2748"
  },
  {
    "objectID": "07_flottants/TP_Bases_CORR.html#exercice-2",
    "href": "07_flottants/TP_Bases_CORR.html#exercice-2",
    "title": "TP : Bases 2, 10 et 16 en Python - Correction",
    "section": "Exercice 2",
    "text": "Exercice 2\nLe but de cet exercice est d’étudier une fonction permettant de convertir en base 2 un nombre entier naturel donné en base 10.\nOn donne ci-dessous le code de la fonction dec_to_bin :\ndef dec_to_bin(n):\n    chaine_bin = ''\n    nombre = n\n    while nombre &gt; 0:\n        r = nombre % 2\n        nombre = nombre // 2\n        chaine_bin = str(r) + chaine_bin\n    return chaine_bin\n\nTester cette fonction avec quelques valeurs de \\(n\\) et vérifier qu’elle effectue bien la conversion attendue.\nQuel est la méthode utilisée ? Faire le lien avec un des exemples du cours.\nOn souhaite convertir le nombre \\(n=105\\) en binaire. Recopier et compléter le tableau d’état des variables lors de l’appel dec_to_bin(105). L’étape zéro correspond à l’initialisation, l’étape 1 à l’état des variables après le premier passage dans la boucle while.\n\n\n\nEtape\nchaine_bin\nnombre\nr\n\n\n\n\n0\n“”\n102\n/\n\n\n1\n…\n…\n…\n\n\n\nModifier la fonction afin que le préfixe 0b soit présent dans la chaîne retournée.\n\n\ndef dec_to_bin(n):\n    chaine_bin = ''\n    nombre = n\n    while nombre &gt; 0:\n        r = nombre % 2\n        nombre = nombre // 2\n        chaine_bin = str(r) + chaine_bin\n    return chaine_bin\n\n\ndec_to_bin(4)\n\n'100'\n\n\n\ndec_to_bin(21)\n\n'10101'\n\n\nLa méthode utilisée est celle des divisions successives en conservant les restes. C’est la méthode utilisée dans le cours.\nTableau d’exécution pour \\(n=105\\) :\n\n\n\nEtape\nchaine_bin\nnombre\nr\n\n\n\n\n0\n“”\n105\n/\n\n\n1\n“1”\n52\n1\n\n\n2\n“01”\n26\n0\n\n\n3\n“001”\n13\n0\n\n\n4\n“1001”\n6\n1\n\n\n5\n“01001”\n3\n0\n\n\n6\n“101001”\n1\n1\n\n\n7\n“1101001”\n0\n1\n\n\n\n\n# Vérification\ndec_to_bin(105)\n\n'1101001'\n\n\n\n# Modification demandée\n\ndef dec_to_bin_modif(n):\n    chaine_bin = ''\n    nombre = n\n    while nombre &gt; 0:\n        r = nombre % 2\n        nombre = nombre // 2\n        chaine_bin = str(r) + chaine_bin\n    return \"0b\"+chaine_bin\n\n# Vérification\n\nprint(dec_to_bin_modif(105))\n\n0b1101001"
  },
  {
    "objectID": "07_flottants/TP_Bases_CORR.html#exercice-3",
    "href": "07_flottants/TP_Bases_CORR.html#exercice-3",
    "title": "TP : Bases 2, 10 et 16 en Python - Correction",
    "section": "Exercice 3",
    "text": "Exercice 3\n\nÉcrire une fonction qui respecte les spécifications indiquées :\ndef add_2_bits(a: int, b: int) -&gt; str\n    \"\"\"a et b sont des bits égaux à 0 ou 1\n    retourne une chaine représentant en base 2\n    la somme de a et de b\"\"\"\nÉcrire une fonction analogue add_3_bits(a, b, c) qui retourne la somme de trois bits.\n\n\n def add_2_bits(a: int, b: int) -&gt; str:\n        \"\"\"a et b sont des bits égaux à 0 ou 1\n         retourne une chaine représentant en base 2\n         la somme de a et de b\"\"\"\n        if a == 1 and b == 1:\n            rep = \"10\"\n        elif a == 1 or b == 1:\n            rep = \"1\"\n        else:\n            rep = \"0\"\n        return rep\n\n# Vérification\n\nassert add_2_bits(0,0) == \"0\"\nassert add_2_bits(1,0) == \"1\"\nassert add_2_bits(0,1) == \"1\"\nassert add_2_bits(1,1) == \"10\"\n\n\ndef add_3_bits(a: int, b: int, c: int) -&gt; str:\n    if a == 1 and b == 1:\n        if c == 1:\n            return \"11\"\n        else:\n            return \"10\"\n    elif a == 1 or b == 1:\n        if c == 1:\n            return \"10\"\n        else:\n            return \"1\"\n    else:\n        if c == 1:\n            return \"1\"\n        else:\n            return \"0\"\n        \n\n# Vérification\n\nassert add_3_bits(0,0,0) == \"0\"\nassert add_3_bits(1,0,0) == \"1\"\nassert add_3_bits(0,1,0) == \"1\"\nassert add_3_bits(0,0,1) == \"1\"\nassert add_3_bits(0,1,1) == \"10\"\nassert add_3_bits(1,0,1) == \"10\"\nassert add_3_bits(1,1,0) == \"10\"\nassert add_3_bits(1,1,1) == \"11\""
  },
  {
    "objectID": "07_flottants/TP_Bases_CORR.html#exercice-4",
    "href": "07_flottants/TP_Bases_CORR.html#exercice-4",
    "title": "TP : Bases 2, 10 et 16 en Python - Correction",
    "section": "Exercice 4",
    "text": "Exercice 4\nCoder la fonction complement_deux spécifiée ci-dessous. Vous pourrez utiliser la fonction dec_to_bin définie à l’exercice 2 (sans le préfixe 0b). Votre code devra tester les préconditions indiquées sur l’entier \\(n\\).\nUn jeu de tests unitaires est proposé ci-dessous : il permet de vérifier que votre fonction retourne bien ce qui est attendu.\ndef complement_deux(n:int, nbits:int)-&gt;str:\n    \"\"\"\n    Renvoie la notation en compléments à 2 de l'entier relatif n\n    sous la forme d'une chaîne de caractères\n    \n    Parameters\n    ----------\n    n : int Précondition -2**(nbits-1) &lt;= n &lt; 2**(nbits-1)\n    nbits : int\n    \n    Returns\n    -------\n    type str de longueur nbits\n    \"\"\"\n    pass\n\nprint(complement_deux(-12,8))\n# Jeu de tests unitaires\nassert complement_deux(0, 8) == \"00000000\"\nassert complement_deux(5, 8) == \"00000101\"\nassert complement_deux(2**7 - 1, 8) == \"01111111\"\nassert complement_deux(-2**7, 8) == \"10000000\"\nassert complement_deux(2**7 - 2, 8) == \"01111110\"\nassert complement_deux(-2**7 + 1, 8) == \"10000001\"\nassert complement_deux(-1, 8) == \"11111111\"\nassert complement_deux(-2, 8) == \"11111110\"\nprint(\"Bravo ! Tous les tests sont réussis !\")\nSortie attendue à l’exécution :\n11110100\nBravo ! Tous les tests sont réussis !\n\ndef complement_deux(n:int, nbits:int)-&gt;str:\n    \"\"\"\n    Renvoie la notation en compléments à 2 de l'entier relatif n\n    sous la forme d'une chaîne de caractères\n\n    Parameters\n    ----------\n    n : int Précondition -2**(nbits-1) &lt;= n &lt; 2**(nbits-1)\n    nbits : int\n\n    Returns\n    -------\n    type str de longueur nbits\n    \"\"\"\n    # Vérification de préconditions\n    assert type(n) == int and (-2**(nbits-1) &lt;= n &lt; 2**(nbits-1))\n    assert type(nbits) == int\n    \n    if n &gt;=0: # n est positif\n        rep = dec_to_bin(n)\n    else: # n est négatif\n        cplt = 2**nbits - abs(n)\n        rep = dec_to_bin(cplt)\n    # On complète la chaîne pour arriver à nbits\n    while len(rep) &lt; nbits:\n        rep = \"0\" + rep\n    return rep\n        \n\nprint(complement_deux(-12,8))\n# Jeu de tests unitaires\nassert complement_deux(0, 8) == \"00000000\"\nassert complement_deux(5, 8) == \"00000101\"\nassert complement_deux(2**7 - 1, 8) == \"01111111\"\nassert complement_deux(-2**7, 8) == \"10000000\"\nassert complement_deux(2**7 - 2, 8) == \"01111110\"\nassert complement_deux(-2**7 + 1, 8) == \"10000001\"\nassert complement_deux(-1, 8) == \"11111111\"\nassert complement_deux(-2, 8) == \"11111110\"\nprint(\"Bravo ! Tous les tests sont réussis !\")\n\n11110100\nBravo ! Tous les tests sont réussis !"
  },
  {
    "objectID": "07_flottants/TP_Bases_CORR.html#problème",
    "href": "07_flottants/TP_Bases_CORR.html#problème",
    "title": "TP : Bases 2, 10 et 16 en Python - Correction",
    "section": "Problème",
    "text": "Problème\nÉcrire une fonction ieee_754(x) qui prend en entrée un flottant x (en base 10) et qui retourne une chaine de caractères correspondant à la représentation de \\(x\\) selon la norme IEEE-754 sur 32 bits.\nConseils : vous pourrez décomposer le problème en plusieurs fonctions séparées pour traiter les étapes une par une.\n\ndef ieee_754(x: float) -&gt; str:\n    \n    \"\"\"Convertit le flottant x en binaire selon la norme ieee 754 sur 32 bits\n    Résultat retourné sous forme de chaîne de caractères\"\"\"\n    \n    # bit de signe\n    if x &gt;= 0:\n        chaine = \"0  \"\n    else:\n        chaine = \"1  \"\n        \n    n = abs(int(x)) # partie entière de x\n    f = abs(x) - n # partie décimale de x\n    n_bin = dec_to_bin(n) # partir entière de x en binaire\n    \n    # conversion en binaire de la partie décimale f, on se limite à 100 bits maximum\n    f_bin = \"\"\n    while f != 0 and len(f_bin) &lt; 100:\n        f = 2 * f\n        f_bin = f_bin + str(int(f))\n        f = f - int(f)\n        \n    # calcul de l'exposant\n    if n &gt;= 1:\n        e = len(n_bin) - 1\n        # mantisse\n        m = n_bin[1:] + f_bin\n    else:\n        # cas d'un nombre de partie entière nulle\n        # on cherche le premier 1 dans la partie fractionnaire\n        e = 0\n        compteur = 0\n        while f_bin[compteur] == \"0\":\n            compteur += 1\n        e = - (compteur + 1)\n        m = f_bin[compteur+1:]\n        \n    # codage de l'exposant\n    #print(f\"exposant : {e}\")\n    e = e + 127\n    e_bin = bin(e)[2:]\n    while len(e_bin) &lt; 8:\n        e_bin = \"0\" + e_bin\n    chaine = chaine + e_bin + \"  \"\n    \n    # mantisse : on renvoie une mantisse de taille 23 bits\n    if len(m) &gt; 23:\n        m = m[:23]\n    while len(m) &lt; 23:\n        m = m + \"0\"\n    chaine = chaine + m\n    return chaine\n\n\n# Vérification avec quelques exemples\nnb = [0.9218, 0.002125, 45.218, 126.725, 0.1, 0.333333333333333333333333333, -2.5]\nfor item in nb:\n    print(f\"codage de {item} :  {ieee_754(item)}\")\n\ncodage de 0.9218 :  0  01111110  11010111111101100010101\ncodage de 0.002125 :  0  01110110  00010110100001110010101\ncodage de 45.218 :  0  10000100  01101001101111100111011\ncodage de 126.725 :  0  10000101  11111010111001100110011\ncodage de 0.1 :  0  01111011  10011001100110011001100\ncodage de 0.3333333333333333 :  0  01111101  01010101010101010101010\ncodage de -2.5 :  1  10000000  01000000000000000000000\n\n\nRemarque : le site https://www.ultimatesolver.com/en/ieee-754 permet de vérifier ces réponses."
  },
  {
    "objectID": "08_booleens/booleens_essentiel.html#opérateurs-booléens-de-base",
    "href": "08_booleens/booleens_essentiel.html#opérateurs-booléens-de-base",
    "title": "S2 - Représentation de données - Types et valeurs de base",
    "section": "Opérateurs booléens de base",
    "text": "Opérateurs booléens de base\nDans le cours sur les bases de Python, nous avons déjà vu les opérateurs or, and et not.\n\nOpérateur OU\n!!! info “Définition” Soit \\(a\\) et \\(b\\) deux expressions :\n$$a\\textrm{ OU }b\\textrm{ est vrai }\\iff a\\textrm{ est vrai ou }b\\textrm{ est vrai}$$\nTable de vérité de l’opérateur OU (inclusif):\n\n\n\n\\(a\\)\n\\(b\\)\n\\(a\\) OU \\(b\\)\n\n\n\n\n1\n1\n1\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n\n\n\nOpérateur ET\n!!! info “Définition” Soit \\(a\\) et \\(b\\) deux expressions :\n$$a\\textrm{ ET }b\\textrm{ est vrai }\\iff a\\textrm{ est vrai et }b\\textrm{ est vrai}$$\nTable de vérité de l’opérateur ET :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(a\\) ET \\(b\\)\n\n\n\n\n1\n1\n1\n\n\n1\n0\n0\n\n\n0\n1\n0\n\n\n0\n0\n0\n\n\n\n\n\nOpérateur NON\n!!! info “Définition” Soit \\(a\\) une expression :\n$$(\\textrm{NON }a)\\textrm{ est vrai }\\iff a\\textrm{ est faux}$$\nTable de vérité de l’opérateur NON :\n\n\n\n\\(a\\)\nNON \\(a\\)\n\n\n\n\n1\n0\n\n\n0\n1"
  },
  {
    "objectID": "08_booleens/booleens_essentiel.html#le-ou-exclusif",
    "href": "08_booleens/booleens_essentiel.html#le-ou-exclusif",
    "title": "S2 - Représentation de données - Types et valeurs de base",
    "section": "Le ou exclusif",
    "text": "Le ou exclusif\nLe OU logique étant inclusif, on définit un opérateur spécifique pour le ou exclusif, appelé opérateur XOR.\n!!! info “Définition” Soit \\(a\\) et \\(b\\) deux expressions :\n$$a\\textrm{ XOR }b\\textrm{ est vrai }\\iff (a\\textrm{ est vrai et }b\\textrm{ est faux})\\textrm{ ou }(a\\textrm{ est faux et }b\\textrm{ est vrai})$$\nTable de vérité de l’opérateur XOR :\n\n\n\n\\(a\\)\n\\(b\\)\n\\(a\\) XOR \\(b\\)\n\n\n\n\n1\n1\n0\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n\nEn Python, le ou exclusif est note ^."
  },
  {
    "objectID": "08_booleens/index.html",
    "href": "08_booleens/index.html",
    "title": "Programme",
    "section": "",
    "text": "Toute machine informatique manipule une représentation des données dont l’unité minimale est le bit 0/1, ce qui permet d’unifier logique et calcul. Les données de base sont représentées selon un codage dépendant de leur nature : entiers, flottants, caractères et chaînes de caractères. Le codage conditionne la taille des différentes valeurs en mémoire.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nÉcriture d’un entier positif dans une base b ⩾ 2\nPasser de la représentation d’une base dans une autre.\nLes bases 2, 10 et 16 sont privilégiées.\n\n\nReprésentation binaire d’un entier relatif\nÉvaluer le nombre de bits nécessaires à l’écriture en base 2 d’un entier, de la somme ou du produit de deux nombres entiers. Utiliser le complément à 2.\nIl s’agit de décrire les tailles courantes des entiers (8, 16, 32 ou 64 bits). Il est possible d’évoquer la représentation des entiers de taille arbitraire de Python.\n\n\nReprésentation approximative des nombres réels : notion de nombre flottant\nCalculer sur quelques exemples la représentation de nombres réels : 0.1, 0.25 ou 1/3.\n0.2 + 0.1 n’est pas égal à 0.3. Il faut éviter de tester l’égalité de deux flottants. Aucune connaissance précise de la norme IEEE-754 n’est exigible.\n\n\nValeurs booléennes : 0, 1. Opérateurs booléens : and, or, not. Expressions booléennes\nDresser la table d’une expression booléenne.\nLe ou exclusif (xor) est évoqué. Quelques applications directes comme l’addition binaire sont présentées. L’attention des élèves est attirée sur le caractère séquentiel de certains opérateurs booléens.\n\n\nReprésentation d’un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode\nIdentifier l’intérêt des différents systèmes d’encodage. Convertir un fichier texte dans différents formats d’encodage.\nAucune connaissance précise des normes d’encodage n’est exigible."
  },
  {
    "objectID": "08_booleens/index.html#programme",
    "href": "08_booleens/index.html#programme",
    "title": "Programme",
    "section": "",
    "text": "Toute machine informatique manipule une représentation des données dont l’unité minimale est le bit 0/1, ce qui permet d’unifier logique et calcul. Les données de base sont représentées selon un codage dépendant de leur nature : entiers, flottants, caractères et chaînes de caractères. Le codage conditionne la taille des différentes valeurs en mémoire.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nÉcriture d’un entier positif dans une base b ⩾ 2\nPasser de la représentation d’une base dans une autre.\nLes bases 2, 10 et 16 sont privilégiées.\n\n\nReprésentation binaire d’un entier relatif\nÉvaluer le nombre de bits nécessaires à l’écriture en base 2 d’un entier, de la somme ou du produit de deux nombres entiers. Utiliser le complément à 2.\nIl s’agit de décrire les tailles courantes des entiers (8, 16, 32 ou 64 bits). Il est possible d’évoquer la représentation des entiers de taille arbitraire de Python.\n\n\nReprésentation approximative des nombres réels : notion de nombre flottant\nCalculer sur quelques exemples la représentation de nombres réels : 0.1, 0.25 ou 1/3.\n0.2 + 0.1 n’est pas égal à 0.3. Il faut éviter de tester l’égalité de deux flottants. Aucune connaissance précise de la norme IEEE-754 n’est exigible.\n\n\nValeurs booléennes : 0, 1. Opérateurs booléens : and, or, not. Expressions booléennes\nDresser la table d’une expression booléenne.\nLe ou exclusif (xor) est évoqué. Quelques applications directes comme l’addition binaire sont présentées. L’attention des élèves est attirée sur le caractère séquentiel de certains opérateurs booléens.\n\n\nReprésentation d’un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode\nIdentifier l’intérêt des différents systèmes d’encodage. Convertir un fichier texte dans différents formats d’encodage.\nAucune connaissance précise des normes d’encodage n’est exigible."
  },
  {
    "objectID": "09_texte/textes_cours.html",
    "href": "09_texte/textes_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Une chaîne de caractères est une suite ordonnée de caractères. Ces caractères peuvent être :\nEn machine, les caractères, comme toute autre information, est codée de façon numérique par un nombre binaire.\nLe problème qui se pose est que les lettres de l’alphabet, par exemple, ne sont pas les mêmes dans toutes les langues et des caractères. Il faut pouvoir coder des caractères aussi divers que : é, à, ô, ß, \\(\\Delta\\), ﺾ, ネ, 乻.\nDifférents systèmes d’encodage des caractères existent.\nPour une table de codage, il peut exister plusieurs encodages : ce sera le cas pour la table Unicode, présentée ci-dessous, pour laquelle plusieurs encodages existent (UTF-8, UTF-16, …).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "09_texte/textes_cours.html#le-code-ascii",
    "href": "09_texte/textes_cours.html#le-code-ascii",
    "title": "Cours",
    "section": "1. Le code ASCII",
    "text": "1. Le code ASCII\nDans les premiers temps de l’informatique, de nombreux systèmes de codage, incompatibles entre eux, existaient.\nEn 1960, l’organisation internationale de normalisation (International Standard Office : ISO) a créé la norme ASCII (American Standard Code for Information Interchange) pour écrire des textes en anglais.\nLa table ASCII fournit la correspondance entre 128 caractères et leur représentation binaire. Les caractères sont numérotés de 0 à 127. Comme \\(2^7=128\\),il suffit de 7 bits par caractère. Cependant, un octet est le plus souvent utilisé, le bit de poids fort, inutilisé, étant toujours égal à 0.\nDans le code ASCII, les codes des lettres minuscules et des lettres majuscules diffèrent d’un bit, le sixième. Par exemple “G” est codé par \\(71_{10}=0100\\;0111_2\\) et “g” est codé par \\(103_{10}=0110\\;0111_2\\). Cela revient à ajouter \\(32=2^5\\) pour passer du code de la majuscule au code de la minuscule.\nLes chiffres sont codés par le nombre binaire \\(0011\\;XXXX_2\\) où \\(XXXX_2\\) est la valeur du chiffre en binaire. Par exemple 5 est codé par \\(0011\\;0101_2\\).\nLe code ASCII d’un caractère étant composé de 8 bits, il peut aussi être représenté par un nombre hexadécimal à deux chiffres.\nVoici la table ASCII complète :\n\nLe code ASCII est suffisant pour écrire un texte en anglais ou pour écrire un programme informatique et il est encore très largement utilisé de nos jours, car il a l’avantage d’être léger.\nCependant, il est insuffisant pour représenter d’autres langues que l’anglais : pas de caractères accentués, de c-cédille, pas de caractères grecs, hébreux, arabes, chinois, …",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "09_texte/textes_cours.html#le-code-iso-8859-1",
    "href": "09_texte/textes_cours.html#le-code-iso-8859-1",
    "title": "Cours",
    "section": "2. Le code ISO-8859-1",
    "text": "2. Le code ISO-8859-1\nPour encoder les langues européennes occidentales, plusieurs extensions du code ASCII ont été définies par l’ISO, comme notamment la norme ISO-8859-1 (appelée aussi ISO-Latin-1). Avec cette norme :\n\nle codage des caractères présents dans la table ASCII est conservé ;\nchaque caractère est toujours codé sur un octet.\n\nOn exploite le bit de poids fort inutilisé par le codage ASCII : cela permet de coder \\(2^8=256\\) caractères, soir deux fois plus qu’avec le code ASCII.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "09_texte/textes_cours.html#le-code-unicode",
    "href": "09_texte/textes_cours.html#le-code-unicode",
    "title": "Cours",
    "section": "3. Le code Unicode",
    "text": "3. Le code Unicode\nCes extensions du code ASCII ne suffisent évidemment pas à encoder les caractères des langues non latines. Il a donc fallu créer une autre norme internationale : la norme Unicode, apparue au début des années 90.\nDans sa version 14.0 publiée en septembre 2021, la table Unicode compte 144 697 caractères couvrant plus de 150 écritures.\nUnicode est une table qui regroupe tous les caractères existant au monde, mais ne s’occupe pas de la façon dont les caractères sont codés dans la machine. Il existe pour cela plusieurs formats différents, le plus répandu étant l’encodage UTF-8.\nUTF-8 est un code à taille variable dans lequel les caractères sont représentés sur 1, 2, 3 ou 4 octets.\nLes 128 premiers caractères de la table UTF-8 sont compatibles avec le codage ASCII. Ainsi le codage UTF-8 d’un texte ne comportant que des caractères présents dans la table ASCII sera le même que le codage ASCII de ce texte.\nCe ne sera pas vrai pour un texte ISO-8859-1.\nIl importe donc, quand on veut décoder un texte, de savoir quel est le codage utilisé sous peine de décoder improprement les caractères, ce qui arrive par exemple lorsque l’encodage d’une page web n’est pas bien reconnu par le navigateur :\n\nOn représente en général un code UTF-8 sous la forme U+XXXX où XXXX est un nombre écrit en hexadécimal.\nEn voici quelques exemples :\n\n\n\nCode UTF-8\nCaractère\nÉcriture\n\n\n\n\nU+FEBE\nﺾ\nArabe\n\n\nU+05E6\nצ\nHébreu\n\n\nU+30CD\nネ\nJaponais katakana\n\n\nU+4E7B\n乻\nChinois\n\n\n\nLe site symbl.cc liste tous les caractères de la table Unicode.\n\n\n\n\n\n\nRemarque\n\n\n\nDepuis sa version 3, Python utilise l’encodage UTF-8 pour les chaînes de caractères.\nNous disposons en Python de deux fonctions liées à ce codage :\n\nchr(x) : retourne le caractère codé par l’entier \\(x\\) écrit en base 10 ;\nord(c) : retourne l’entier correspondant au caractère c (de type str).\n\n&gt;&gt;&gt; chr(244)\n'ô'\n&gt;&gt;&gt; ord(\"€\")\n8364",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "09_texte/textes_cours.html#convertir-un-fichier-dun-encodage-à-un-autre",
    "href": "09_texte/textes_cours.html#convertir-un-fichier-dun-encodage-à-un-autre",
    "title": "Cours",
    "section": "4. Convertir un fichier d’un encodage à un autre",
    "text": "4. Convertir un fichier d’un encodage à un autre\nPour convertir un fichier d’un encodage à un autre, on peut utiliser l’éditeur Notepad++ (sous Windows) ou son clone Notepadqq (sous Linux) dans lequel on trouve un menu “Encodage” comprenant par exemple une commande “convertir en UTF-8”.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "09_texte/textes_cours.html#ouverture-dun-fichier-texte-en-python",
    "href": "09_texte/textes_cours.html#ouverture-dun-fichier-texte-en-python",
    "title": "Cours",
    "section": "5. Ouverture d’un fichier texte en Python",
    "text": "5. Ouverture d’un fichier texte en Python\nUne bonne compréhension du problème de l’encodage des caractères permet d’éviter certaines erreurs lors de l’utilisation de fichiers textes en Python.\nConsidérons par exemple deux fichiers textes texte_ascii.txt et texte_utf-8.txt contenant le même texte, l’un étant encodé en ASCII étendu (c’est-à-dire en ISO-8859-1) et l’autre en UTF-8.\nLe programme ci-dessous ouvre ces fichiers l’un après l’autre et affiche leur contenu dans la console interactive.\nfrom io import open\n\nf = open(\"texte_ascii.txt\")\nfor ligne in f.readlines():\n    print(ligne)\nf.close()\n\nprint(\"---------\")\n\nf = open(\"texte_utf-8.txt\")\nfor ligne in f.readlines():\n    print(ligne)\nf.close()\nTout d’abord, le programme est exécuté sous Windows :\nCeci est un fichier texte\n\nencodé au format ASCII étendu\n\nVoici quelques mots avec des caractères spéciaux\n\ncomme par exemple forçat ou encore Niño ...\n---------\nCeci est un fichier texte\n\nencodÃ© au format UTF-8 Ã©tendu\n\nVoici quelques mots avec des caractÃ¨res spÃ©ciaux\n\ncomme par exemple forÃ§at ou encore NiÃ±o ...\nEt maintenant sous Linux :\nTraceback (most recent call last):\n  File \"/usr/lib/python3.10/idlelib/run.py\", line 578, in runcode\n    exec(code, self.locals)\n  File \"/home/fabrice/windows/lecture_fichier.py\", line 4, in &lt;module&gt;\n    for ligne in f.readlines():\n  File \"/usr/lib/python3.10/codecs.py\", line 322, in decode\n    (result, consumed) = self._buffer_decode(data, self.errors, final)\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 32: invalid continuation byte\nPourquoi cette différence ? La fonction open de Python essaie de lire le fichier texte en utilisant l’encodage du système d’exploitation dans lequel Python est utilisé.\n\nSous Windows, l’encodage du système est un dérivé de ISO-8859-1. Le fichier ASCII est donc bien lu et affiché, le fichier UTF-8, lui, est bien lu, mais les caractères ne sont pas affichés correctement.\nSous Linux, l’encodage du système est UTF-8. Le fichier ASCII provoque une erreur en lecture car Python s’attend par défaut à lire des caractères encodés en UTF-8.\n\nPour éviter ce type de problème et assurer la portabilité d’un programme d’un système d’exploitation à un autre, il est préférable de toujours indiquer l’encodage à la fonction open. Le programme suivant fonctionnera sous les deux systèmes et provoquera l’affichage attendu.\nfrom io import open\n\nf = open(\"texte_ascii.txt\", encoding=\"ISO-8859-1\")\nfor ligne in f.readlines():\n    print(ligne)\nf.close()\n\nprint(\"---------\")\n\nf = open(\"texte_utf-8.txt\", encoding=\"UTF-8\")\nfor ligne in f.readlines():\n    print(ligne)\nf.close()\nCeci est un fichier texte\n\nencodé au format ASCII étendu\n\nVoici quelques mots avec des caractères spéciaux\n\ncomme par exemple forçat ou encore Niño ...\n---------\nCeci est un fichier texte\n\nencodé au format UTF-8 étendu\n\nVoici quelques mots avec des caractères spéciaux\n\ncomme par exemple forçat ou encore Niño ...",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 4 - Représentation numérique des nombres et du texte",
      "Cours"
    ]
  },
  {
    "objectID": "10_p-uplets/exos_tuples.html",
    "href": "10_p-uplets/exos_tuples.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "10_p-uplets/exos_tuples.html#exercice-1",
    "href": "10_p-uplets/exos_tuples.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\nLa notation française pour les dates est jj/mm/aa, alors que la notation anglaise est aa/mm/jj.\nUne date étant composée de trois informations, elle peut être représentée par un tuple, par exemple : date = (21,11,18) pour le 21 novembre 2018.\n\nTester le programme ci-dessous et le corriger :\n\ndate = (24, 12, 20)\njour, mois = date\nif jour == 24 and mois == 12:\n    print(\"C'est Noël demain, les petits !\")\n\nÉcrire un programme qui à partir du tuple date = (21,11,18) affiche la date selon les deux formats :\n\n\nFormat français : 21/11/18\nFormat anglais : 18/11/21",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "10_p-uplets/exos_tuples.html#exercice-2",
    "href": "10_p-uplets/exos_tuples.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nUn point \\(A\\) de coordonnées \\(A(2 ; 7)\\) peut être représenté par un tuple : A = (2,7).\nL’abscisse et l’ordonnée d’un point \\(A\\) sont en général notées \\(x_A\\) et \\(y_A\\).\nOn considère la fonction :\ndef milieu(A, B):\n    xA, yA = A\n    xB, yB = B\n    xM = (xA + xB) / 2\n    yM = (yA + yB) / 2\n    return xM, yM\n\nParmi les appels suivants, quel est celui qui correct ?\n\nmilieu((2, 3, 4, 9))\nmilieu(2, 3, 4, 9)\nmilieu((2, 3), (4, 9))\nmilieu((2 ; 3), (4 ; 9))\n\nQuelle est la valeur retournée par l’appel suivant : milieu((2,3),(4,9)) ?\nOn utilise cette fonction dans le programme suivant :\nC = (2, 3)\nD = (4, 9)\nxE = milieu(C, D)\nprint(\"Le milieu a pour abscisse :\", xE)\nCorriger ce programme pour qu’il fonctionne.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "10_p-uplets/exos_tuples.html#exercice-3",
    "href": "10_p-uplets/exos_tuples.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\nCet exercice doit être fait après avoir étudié les tableaux.\nVoici un tableau qui répertorie des informations sur les adhérents d’un site internet :\n\n\n\nNom\nSexe\nAvatar\nAge\nAnnée d’adhésion\nMot de passe\n\n\n\n\nBERNARD\nF\nBebert\n19\n2019\nBibi2019*\n\n\nBONNET\nM\nBonbon\n22\n2017\n45trd ;*%GR\n\n\nDUBET\nM\nBud\n17\n2018\nBud17\n\n\nDURAND\nM\nRantanplan\n15\n2018\nOuahOuah\n\n\nFOURNIER\nF\nFifou\n21\n2016\n12051995\n\n\nMARTIN\nM\nTinmar\n23\n2017\nTitidu15\n\n\n\nOn peut le représenter par un tableau de tuples (un tuple pour chaque adhérent) :\nListeAdherents = [(\"BERNARD\", \"F\", \"Bebert\", 19, 2019, \"Bibi2019*\"), (\"BONNET\", \"M\", \"Bonbon\", 22, 2017, \"45trd ;*%GR\"),\n                  (\"DUBET\", \"M\", \"Bud\", 17, 2018, \"Bud17\"), (\"DURAND\", \"M\", \"Rantanplan\", 15, 2018, \"OuahOuah\"),\n                  (\"FOURNIER\", \"F\", \"Fifou\", 21, 2016, \"12051995\"), (\"MARTIN\", \"M\", \"Tinmar\", 23, 2017, \"Titidu15\")]\n\nSans utiliser l’ordinateur, prévoir ce qui est affiché par les instructions suivantes :\n\nprint(ListeAdherents[1])\nprint(ListeAdherents[1,2])\nprint(ListeAdherents[1][2])\nprint(ListeAdherents[2][1])\nprint(ListeAdherents[4][5])\n\nÉcrire une fonction qui prend en paramètre le tableau ListeAdherents, qui affiche la liste des avatars de tous les adhérents, et qui renvoie l’âge moyen de tous les adhérents (utiliser une boucle for).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "10_p-uplets/p_uplets.html",
    "href": "10_p-uplets/p_uplets.html",
    "title": "Cours",
    "section": "",
    "text": "Nous connaissons les types de données simples en Python. Ce sont les type int (nombres entiers), float (nombres flottants), bool (booléens). Le type str est aussi utilisé. Il est un peu moins simple. Un objet de type str est une chaîne de caractères qui s’écrit entre des guillemets ou des apostrophes. Un caractère est, pour simplifier, ce que l’on obtient par exemple avec les touches d’un clavier. Dans une chaîne, chaque caractère est repéré par un indice qui commence à 0. Avec la chaîne ch =\"exemple\", ch[0] est le caractère “e”, ch[1] est le caractère “x”, et ainsi de suite.\nCes types simples ne sont plus suffisants si nous avons besoin de garder en mémoire un grand nombre de valeurs comme dans le cas d’un traitement de données statistiques. Il en est de même si l’on souhaite regrouper des valeurs, par exemple afin d’avoir une variable représentant les coordonnées d’un point.\nL’objectif est donc de construire un type de variable capable de contenir plusieurs valeurs. Nous pouvons nous inspirer du type str et utiliser des indices pour repérer les éléments. Ceci amène à la construction des p-uplets, type tuple, et des tableaux, type list. Comme pour le type str, un objet t de type tuple n’est pas modifiable par une affectation t[i]=valeur. Un objet de type list est lui modifiable par une affectation ce qui autorise de nombreuses méthodes applicables à ces objets mais en contrepartie une grande vigilance sur leur utilisation. Un troisième type est présenté, le type dict pour les dictionnaires. La principale différence avec les listes est qu’un dictionnaire n’est pas ordonné. Un élément n’est pas repéré par un indice entier mais par une “clé”.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Cours"
    ]
  },
  {
    "objectID": "10_p-uplets/p_uplets.html#introduction-les-séquences-en-python",
    "href": "10_p-uplets/p_uplets.html#introduction-les-séquences-en-python",
    "title": "Cours",
    "section": "",
    "text": "Nous connaissons les types de données simples en Python. Ce sont les type int (nombres entiers), float (nombres flottants), bool (booléens). Le type str est aussi utilisé. Il est un peu moins simple. Un objet de type str est une chaîne de caractères qui s’écrit entre des guillemets ou des apostrophes. Un caractère est, pour simplifier, ce que l’on obtient par exemple avec les touches d’un clavier. Dans une chaîne, chaque caractère est repéré par un indice qui commence à 0. Avec la chaîne ch =\"exemple\", ch[0] est le caractère “e”, ch[1] est le caractère “x”, et ainsi de suite.\nCes types simples ne sont plus suffisants si nous avons besoin de garder en mémoire un grand nombre de valeurs comme dans le cas d’un traitement de données statistiques. Il en est de même si l’on souhaite regrouper des valeurs, par exemple afin d’avoir une variable représentant les coordonnées d’un point.\nL’objectif est donc de construire un type de variable capable de contenir plusieurs valeurs. Nous pouvons nous inspirer du type str et utiliser des indices pour repérer les éléments. Ceci amène à la construction des p-uplets, type tuple, et des tableaux, type list. Comme pour le type str, un objet t de type tuple n’est pas modifiable par une affectation t[i]=valeur. Un objet de type list est lui modifiable par une affectation ce qui autorise de nombreuses méthodes applicables à ces objets mais en contrepartie une grande vigilance sur leur utilisation. Un troisième type est présenté, le type dict pour les dictionnaires. La principale différence avec les listes est qu’un dictionnaire n’est pas ordonné. Un élément n’est pas repéré par un indice entier mais par une “clé”.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Cours"
    ]
  },
  {
    "objectID": "10_p-uplets/p_uplets.html#les-p-uplets-en-python",
    "href": "10_p-uplets/p_uplets.html#les-p-uplets-en-python",
    "title": "Cours",
    "section": "2. Les p-uplets en Python",
    "text": "2. Les p-uplets en Python\n\n\n\n\n\n\nDéfinition\n\n\n\nUn objet de type tuple, un p-uplet, est une suite ordonnée d’éléments qui peuvent être chacun de n’importe quel type. On parlera indifféremment de p-uplet ou de tuple.\n\n\n\n2.1 Création d’un p-uplet\nPour créer un p-uplet non vide, on écrit n valeurs séparées par des virgules et placées entre des parenthèses. Par exemple :\n\nt = (\"a\", \"b\", \"c\", 3) pour un tuple à 4 éléments ;\nt = (\"a\", )pour un tuple à 1 éléments (attention à la virgule) ;\nt = () pour un tuple à 0 éléments (ici, pas de virgule, mais des parenthèses).\n\nOn peut aussi, quand il n’y a pas d’ambiguïté, ne pas écrire les parenthèses : t = 1, 2, 3, 4. Mais les parenthèses peuvent améliorer la lisibilité et on les utilisera de préférence.\nOn dit aussi qu’on empaquette les valeurs 1, 2, 3 et 4 dans le quadruplet t.\n\n\n2.2. Opérations\nNous avons deux opérateurs de concaténation qui s’utilisent comme avec les chaînes de caractères, ce sont les opérateurs + et *.\nDe nouveaux p-uplets sont créés.\n&gt;&gt;&gt; t1 = (\"a\", \"b\")\n&gt;&gt;&gt; t2 = (\"c\", \"d\")\n&gt;&gt;&gt; t1 + t2\n('a', 'b', 'c', 'd')\n&gt;&gt;&gt; 3 * t1\n('a', 'b', 'a', 'b', 'a', 'b')\n\n\n2.3. Appartenance\nPour tester l’appartenance d’un élément à un tuple, on utilise l’opérateur in :\n&gt;&gt;&gt; t = (\"a\", \"b\", \"c\")\n&gt;&gt;&gt; \"a\" in t\nTrue\n&gt;&gt;&gt; \"d\" in t\nFalse\n\n\n2.4. Utilisation des indices\nLes indices permettent d’accéder aux différents éléments d’un tuple. Pour accéder à un élément d’indice i d’un tuple t, la syntaxe est t[i]. L’indice i peut prendre les valeurs entières de 0 à \\(n − 1\\) où \\(n\\) est la longueur du tuple. Cette longueur s’obtient avec la fonction len. Exemple :\n&gt;&gt;&gt; t = (\"a\", 1, \"b\", 2, \"c\", 3)\n&gt;&gt;&gt; len(t)\n6\n&gt;&gt;&gt; t[2]\n'b'\nLes indices commencent toujours à 0 et par exemple le troisième élément a pour indice 2. Le dernier élément d’un tuple t a pour indice len(t)-1. On accède ainsi au dernier élément avec t[len(t)-1] qui peut s’abréger en t[-1]. Les indices négatifs permettent donc d’accéder aux éléments du tuple “en partant de la fin”.\n&gt;&gt;&gt; t = (\"a\", 1, \"b\", 2, \"c\", 3)\n&gt;&gt;&gt; t[-1]\n3\n&gt;&gt;&gt; t[-2]\n'c'\nExemple avec des tuples emboîtés (un tuple contenant des tuples) :\n&gt;&gt;&gt; t = ((\"a\", \"b\"), (\"c\", \"d\"))\n&gt;&gt;&gt; t[1][0]\n'c'\nExplication : t[1] est le tuple (\"c\", \"d\") et 'c' est l’élément d’indice 0 de ce tuple.\nRappelons ce qui a été annoncé plus haut : les éléments d’un tuple ne sont pas modifiables par une affectation de la forme t[i]=valeur qui provoque une erreur et arrête le programme.\n\n\n2.5. Affectation multiple\nPrenons pour exemple l’affectation a, b, c = 1, 2, 3. Ceci signifie que le tuple (a, b, c) prend pour valeur le tuple (1, 2, 3), autrement dit, les valeurs respectives des variables a, b et c sont 1, 2 et 3.\nEn particulier, l’instruction a, b = b, a permet d’échanger les valeurs des deux variables a et b.\nLes valeurs des éléments d’un tuple peuvent ainsi être stockées dans des variables.\n&gt;&gt;&gt; t = (1, 2, 3)\n&gt;&gt;&gt; a, b, c = t\n&gt;&gt;&gt; b\n2\nCette syntaxe s’utilise souvent avec une fonction qui renvoie un tuple.\nVoici un exemple avec une fonction qui calcule et renvoie les longueurs des trois côtés d’un triangle ABC. La fonction prend en paramètres trois p-uplets représentant les coordonnées des trois points. On importe au préalable la fonction racine carrée sqrt du module math.\nfrom math import sqrt\n\ndef longueurs(A, B, C):\n    xA, yA = A\n    xB, yB = B\n    xC, yC = C\n    dAB = sqrt((xB - xA) ** 2 + (yB - yA) ** 2)\n    dBC = sqrt((xC - xB) ** 2 + (yC - yB) ** 2)\n    dAC = sqrt((xC - xA) ** 2 + (yC - yA) ** 2)\n    return dAB, dBC, dAC\nDans cette fonction, les variables A, B et C sont des 2-uplets représentant les coordonnées des points A, B et C. Aux lignes 4, 5, 6, on dépaquette ces 2-uplets pour procéder à une affectation multiple.\nLa fonction étant définie, nous l’utilisons dans l’interpréteur :\n&gt;&gt;&gt; M = (3.4, 7.8)\n&gt;&gt;&gt; N = (5, 1.6)\n&gt;&gt;&gt; P = (-3.8, 4.3)\n&gt;&gt;&gt; dMN, dNP, dMP = longueurs(M, N, P)\n&gt;&gt;&gt; dMN\n6.403124237432848\n\n\n2.6. Parcours d’un tuple avec une boucle for\nUne boucle for permet de parcourir chacun des éléments d’un tuple, comme le montre la suite d’instruction suivante, entrée dans la console Python :\n&gt;&gt;&gt; t = (1,2,3,4)\n&gt;&gt;&gt; for k in t: \n        print(k)\n1\n2\n3\n4\n\n\n\n\n\n\nÀ retenir\n\n\n\n\nUn p-uplet, ou tuple, est une structure ordonnée qui permet de contenir plusieurs éléments qui sont tous accessibles.\nUn même p-uplet peut contenir des éléments de types différents. Un p-uplet peut contenir d’autres p-uplets.\nUn p-uplet est immuable, c’est-à-dire non modifiable : on ne peut pas procéder à une affectation de la forme t[i]=valeur\n\n\n\nRemarque : en français, un objet non modifiable élément par élément après sa création est dit immuable. En anglais, on dit immutable.\n\n\n\n\n\n\nRemarque : p-uplets nommés\n\n\n\nDans le programme, il est fait mention de p-uplets nommés. Ce type de variable est semblable aux p-uplets, avec toutes leurs propriétés, mais les éléments ne sont pas indexés par un entier 0, 1, 2 …, mais par un descripteur qui peut par exemple être une chaîne de caractères :\n&gt;&gt;&gt; monsieurX = {\"nom\": \"X\", \"́prenom\": \"Monsieur\", \"age\": 47}\n&gt;&gt;&gt; monsieurX[\"age\"]\n47\nLe type p-uplet nommé n’existe pas en Python (ou alors il faut utiliser une bibliothèque supplémentaire). Nous utiliserons à la place des dictionnaires (voir le cours sur les dictionnaires).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Cours"
    ]
  },
  {
    "objectID": "11_tableaux/index.html",
    "href": "11_tableaux/index.html",
    "title": "Programme",
    "section": "",
    "text": "À partir des types de base se constituent des types construits, qui sont introduits au fur et à mesure qu’ils sont nécessaires.\nIl s’agit de présenter tour à tour les p-uplets (tuples), les enregistrements qui collectent des valeurs de types différents dans des champs nommés et les tableaux qui permettent un accès calculé direct aux éléments. En pratique, on utilise les appellations de Python, qui peuvent être différentes de celles d’autres langages de programmation.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\np-uplets. p-uplets nommés\nÉcrire une fonction renvoyant un p-uplet de valeurs.\n\n\n\nTableau indexé, tableau donné en compréhension\nLire et modifier les éléments d’un tableau grâce à leurs index. Construire un tableau par compréhension. Utiliser des tableaux de tableaux pour représenter des matrices : notation a [i] [j]. Itérer sur les éléments d’un tableau.\nSeuls les tableaux dont les éléments sont du même type sont présentés. Aucune connaissance des tranches (slices) n’est exigible. L’aspect dynamique des tableaux de Python n’est pas évoqué. Python identifie listes et tableaux. Il n’est pas fait référence aux tableaux de la bibliothèque NumPy.\n\n\nDictionnaires par clés et valeurs\nConstruire une entrée de dictionnaire. Itérer sur les éléments d’un dictionnaire.\nIl est possible de présenter les données EXIF d’une image sous la forme d’un enregistrement. En Python, les p-uplets nommés sont implémentés par des dictionnaires. Utiliser les méthodes keys(), values () et items ()."
  },
  {
    "objectID": "11_tableaux/TP_Stegano.html",
    "href": "11_tableaux/TP_Stegano.html",
    "title": "Mini-projet Stéganographie",
    "section": "",
    "text": "Cette activité est fortement inspirée du dossier paru sur le site bibmath.\nLes images utilisées sont toutes issues du site Pixabay et libres de droits.\nLa stéganographie, du grec stegano (dissimuler), est une méthode de cryptographie qui consiste, plutôt que de crypter un message, à le cacher dans une image selon un procédé plus ou moins complexe.\nOn s’intéresse en particulier à la dissimulation d’une image dans une autre image.\nAvant de commencer, il est nécessaire de prendre en main le module Python PIL (Python Imaging Library) qui permet de manipuler des images.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Mini-projet Stéganographie"
    ]
  },
  {
    "objectID": "11_tableaux/TP_Stegano.html#1-le-module-pil",
    "href": "11_tableaux/TP_Stegano.html#1-le-module-pil",
    "title": "Mini-projet Stéganographie",
    "section": "1. Le module PIL",
    "text": "1. Le module PIL\n\nQu’est-ce que la librairie PIL ?\nPIL est l’acronyme pour Python Imaging Library. Il s’agit d’une librairie additionnelle qui fournit des fonctions de traitement d’images et de manipulations graphiques à Python. Elle supporte de nombreux formats d’images.\nLa “véritable” bibliothèque PIL, c’est-à-dire la bibliothèque d’origine, n’a jamais été portée pour Python 3. Nous utiliserons donc une version dérivée, nommée Pillow (les informaticiens ont beaucoup d’humour...) qui est, elle, compatible avec les dernières versions de Python 3. On pourra consulter le site de Pillow. La bibliothèque Pillow est déjà installée dans la distribution EduPython.\n\n\n\n\n\n\nAttention\n\n\n\n\nToutes les images utilisées dans ce mini-projet sont téléchargeables en cliquant ici : images.zip.\nPour faire ce travail, il est nécessaire d’avoir téléchargé les images et de les avoir placées dans le même dossier que votre programme.\nLe travail pourra être fait dans EduPython, ou dans la console Python accessible dans le menu ci-dessus. Dans ce cas, les images devront être chargées dans la console en utilisant le bouton représentant un dossier.\n\n\n\n\n\n\nCommandes utiles pour une utilisation de base\nAvant toute chose, on importera la bibliothèque en ajoutant la ligne suivante en début de programme :\n\nfrom PIL import Image\n\n\nExemple d’ouverture d’un fichier et accès à ses informations\n\n\n# ouverture du fichier image\nimg = Image.open(\"chat.png\")\n# nom du fichier\nprint(img.filename)\n# taille du fichier\nprint(img.size)\nprint(img.width)\nprint(img.height)\n\nchat.png\n(640, 427)\n640\n427\n\n\n\n# Affichage de l'image\nimg.show()\n\n\n\nUn fichier image peut avoir trois modes différents :\n\n“l” (lettre l minuscule) pour un fichier en noir et blanc (uniquement deux couleurs) ;\n“L” pour un fichier en niveaux de gris ;\n“RGB” pour une image en couleur.\n\nUne image est représentée par un tableau de pixels. Chaque pixel est repéré par ses coordonnées \\((x;y)\\) où \\(x\\) est la ligne où se trouve le pixel et \\(y\\) la colonne. Chaque pixel possède une valeur.\nDans le cas d’une image en noir et blanc, la valeur d’un pixel est 0 (blanc) ou 1 (noir).\nDans le cas d’une image en niveaux de gris, la valeur d’un pixel est un entier compris entre 0 (noir) et 255 (blanc).\nDans le cas d’une image en couleurs RGB, la valeur d’un pixel est un 3-uplet \\((R, G, B)\\) dans lequel chaque élément est un entier compris entre 0 et 255 qui représente respectivement la prorportion de rouge, de vert et de bleu dans la couleur du pixel en question.\nAccéder à la valeur d’un pixel : img.getpixel((x, y)). Cette fonction retourne un entier (dans le cas d’une image noir et blanc ou en niveaux de gris) ou un triplet (dans le cas d’une image en couleurs). Attention à la syntaxe : il n’y a qu’un seul argument, qui est un couple de coordonnées (donc doubles parenthèses).\n\n\nprint(img.mode)\nimg.getpixel((48,75)) # attention aux parenthèses !\n\nL\n\n\n12\n\n\n\nCommandes pour créer un fichier image et définir la valeur de ses pixels :\n\n\nlargeur = 200\nhauteur = 100\n# Création d'une nouvelle image en niveaux de gris en mémoire\nnouvelle_image = Image.new(\"L\", (largeur, hauteur))\n# Définition de la valeur d'un pixel particulier\nnouvelle_image.putpixel((48,75), 189)\n\n# Double boucle pour parcourir tous les pixels et affecter une valeur aléatoire\nfrom random import randint\n\nfor i in range(largeur):\n    for j in range(hauteur):\n        nouvelle_image.putpixel((i,j), randint(0,255))\n\n# Enregistrement du fichier\nnouvelle_image.save(\"mon_image.png\")\n\n# Affichage dans le notebook\nnouvelle_image.show()",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Mini-projet Stéganographie"
    ]
  },
  {
    "objectID": "11_tableaux/TP_Stegano.html#2-stéganographie-dans-une-image-en-niveaux-de-gris",
    "href": "11_tableaux/TP_Stegano.html#2-stéganographie-dans-une-image-en-niveaux-de-gris",
    "title": "Mini-projet Stéganographie",
    "section": "2. Stéganographie dans une image en niveaux de gris",
    "text": "2. Stéganographie dans une image en niveaux de gris",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Mini-projet Stéganographie"
    ]
  },
  {
    "objectID": "11_tableaux/TP_Stegano.html#le-principe",
    "href": "11_tableaux/TP_Stegano.html#le-principe",
    "title": "Mini-projet Stéganographie",
    "section": "Le principe",
    "text": "Le principe\nConsidérons deux images en niveau de gris. Chaque pixel est donc codé par un entier compris en 0 et 255. Nous supposons de plus ces deux images de même taille.\nLa première image image1.pgm est la suivante (dimensions : 640x426) :\n\nLa seconde image image2.pgm est la suivante (dimensions : 640x426) :\n\nNous utilisons des images au format PGM qui est non compressé. L’utilisation d’un format compressé du type JPG ou PNG empêcherait notre méthode de fonctionner. Ce type d’image s’affiche dans le logiciel GIMP.\nL’objectif est de cacher l’image 2 dans l’image 1. Comment faire ?\nChaque pixel de chacune des deux images est codé par un entier compris entre 0 et 255. Écrit en base 2, cet entier s’écrit avec 8 chiffres (en ajoutant éventuellement des zéros inutiles au début du nombre). Prenons par exemple un pixel de la première image codé par le nombre binaire 1011 0101 : les quatre premiers chiffres ont plus de poids dans la valeur de ce nombre que les quatre derniers puisqu’ils sont associés à de plus grandes puissances de 2. Nous les appellerons bits de poids lourds. Les quatre derniers sont donc des bits de poids faible.\nSi on remplace ce nombre par un nombre dont on ne modifie que les quatre bits de poids faible (les quatre derniers), alors l’image sera assez peu modifiée. C’est cette remarque qui permet de cacher l’image 2 dans l’image 1. Il suffit de créer une nouvelle image dont chaque pixel est formé des bits de poids lourd de chacune des deux images de départ.\nPour chaque pixel des deux images :\n\n\n\nImage 1\nImage 2\nImage cryptée\n\n\n\n\n1011 0101\n0110 1100\n1011 0110\n\n\n\nComme on n’a modifié que les bits de poids faible de l’image 1, l’image cryptée ressemblera beaucoup à l’image 1, mais un programmeur averti saura en extraire l’image 2 ...\nVoici, à gauche, l’image 1 et, à droite, l’image cryptée (la pauvre vache est perdue dans la ville !).\n\n\n\nImage 1\nImage cryptée",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Mini-projet Stéganographie"
    ]
  },
  {
    "objectID": "11_tableaux/TP_Stegano.html#mini-projet",
    "href": "11_tableaux/TP_Stegano.html#mini-projet",
    "title": "Mini-projet Stéganographie",
    "section": "Mini-projet",
    "text": "Mini-projet\nTa mission, si tu l’acceptes, consiste en deux choses :\n\nProgrammer un algorithme permettant de créer l’image cryptée à partir des deux images de départ. Il s’agit de définir une fonction qui prend en arguments deux images de mêmes dimensions et qui retourne l’image cryptée.\nProgrammer un algorithme permettant de retrouver l’image cachée dans une image cryptée. Il s’agit de définir une fonction qui prend en argument une image cryptée et qui retourne l’image cachée.\n\nEn cas de besoin, quelques indications :\n\nLa fonction bin() permet de convertir un entier en sa représentation binaire sous forme de chaîne de caractères. Cependant, le résultat ne contient pas les zéros inutiles en début de chaîne !!! Par exemple bin(45) retourne '0b101101'.\nPour accéder aux éléments d’une chaîne de caractères, on utilise les crochets comme pour les tableaux. Un indice négatif indique que l’on part de la fin de la chaîne. Par exemple, si mot = \"indication\", mot[2:-2] retourne \"dicati\".\n\nUne première étape dans la réalisation de ce projet consiste donc en l’écriture d’une fonction permettant d’obtenir la représentation binaire d’un entier compris entre 0 et 255 sous la forme d’une chaîne de caractères de longueur exactement 8. Tu peux compléter la fonction ci-dessous.\ndef bin_8_car(x):\n    \"\"\"x est un entier compris entre 0 et 255\n    la fonction renvoie une chaîne de 8 caractères\n    représentant x en binaire\"\"\"\n    nb = bin(x)\n    nb = nb[2:] # on enlève '0b'\n    # on ajoute des zéros pour arriver à 8 caractères\n    while ... :\n        nb = ... + nb\n    return nb\nExécute les tests ci-dessous pour vérifier la fonction.\n# tests de la fonction bin_8_car\nassert bin_8_car(54) == \"00110110\"\nassert bin_8_car(255) == \"11111111\"\nprint(\"Tests réussis !\")\nComplète ci-dessous la fonction crypte réalisant la première tâche demandée :\ndef crypte(img1, img2):\n    \"\"\"Cette fonction cache l'image 2 dans l'image 1\"\"\"\n    largeur, hauteur = img1.size\n    imgCrypt = Image.new(\"L\", (largeur, hauteur))\n    for i in range(...):\n        for j in range(...):\n            pixel_img1 = img1.getpixel((i,j))\n            pixel_img2 = img2.getpixel((i,j))\n            ...\n            ...\n            ...\n            imgCrypt.putpixel((i,j), ...)\n    return imgCrypt\n# test de la fonction crypte : il est normal que cela prenne quelques secondes\n# ici, on cache l'image de la vache dans l'image de la ville\nimg1 = Image.open('image1.pgm')\nimg2= Image.open('image2.pgm')\nimage_cryptee = crypte(img1, img2)\nimage_cryptee.save(\"vache_perdue.pgm\")\nimage_cryptee\nComplète ci-dessous la fonction decrypte réalisant la seconde tâche demandée :\ndef decrypte(imgCrypt):\n    \"\"\"Cette fonction retourne l'image cachée dans imgCrypt\"\"\"\n    largeur, hauteur = imgCrypt.size\n    img = Image.new(\"L\", (largeur, hauteur))\n    ...\n    return img\nPour tester cette fonction, voici une image en niveaux de gris qui contient un message secret. Le fichier est nommé image_crypte.pgm.\n\n# test de la fonction decrypte\n# ou ouvre une image qui contient une image cryptée\nimageCryptee = Image.open(\"image_crypte.pgm\")\n# on décrypte\nimage = decrypte(imageCryptee)\n# on affiche l'image qui était cachée\nimage\nMaintenant, tu peux t’amuser à créer d’autres images cryptées et à les décrypter pour tester tes fonctions sur plusieurs exemples.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Mini-projet Stéganographie"
    ]
  },
  {
    "objectID": "11_tableaux/TP_Stegano.html#défi-",
    "href": "11_tableaux/TP_Stegano.html#défi-",
    "title": "Mini-projet Stéganographie",
    "section": "Défi !!!",
    "text": "Défi !!!\nDans une image en couleur au format RGB, chaque pixel est codé par trois entiers compris entre 0 et 255.\nOn peut donc y cacher trois images en niveaux de gris différentes : une dans chaque composante de couleur.\nEn suivant cette idée, j’ai caché trois messages dans l’image ci-dessous, nommée defi_steg.ppm. Sauras-tu retrouver les trois messages cachés ?\n\n### à compléter ...\ndef decrypte_image_couleurs(img):\n    pass",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Mini-projet Stéganographie"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html",
    "href": "12_dictionnaires/exos_dicos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html#exercice-1",
    "href": "12_dictionnaires/exos_dicos.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\n\nLe dictionnaire suivant donne des informations sur l’adresse d’une personne.\nadresse = {(\"numero\", 13), (\"rue\", \"rue des Lilas\"), (\"codepostal\", 78340), (\"ville\", \"Pétaouchnoc\"){\nCette instruction ne respecte pas la syntaxe du langage Python, la corriger.\nLe dictionnaire suivant donne des informations sur l’identité d’une personne.\nidentite = {\"nom\":\"Durand\", \"prenom\":\"Christophe\", \"prenom\":\"Jean\", 52:\"age\"}\nExpliquer ce qui n’est pas correct dans cette déclaration et corriger.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html#exercice-2",
    "href": "12_dictionnaires/exos_dicos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nUn film peut être défini par un certain nombre de caractéristiques : son titre, son réalisateur, sa durée, son année de sortie. On définit pour cela le dictionnaire suivant :\nfilm = {\"titre\":\"Star Wars\", \"auteur\":\"G.Lucas\", \"duree\":121, \"annee\":1977}\n\nCorriger l’instruction suivante : print(\"Mon film préféré\", film[0], \"est sorti en\", film(\"annee\"), \"!\")\nQu’est-ce qui est affiché par les instructions suivantes :\nprint(film[\"auteur\"],\"est mon dieu vivant.\")\nprint(film[\"titre\"],\"c'est\",film[\"durée\"],\"minutes d'extase !\")\nQu’est-ce qui est affiché par les instructions suivantes ?\nprint(\"Qui est l'\",film[\"G.Lucas\"],\"de ce film ?\")\nprint(film[\"acteur\"],\"est trop beau dans de ce film !\")",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html#exercice-3",
    "href": "12_dictionnaires/exos_dicos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\nLe dictionnaire suivant donne les articles choisis par un visiteur sur un site internet, et la quantité de chaque article.\npanier = {\"stylo\": 10, \"crayon\": 15, \"gomme\": 3, \"tube de colle\": 2, \"cahier\": 5}\npanier[\"gomme\"] = panier[\"gomme\"] + 2\npanier[\"crayon\"] = 12\ndel panier[\"tube de colle\"]\npanier[\"scoth\"] = 1\nQuels sont les éléments du dictionnaire après l’exécution de ces instructions ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html#exercice-4",
    "href": "12_dictionnaires/exos_dicos.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\nÀ l’issue d’une élection à scrutin uninominal, on récupère un tableau contenant tous les noms inscrits sur les bulletins trouvés dans l’urne :\nurne = [\"Maurice\",\"Roger\",\"Maurice\",\"Marie\",\"Marie\",\"Jeanne\",\"Roger\",\n             \"Roger\",\"Maurice\",\"Roger\",\"Maurice\",\"Marie\",\"Marie\",\"Roger\",\"Marie\"]\nNous voulons créer un dictionnaire qui à chaque nom associera son nombre de voix : scorescandidats = {}.\nPar exemple, Maurice a obtenu 4 voix, un des couples du dictionnaire sera : \"Maurice\": 4\nL’avantage d’un dictionnaire est qu’il n’y a pas besoin de savoir à l’avance qui sont les candidats, ni même combien il y en a.\nCopier ce tableau dans un fichier python. Créer un dictionnaire vide, et parcourir le tableau.\nPour chaque élément du tableau :\n\nsoit le nom n’est pas encore dans le dictionnaire, et dans ce cas on l’ajoute au dictionnaire en lui donnant 1 première voix ;\nsoit le nom est déjà dans le dictionnaire, et dans ce cas on augmente son nombre de voix de 1.\n\nÉcrire et tester un programme réalisant ces opérations.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html#exercice-5",
    "href": "12_dictionnaires/exos_dicos.html#exercice-5",
    "title": "Exercices",
    "section": " Exercice 5",
    "text": "Exercice 5\nLe dictionnaire suivant donne les noms et les nationalités des visiteurs d’un site.\nvisiteurs = {\"STARK\": \"usa\", \"TOR\": \"rus\", \"MACRON\": \"fr\", \"JOHNSON\": \"en\",\n             \"DUBOIS\": \"fr\", \"MACARTHUR\": \"usa\", \"HOLMES\": \"en\",\n             \"BERNARD\": \"fr\", \"DURAND\": \"fr\", \"HOLLANDE\": \"fr\",\n             \"OBAMA\": \"usa\", \"POPOV\": \"rus\"}\nÉcrire une fonction qui renvoie le nombre de clients français.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html#exercice-6",
    "href": "12_dictionnaires/exos_dicos.html#exercice-6",
    "title": "Exercices",
    "section": " Exercice 6",
    "text": "Exercice 6\nLe dictionnaire suivant donne la liste des couples identifiant/mots de passe des adhérents d’un site.\nidentifiants = {\"joe.durand\": \"Joe-la-terreur\",\n                \"dupond15\": \"Dd152017\",\n                \"bfournier\": \"#14;P@gh\",\n                \"bonnetjohn\": \"Kamikaze2038\",\n                \"d.dubois\": \"15022001\",\n                \"martin\": \"youhou\",\n                \"Bernard.71\": \"bebertpower2001\"}\nPar exemple, le premier adhérent a pour identifiant “joe.durand” et son mot de passe est “Joe-la-terreur”.\nÉcrire un programme qui demande à l’utilisateur de saisir son identifiant et son mot de passe. On vérifie ensuite si ce couple identifiant/mot de passe est présent dans le dictionnaire. Si c’est le cas, on affiche le message “Identification réussie, bienvenue sur notre site”, et sinon le message “Nous ne vous connaissons pas”.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html#exercice-7",
    "href": "12_dictionnaires/exos_dicos.html#exercice-7",
    "title": "Exercices",
    "section": " Exercice 7",
    "text": "Exercice 7\nOn donne ci-dessous un dictionnaire de conversion du binaire en hexadécimal, dont les couples sont composés d’un nombre binaire et de sa conversion en hexadécimal :\nConvbinaire = {\"0000\": \"0\", \"0001\": \"1\", \"0010\": \"2\", \"0011\": \"3\", \"0100\": \"4\", \"0101\": \"5\",\n               \"0110\": \"6\", \"0111\": \"7\", \"1000\": \"8\", \"1001\": \"9\", \"1010\": \"A\", \"1011\": \"B\",\n               \"1100\": \"C\", \"1101\": \"D\", \"1110\": \"E\", \"1111\": \"F\"}\nÉcrire une fonction qui crée le dictionnaire inversé Convhexa dont les couples sont composés d’un nombre hexadécimal et de sa conversion en binaire.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html#exercice-8",
    "href": "12_dictionnaires/exos_dicos.html#exercice-8",
    "title": "Exercices",
    "section": " Exercice 8",
    "text": "Exercice 8\nVoici un tableau qui répertorie des informations sur les adhérents d’un site internet, certaines informations n’étant pas complètes :\n\n\n\nNom\nSexe\nAvatar\nAge\nAnnée d’adhésion\nMot de passe\n\n\n\n\n\nF\nBebert\n19\n2019\nBibi2019*\n\n\n\n\nBonbon\n\n2017\n45trd ;*%GR\n\n\nDUBET\nM\nBud\n17\n2018\nBud17\n\n\nDURAND\nM\n\n\n2018\nOuahOuah\n\n\nFOURNIER\nF\n\n\n2016\n12051995\n\n\n\n\nTinmar\n\n2017\nTitidu15\n\n\n\nOn peut le représenter par un tableau de dictionnaires partageant les mêmes clés (un dictionnaire pour chaque adhérent) :\nListeAdherents = [\n    {\"sexe\": \"F\", \"avat\": \"Bebert\", \"age\": 19, \"an\": 2019, \"pw\": \"Bibi2019*\"},\n    {\"avat\": \"Bonbon\", \"an\": 2017, \"password\": \"45trd ;*%GR\"},\n    {\"nom\": \"DUBET\", \"sexe\": \"M\", \"avat\": \"Bud\", \"age\": 17, \"an\": 2018, \"pw\": \"Bud17\"},\n    {\"nom\": \"DURAND\", \"sexe\": \"M\", \"an\": 2018, \"pw\": \"OuahOuah\"},\n    {\"nom\": \"FOURNIER\", \"sexe\": \"F\", \"an\": 2016, \"pw\": \"12051995\"},\n    {\"avat\": \"Tinmar\", \"an\": 2017, \"password\": \"Titidu15\"}]\n\nSans utiliser l’ordinateur, prévoir ce qui est affiché par les instructions suivantes :\n\nprint(ListeAdherents[1])\nprint(ListeAdherents[\"avat\"][2])\nprint(ListeAdherents[2][\"age\"])\nprint(ListeAdherents[\"pw\"])\nprint(ListeAdherents[4][\"avat\"])\n\nÉcrire une fonction qui renvoie la liste des avatars de tous les adhérents qui en ont un (utiliser une boucle for).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/exos_dicos.html#exercice-9-qcm",
    "href": "12_dictionnaires/exos_dicos.html#exercice-9-qcm",
    "title": "Exercices",
    "section": " Exercice 9 : QCM",
    "text": "Exercice 9 : QCM\n\nOn définit :\nT = [{'fruit': 'banane', 'nombre': 25}, {'fruit': 'orange', 'nombre': 124},\n    {'fruit': 'pomme', 'nombre': 75}, {'fruit': 'kiwi', 'nombre': 51}] \nQuelle expression a pour valeur le nombre de pommes ?\n\nT[2]['nombre']\nT[2,'nombre']\nT[3]['nombre']\nT[3,'nombre']\n\nOn exécute le script suivant :\ninventaire = {'pommes': 430, 'bananes': 312,\n            'oranges': 274, 'poires': 137}\n\nstock = 0\nfor fruit in inventaire.keys():\n    if fruit != 'bananes':\n        stock = stock + inventaire[fruit]\nQue contient la variable stock à la fin de cette exécution ?\n\n{430, 274, 137}\n312\n841\n{ 'pommes', 'oranges', 'poires' }\n\nOn dispose du dictionnaire regions ci-dessous :\nregions = {'Mayotte': 376, 'Pays de la Loire': 32082,\n        'La Réunion': 2504, 'Grand Est': 57441,\n        'Martinique': 1128, 'Corse': 8680,\n        'Bretagne': 27208, 'Nouvelle-Aquitaine': 84036}\nParmi les instructions suivantes, laquelle permet d’ajouter une nouvelle région ?\n\nINSERT \"'Hauts de France':31806\" INTO regions\nregions = dict(['Hauts de France'] = 31806)\nregions('Hauts de France') = 31806\nregions['Hauts de France'] = 31806\n\nOn définit :\ncontacts = {'Toto': 'toto@nsi.fr', 'Chloé': 'chloe@nsi.com',\n            'Paul': 'paul@nsi.net', 'Clémence': 'clemence@nsi.org'}\nParmi les propositions suivantes, laquelle est exacte ?\n\n‘Chloé’ est une valeur de la variable contacts\n‘Chloé’ est une clé de la variable contacts\n‘Chloé’ est un attribut de la variable contacts\n‘Chloé’ est un champ de la variable contacts\n\nOn considère le code suivant :\nD = {'a': '1', '2': 'a', 'b': 'a', 'c': '3'}\nQue vaut D['a'] à la fin de son exécution ?\n\n'1'\n2\n['2', 'b']\n['1', '3']",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices"
    ]
  },
  {
    "objectID": "12_dictionnaires/quiz.html",
    "href": "12_dictionnaires/quiz.html",
    "title": "Quiz",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.\nCe documents regroupe des petites questions rapides pour s’assurer que tout est bien compris",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz"
    ]
  },
  {
    "objectID": "12_dictionnaires/quiz.html#exercice-1",
    "href": "12_dictionnaires/quiz.html#exercice-1",
    "title": "Quiz",
    "section": " Exercice 1",
    "text": "Exercice 1\nCet exercice est une suite de petites “questions flash”. Vous pouvez vérifier vos réponses dans la console Python.\n\nComplétez le programme suivant afin que la variable a ait pour valeur 8 :\n\nmon_tuple = (5, 8, 6, 9)\na = mon_tuple[...]\n\nComplétez le programme ci-dessous pour qu’après exécution de ce dernier, le tableau mon_tab soit composé des éléments suivants : [15, 8, 6,  9]\n\nmon_tab = [5, 8, 6, 9]\nmon_tab[...] = 15\n\nSoit le tableau suivant :\n\ntab = [3,3,6,9]\nQuelle sera la composition de ce tableau si on exécute la ligne suivante :\ntab.append(0)\n\nDonnez la composition du tableau mon_tab après l’exécution du programme ci-dessous :\n\nmon_tab = [1, 2, 3, 4]\ndel mon_tab[1]\n\nQuelle est la valeur de la variable a après l’exécution du programme ci-dessus ?\n\nmon_tab = [5, 8, 6, 9, 15,  0]\na = len(mon_tab)\n\nQuelle est la valeur de la variable s après l’exécution du programme ci-dessus. Vérifiez votre réponse à l’aide de la console.\n\ntab = [1, 2, 3]\ns = 0\nfor t in tab:\n    s = s + t\n\nSoit le programme suivant :\n\nm = [[1, 3, 4],\n     [5, 6, 8],\n     [2, 1, 3],\n     [7, 8, 15]]\na  = m[0][1]\nQuelle est la valeur de la variable a après l’exécution de ce programme ? Vérifiez votre réponse à l’aide de la console.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz"
    ]
  },
  {
    "objectID": "12_dictionnaires/quiz.html#exercice-2",
    "href": "12_dictionnaires/quiz.html#exercice-2",
    "title": "Quiz",
    "section": " Exercice 2",
    "text": "Exercice 2\ntab = [5, 3, 4, 8]\nmon_tab = [2*t for t in tab if t &gt; 4]\nQuelle est la composition du tableau mon_tab après l’exécution du programme ci-dessus. Vérifiez votre réponse à l’aide de la console.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz"
    ]
  },
  {
    "objectID": "12_dictionnaires/quiz.html#exercice-3",
    "href": "12_dictionnaires/quiz.html#exercice-3",
    "title": "Quiz",
    "section": " Exercice 3",
    "text": "Exercice 3\nm = [[1, 3],\n     [5, 8],\n     [2, 3]]\nnb_colonne = 2\nnb_ligne = 3\na = 0\nfor i in range(0, nb_ligne):\n    for j in range(0, nb_colonne):\n        a = a + m[i][j]\nQuelle est la valeur de la variable a après l’exécution de ce programme ? Vérifiez votre réponse à l’aide de la console.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz"
    ]
  },
  {
    "objectID": "12_dictionnaires/quiz.html#exercice-4",
    "href": "12_dictionnaires/quiz.html#exercice-4",
    "title": "Quiz",
    "section": " Exercice 4",
    "text": "Exercice 4\nCompléter la fonction ci-dessous pour qu’elle réponde à sa spécification. Tester votre code.\nPar exemple, recherche_max([4, 3, 0, 5]) renvoie 5.\ndef recherche_max(tab: list) -&gt; int:\n    \"\"\"Retourne la plus grande valeur contenue dans le tableau\n    tab: tableau d'entiers naturels\"\"\"\n    maxi = ...\n    for t in tab :\n        if ... &gt; maxi :\n            maxi = ...\n    return ...",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz"
    ]
  },
  {
    "objectID": "12_dictionnaires/quiz.html#exercice-5",
    "href": "12_dictionnaires/quiz.html#exercice-5",
    "title": "Quiz",
    "section": " Exercice 5",
    "text": "Exercice 5\nCompléter la fonction ci-dessous pour qu’elle réponde à sa spécification. Tester votre code.\ndef somme(tab: list) -&gt; int:\n    \"\"\"Retourne la somme des éléments du tableau\n    tab: tableau d'entiers\"\"\"\n    s = ...\n    for t in ... :\n        s = s + ...\n    return ...\n&gt;&gt;&gt; somme([3,5,8,4])\n20",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz"
    ]
  },
  {
    "objectID": "12_dictionnaires/quiz.html#exercice-6",
    "href": "12_dictionnaires/quiz.html#exercice-6",
    "title": "Quiz",
    "section": " Exercice 6",
    "text": "Exercice 6\nd = {\"voiture\": 25, \"vélo\": 55, \"train\": 20}\ntr = d['vélo']\nQuelle est la valeur de la variable traprès l’exécution du programme ci-dessus. Vérifiez votre réponse à l’aide de la console.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz"
    ]
  },
  {
    "objectID": "12_dictionnaires/quiz.html#exercice-7",
    "href": "12_dictionnaires/quiz.html#exercice-7",
    "title": "Quiz",
    "section": " Exercice 7",
    "text": "Exercice 7\n\nQuelle est la valeur de la variable tab après l’exécution de ce programme ?\ntab = []\nd = {\"voiture\": 25, \"vélo\": 55, \"train\": 20}\nfor t in d.values():\n    if t &lt; 40 :\n        tab.append(t)\nQuelle est la valeur de la variable tab après l’exécution de ce programme ?\ntab = []\nd = {\"voiture\": 25, \"vélo\": 55, \"train\": 20}\nfor v,t in d.items():\n    if t &lt; 40 :\n        tab.append(v)",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz"
    ]
  },
  {
    "objectID": "12_dictionnaires/quiz.html#exercice-8",
    "href": "12_dictionnaires/quiz.html#exercice-8",
    "title": "Quiz",
    "section": " Exercice 8",
    "text": "Exercice 8\nOn utilise un tableau contenant des dictionnaires afin de stocker les notes des élèves Titi, Toto et Tutu :\n[{'nom':'Titi', 'note':12}, {'nom':'Tutu', 'note':11}, {'nom':'Toto', 'note':17}]\nLa fonction moyenne prend en paramètre un tableau contenant des dictionnaires (comme celui ci-dessus) et renvoie la moyenne des notes.\nÉcrivez la fonction moyenne.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Quiz"
    ]
  },
  {
    "objectID": "13_vonNeumann/exos_circuits.html",
    "href": "13_vonNeumann/exos_circuits.html",
    "title": "T.P. : circuits logiques",
    "section": "",
    "text": "Les exercices de cette page sont à réaliser dans Capytale : un lien par exercice vous permettra de les ouvrir directement dans le simulateur. Les fenêtres interactives présentes dans cette page permettent de s’entraîner ou de revenir faire les exercices plus tard, mais les montages ne sont pas sauvegardés.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "T.P. : circuits logiques"
    ]
  },
  {
    "objectID": "13_vonNeumann/exos_circuits.html#exercice-1",
    "href": "13_vonNeumann/exos_circuits.html#exercice-1",
    "title": "T.P. : circuits logiques",
    "section": " Exercice 1",
    "text": "Exercice 1\nhttps://capytale2.ac-paris.fr/web/c/f050-5535104\nRéaliser un circuit logique à 4 entrées, à l’aide des portes disponibles à gauche, telle que Sortie vaut 1 si, et seulement si, au moins une des entrées est non nulle.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "T.P. : circuits logiques"
    ]
  },
  {
    "objectID": "13_vonNeumann/exos_circuits.html#exercice-2",
    "href": "13_vonNeumann/exos_circuits.html#exercice-2",
    "title": "T.P. : circuits logiques",
    "section": " Exercice 2",
    "text": "Exercice 2\nhttps://capytale2.ac-paris.fr/web/c/16dc-5535233\nDessiner un circuit logique qui a 4 entrées A, B, C et D et dont la sortie O vaut 1 si, et seulement si, toutes les entrées sont nulles.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "T.P. : circuits logiques"
    ]
  },
  {
    "objectID": "13_vonNeumann/exos_circuits.html#exercice-3",
    "href": "13_vonNeumann/exos_circuits.html#exercice-3",
    "title": "T.P. : circuits logiques",
    "section": " Exercice 3",
    "text": "Exercice 3\nhttps://capytale2.ac-paris.fr/web/c/2608-5535244\nDessiner un circuit logique correspondant à la table ci-dessous.\n\n\n\nA\nS\nO\n\n\n\n\n0\n0\n0\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n1\n1\n0\n\n\n\nL’objectif est de renvoyer la valeur de A si S = 0 et de renvoyer (non A) sinon.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "T.P. : circuits logiques"
    ]
  },
  {
    "objectID": "13_vonNeumann/exos_circuits.html#exercice-4",
    "href": "13_vonNeumann/exos_circuits.html#exercice-4",
    "title": "T.P. : circuits logiques",
    "section": " Exercice 4",
    "text": "Exercice 4\nhttps://capytale2.ac-paris.fr/web/c/27b6-5535245\nOn considère le circuit suivant :\n\n\nReproduire ce circuit dans le simulateur ci-dessous.\nEn vous aidant du simulateur, établir la table de vérité de ce circuit.\nQue fait ce circuit ?\n\nVotre réponse ci-dessous :\nVotre réponse ici ...",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "T.P. : circuits logiques"
    ]
  },
  {
    "objectID": "13_vonNeumann/exos_circuits.html#exercice-5",
    "href": "13_vonNeumann/exos_circuits.html#exercice-5",
    "title": "T.P. : circuits logiques",
    "section": " Exercice 5",
    "text": "Exercice 5\nhttps://capytale2.ac-paris.fr/web/c/cbdf-5535252\nOn peut faire une porte NON avec une porte NAND.\nEn rajoutant les fils manquants, utilisez la porte NAND (non-et) pour que la valeur de Sortie soit la même que celle de Témoin, quelle que soit la valeur de Entrée.\n\nPour rajouter un fil, il suffit de cliquer sur la sortie d’une porte et de faire glisser le fil jusqu’à l’entrée d’une autre porte.\nPour changer la valeur de Entrée, il suffit de cliquer dessus.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "T.P. : circuits logiques"
    ]
  },
  {
    "objectID": "13_vonNeumann/exos_circuits.html#exercice-6",
    "href": "13_vonNeumann/exos_circuits.html#exercice-6",
    "title": "T.P. : circuits logiques",
    "section": " Exercice 6",
    "text": "Exercice 6\nhttps://capytale2.ac-paris.fr/web/c/80e5-5535268\nEn rajoutant des portes NAND, disponibles à gauche, faites des circuits équivalents aux portes ET et OU déjà installées.\n\nEn cas d’erreur de manipulation, vous pouvez réinitialiser en utilisant le bouton à droite.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "T.P. : circuits logiques"
    ]
  },
  {
    "objectID": "13_vonNeumann/exos_circuits.html#exercice-7",
    "href": "13_vonNeumann/exos_circuits.html#exercice-7",
    "title": "T.P. : circuits logiques",
    "section": " Exercice 7",
    "text": "Exercice 7\nhttps://capytale2.ac-paris.fr/web/c/d34d-5535004\nFaire un circuit équivalent à une porte XOR à l’aide de portes ET, OU et NON.\n\nVous pouvez rajouter une porte XOR et une nouvelle sortie pour tester votre circuit.\noptionnel Il y a 2 façons de faire une porte XOR, donc vous pouvez chercher la deuxième construction.\noptionnel Pour les plus courageux, vous pouvez essayer de faire le même circuit avec uniquement des portes NAND.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "T.P. : circuits logiques"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_2.html",
    "href": "13_vonNeumann/neumann_cours_2.html",
    "title": "Cours : Partie 2",
    "section": "",
    "text": "Dans cette partie, nous allons décrire comment on peut, à partir de transistors, réaliser des opérations logiques.\n\n1. Du transistor au circuit logique\nOn entend souvent dire qu’“un ordinateur utilise uniquement des”1” et des “0”“. Cette affirmation mérite d’être précisée.\nÀ la base de la plupart des composants d’un ordinateur, on retrouve le transistor. Ce composant électronique a été inventé fin 1947 par les Américains John Bardeen, William Shockley et Walter Brattain. L’invention du transistor a été un immense progrès, mais les premiers ordinateurs sont antérieurs à cette invention. En effet, ces premiers ordinateurs, par exemple le Colossus qui date de 1943, étaient conçus à base de tubes électroniques (on parle aussi de tubes à vide) qui, bien que beaucoup plus gros et beaucoup moins fiable que les transistors fonctionnent sur le même principe que ce dernier.\nun transistor : \nun tube électronique : \nAutre aspect historique qu’il est important de préciser : on ne trouve plus, depuis quelque temps déjà, de transistors en tant que composant électronique discret (comme le transistor de la photo ci-dessus). Dans un ordinateur, les transistors sont regroupés au sein de ce que l’on appelle des circuits intégrés. Dans un circuit intégré, les transistors sont gravés sur des plaques de silicium, les connexions entre les millions de transistors qui composent un circuit intégré sont, elles aussi, gravées directement dans le silicium. Les processus mis en jeu lors de ces gravures dépassent largement le cadre de ce cours, si ce sujet vous intéresse, je vous invite à visionner cette vidéo : https://www.youtube.com/watch?v=NFr-WyytNfo\nun circuit intégré : \nIl n’est pas question de nous pencher en détail sur le fonctionnement d’un transistor, mais vous devez tout de même savoir que dans un ordinateur les transistors se comportent comme des interrupteurs : soit le transistor laisse passer le courant électrique (interrupteur fermé), soit il ne le laisse pas passer (interrupteur ouvert). Et c’est tout, il n’y a pas d’autre état possible pour un transistor dans un ordinateur : le courant passe ou le courant ne passe pas. Globalement l’ordinateur fonctionne uniquement avec deux états. On parle d’un état “haut” et d’un état “bas”. On symbolise souvent l’état “haut” par le chiffre “1” et l’état “bas” par le chiffre “0”, mais il faut bien avoir conscience qu’il n’y a pas dans un ordinateur des “petits 1” ou des “petits 0” qui se “baladent”, c’est juste une histoire de “courant qui passe” ou de “courant qui ne passe pas”. On travaille donc uniquement avec 2 chiffres, voilà pourquoi un ordinateur travaille en base 2 (en binaire) et non pas en base 10 comme dans la vie courante.\nPlus précisément, un transistor se comporte comme un interrupteur commandé électriquement, sans partie mécanique. Il dispose de trois bornes : le drain, la grille et la source. Soumise à une tension suffisante (état 1), la grille permet le passage du courant entre le drain et la source (interrupteur fermé). Dans le cas contraire (état 0), le courant est bloqué (interrupteur ouvert).\n\nVoyons maintenant comment un circuit composé de plusieurs transistors peut effectuer des opérations logiques.\nOn considère le circuit ci-dessous. Il comporte quatre transistors et les deux transistors du haut sont inversés (ils laissent passer le courant quand l’entrée est à 0 et le bloquent quand l’entrée est à 1). Vdd est la tension d’alimentation (1,5 V) et Gnd la terre (0 V).\nEn réfléchissant un peu, nous pouvons justifier la table de vérité de ce circuit, donnée à côté.\n\nIl s’agit de l’opérateur logique NAND, NON ET.\nOn peut de la même façon créer des circuits réalisant toutes les opérations logiques.\nPour en savoir plus sur les transistors voir cet article.\n\n\n2. Les circuits logiques\nLe transistor est donc l’élément de base des circuits logiques. Un circuit logique permet de réaliser une opération booléenne. Il prend en entrée un ou des signaux électriques (chaque entrée est dans un état “haut” (symbolisé par un “1”) ou à un état “bas” (symbolisé par un “0”) et donne en sortie un ou des signaux électriques (chaque sortie est aussi dans un état “haut” ou à un état “bas”). Il existe deux catégories de circuits logiques :\n\nles circuits combinatoires (les états en sortie dépendent uniquement des états en entrée)\nles circuits séquentiels (les états en sortie dépendent des états en entrée ainsi que du temps et des états antérieurs)\n\nDans la suite nous nous intéresserons principalement aux circuits combinatoires.\n\nla porte NON (NOT)\nLe plus simple des circuits combinatoires est la porte “NON” (“NOT” en anglais) qui inverse l’état en entrée : si l’entrée de la porte est dans un état “bas” alors la sortie sera dans un état “haut” et vice versa. Si on symbolise l’état “haut” par un “1” et l’état “bas” pour un “0”, on retrouve la table de vérité de l’opérateur booléen “NON” :\n\n\n\nE (Entrée)\nS (Sortie)\n\n\n\n\n1\n0\n\n\n0\n1\n\n\n\nLa porte “NON” est symbolisée par le schéma suivant (les schémas ci-dessous utilisent les symboles étasuniens, les plus utilisés) :\n\n\n\nla porte OU (OR)\nLa porte “OU” a deux entrées (E1 et E2) et une sortie S\n\nTable de vérité porte “OU” :\n\n\n\nE1\nE2\nS\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n1\n\n\n\n\n\nla porte ET (AND)\nLa porte “ET” (“AND”) a deux entrées (E1 et E2) et une sortie S\n\nTable de vérité porte “ET” :\n\n\n\nE1\nE2\nS\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\nla porte OU EXCLUSIF (XOR)\nLa porte “OU EXCLUSIF” (“XOR”) a deux entrées (E1 et E2) et une sortie S\n\nTable de vérité porte “XOR” :\n\n\n\nE1\nE2\nS\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\nL’additionneur\nEn combinant les portes logiques, on obtient des circuits plus complexes. Par exemple en combinant 2 portes “OU EXCLUSIF”, 2 portes “ET” et une porte “OU” on obtient un additionneur :\n\nComme son nom l’indique, l’additionneur permet d’additionner 2 bits (E1 et E2) en tenant compte de la retenue entrante (“Cin” “carry in” en anglais). En sortie on obtient le résultat de l’addition (S) et la retenue sortante (“Cout”).\n\n\n\nE1\nE2\nCin\nCout\nS\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n1\n\n\n0\n1\n0\n0\n1\n\n\n0\n1\n1\n1\n0\n\n\n1\n0\n0\n0\n1\n\n\n1\n0\n1\n1\n0\n\n\n1\n1\n0\n1\n0\n\n\n1\n1\n1\n1\n1\n\n\n\nEn combinant plusieurs fois le type de circuit décrit ci-dessus, on obtient des additionneurs capables d’additionner des nombres sur X bits.\nUne chose est très importante à bien comprendre : à la base nous avons le transistor, une combinaison de transistors (sous forme de circuit intégré) permet d’obtenir des circuits logiques, la combinaison de circuits logiques permet d’obtenir des circuits plus complexes (exemple : l’additionneur), et ainsi de suite…\nAu sommet de cet édifice, nous allons trouver la mémoire vive (RAM) et le microprocesseur (CPU).\nPour en savoir plus sur les portes logiques voir la vidéo “Les portes logiques” dans cet article.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 2"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_4.html",
    "href": "13_vonNeumann/neumann_cours_4.html",
    "title": "Cours : Partie 4",
    "section": "",
    "text": "Nous avons vu comment un assemblage de transistors pouvait permettre de faire des opérations logiques, de construire des mémoires, des microprocesseurs, …\nDans l’architecture de von Neumann, les instructions et les données sont stockées dans la même mémoire et toutes ces informations transitent sous la forme de signaux électriques entre la mémoire et les différents composants du CPU.\nToutes ces informations, instructions et données, sont codées par une suite de 0 et de 1 puisque c’est le seul langage compris au niveau du matériel. Comment cela se passe-t-il ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 4"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_4.html#fonctionnement-du-processeur",
    "href": "13_vonNeumann/neumann_cours_4.html#fonctionnement-du-processeur",
    "title": "Cours : Partie 4",
    "section": "1. Fonctionnement du processeur",
    "text": "1. Fonctionnement du processeur\nUn processeur donné est capable d’exécuter un certain nombre d’opérations de base, celles pour lesquelles il dispose d’un circuit électronique qui les réalise.\nL’ensemble des instructions exécutables directement par le microprocesseur (instructions machines) constitue ce que l’on appelle le “langage machine” du processeur.\nChaque instruction machine correspond à une configuration électronique binaire composée principalement de 2 parties :\n\nLe champ “code opération” (opcode) qui indique au processeur le type de traitement à réaliser. Par exemple, sur un certain modèle de processeur, le code “00100110” donne l’ordre d’effectuer une multiplication.\nLe champ “opérandes” indique la nature des données sur lesquelles l’opération désignée par le “code opération” doit être effectuée.\n\nUn opérande peut être de 3 natures différentes :\n\nl’opérande est une valeur immédiate : l’opération est effectuée directement sur la valeur donnée dans l’opérande ;\nl’opérande est un registre du CPU : l’opération est effectuée sur la valeur située dans un des registres (R0,R1, R2,…) ; l’opérande indique de quel registre il s’agit ;\nl’opérande est une donnée située en mémoire vive : l’opération est effectuée sur la valeur située en mémoire vive à l’adresse XXXXX. Cette adresse est indiquée dans l’opérande.\n\nLe programme exécuté se trouve en RAM, tout comme les données. Un registre particulier du processeur, nommé IP (instruction pointer), contient l’adresse de la cellule RAM de la prochaine instruction à exécuter.\nUn deuxième registre, IR (instruction register), joue un rôle important en raison de sa connexion physique au reste du processeur : placer dans ce registre la configuration électronique qui dénote une instruction provoque l’activation du circuit dédié à la réalisation de l’opération sous-jacente.\nLe CPU a un fonctionnement cyclique :\n\nil copie dans le registre IR le contenu de la RAM à l’adresse pointée par IP ;\nil décode l’instruction contenue dans IR : ceci provoque l’activation du circuit électronique qui réalise l’opération visée ;\nil exécute l’instruction décodée ; ceci met aussi à jour la valeur de IP pour continuer dans le programme.\n\nLa capacité du processeur à exécuter tous les programmes s’explique par ce fonctionnement très souple et par le fait que le jeu d’instructions de base est suffisamment riche pour être universel (on dit que le langage machine est Turing-complet).\nDans le modèle de von Neumann, il y a une seule mémoire vive pour le programme et les données : c’est par sa copie dans le registre IR qu’une configuration électronique initialement présente en RAM joue le rôle d’une instruction. La même configuration pourrait être interprétée comme une donnée (entier, etc.) dans un autre contexte.\nHistoriquement, les instructions machine sont relativement basiques ; on peut se contenter d’à peine plus que ce qui est nécessaire pour l’universalité. Pour des raisons de performance, les processeurs modernes savent exécuter nativement des opérations plus complexes, comme la composée addition-produit ou des opérations sur des vecteurs de petite dimension.\nLes opérations fondamentales sont de trois sortes :\n\nLes instructions arithmétiques (addition, soustraction, multiplication…) effectuent des calculs mathématiques, soit sur des entiers, soit sur des flottants. Par exemple, on peut avoir une instruction consistant à additionner la valeur contenue dans le registre R1 et le nombre 789 et ranger le résultat dans le registre R0.\nLes instructions de transfert de données permettent de transférer une donnée d’un registre du CPU vers la mémoire vive et vice versa. Par exemple, on peut avoir une instruction consistant à prendre la valeur située à l’adresse mémoire 487 et la placer dans la registre R2, ou encore prendre la valeur située dans le registre R1 et la placer à l’adresse mémoire 512.\nLes instructions de rupture de séquence ou instructions de saut. Elles permettent d’agir sur le registre IP qui contient l’adresse de la prochaine instruction à exécuter. Les instructions arithmétiques ou de transfert de données, outre leur effet spécifique, incrémentent la valeur de IP : de cette façon, l’exécution du programme avance séquentiellement (après avoir exécuté l’instruction placée à l’adresse 512, on passe à l’adresse 513, …). Les instructions de saut permettent de réaliser les autres structures de contrôle d’exécution, notamment l’alternative et la boucle.\n\nOn distingue les instructions de saut inconditionnel, qui modifient toujours IP à la valeur donnée en opérande, et les instructions de saut conditionnel, qui ne font cette modification que selon certaines circonstances, et sinon ont le comportement habituel d’incrémentation de IP. Une instruction de saut conditionnel permet par exemple d’agir comme suit : si la valeur contenue dans le registre R1 est strictement supérieure à 0 alors la prochaine instruction à exécuter est celle située à l’adresse mémoire 4521.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 4"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_4.html#le-langage-assembleur",
    "href": "13_vonNeumann/neumann_cours_4.html#le-langage-assembleur",
    "title": "Cours : Partie 4",
    "section": "2. Le langage Assembleur",
    "text": "2. Le langage Assembleur\nProgrammer en langage machine est extrêmement difficile (très longue suite de 0 et de 1), pour pallier cette difficulté, les informaticiens ont remplacé les codes binaires abscons par des symboles mnémoniques (plus facile à retenir qu’une suite de “1” et de “0”), cela donne l’assembleur.\nPar exemple un “ADD R1,R2,#125” sera équivalent à “11100010100000100001000001111101”.\nLe processeur est uniquement capable d’interpréter le langage machine, un programme appelé “assembleur” assure donc le passage de “ADD R1,R2,#125” à “11100010100000100001000001111101”. Par extension, on dit que l’on programme en assembleur quand on écrit des programmes avec ces symboles mnémoniques à la place de suite de “0” et de “1”.\nIl n’est pas question d’apprendre à programmer en assembleur, mais vous devez être capables de comprendre l’exécution d’une séquence d’instructions simples en assembleur.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 4"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_4.html#exemples-dinstructions",
    "href": "13_vonNeumann/neumann_cours_4.html#exemples-dinstructions",
    "title": "Cours : Partie 4",
    "section": "3. Exemples d’instructions",
    "text": "3. Exemples d’instructions\n\n\nAssembleur\n\nLDR R1,78\n\nPlace la valeur stockée à l’adresse mémoire 78 dans le registre R1 (par souci de simplification, nous continuons à utiliser des adresses mémoire codées en base 10)\n\n\nAssembleur\n\nSTR R3,125\n\nPlace la valeur stockée dans le registre R3 en mémoire vive à l’adresse 125\n\n\nAssembleur\n\nADD R1,R0,#128\n\nAdditionne le nombre 128 (une valeur immédiate est identifiée grâce au symbole #) et la valeur stockée dans le registre R0, place le résultat dans le registre R1\n\n\nAssembleur\n\nADD R0,R1,R2\n\nAdditionne la valeur stockée dans le registre R1 et la valeur stockée dans le registre R2, place le résultat dans le registre R0\n\n\nAssembleur\n\nSUB R1,R0,#128\n\nSoustrait le nombre 128 de la valeur stockée dans le registre R0, place le résultat dans le registre R1\n\n\nAssembleur\n\nSUB R0,R1,R2\n\nSoustrait la valeur stockée dans le registre R2 de la valeur stockée dans le registre R1, place le résultat dans le registre R0\n\n\nAssembleur\n\nMOV R1, #23\n\nPlace le nombre 23 dans le registre R1\n\n\nAssembleur\n\nMOV R0, R3\n\nPlace la valeur stockée dans le registre R3 dans le registre R0\n\n\nAssembleur\n\nB 45\n\nNous avons une structure de rupture de séquence, la prochaine instruction à exécuter se situe en mémoire vive à l’adresse 45\n\n\nAssembleur\n\nCMP R0, #23\n\nCompare la valeur stockée dans le registre R0 et le nombre 23. Cette instruction CMP doit précéder une instruction de branchement conditionnel BEQ, BNE, BGT, BLT (voir ci-dessous)\n\n\nAssembleur\n\nCMP R0, R1\n\nCompare la valeur stockée dans le registre R0 et la valeur stockée dans le registre R1.\n\n\nAssembleur\n\nCMP R0, #23\nBEQ 78\n\nLa prochaine instruction à exécuter se situe à l’adresse mémoire 78 si la valeur stockée dans le registre R0 est égale à 23\n\n\nAssembleur\n\nCMP R0, #23\nBNE 78\n\nLa prochaine instruction à exécuter se situe à l’adresse mémoire 78 si la valeur stockée dans le registre R0 n’est pas égale à 23\n\n\nAssembleur\n\nCMP R0, #23\nBGT 78\n\nLa prochaine instruction à exécuter se situe à l’adresse mémoire 78 si la valeur stockée dans le registre R0 est plus grand que 23\n\n\nAssembleur\n\nCMP R0, #23\nBLT 78\n\nLa prochaine instruction à exécuter se situe à l’adresse mémoire 78 si la valeur stockée dans le registre R0 est plus petit que 23\n\n\nAssembleur\n\nHALT\n\nArrête l’exécution du programme\nEncore une fois, il n’est pas question d’apprendre à programmer en assembleur, les instructions ci-dessus sont uniquement des exemples.\n\nUtilisation des labels\nEn fait, les instructions assembleur B, BEQ, BNE, BGT et BLT n’utilisent pas directement l’adresse mémoire de la prochaine instruction à exécuter, mais des “labels”. Un label correspond à une adresse en mémoire vive (c’est l’assembleur qui fera la traduction “label” \\(\\longrightarrow\\) “adresse mémoire”). L’utilisation d’un label évite donc d’avoir à manipuler des adresses mémoires en binaire ou en hexadécimal. Voici un exemple qui montre comment utiliser un label :\n\n\nAssembleur\n\nCMP R4, #18\nBGT monLabel\nMOV R0,#14\nHALT\nmonLabel:\nMOV R0,#18\nHALT\n\nDans l’exemple ci-dessus, nous avons choisi “monLabel” comme nom de label. La ligne “MOV R0,#18” a pour label “monLabel” car elle est située juste après la ligne “monLabel:”. Concrètement, voici ce qui se passe avec ce programme : si la valeur stockée dans le registre R4 est supérieure à 18 on place le nombre 18 dans le registre R0 sinon on place le nombre 14 dans le registre R0. ATTENTION : la présence du “HALT” juste après la ligne “MOV R0,#14” est indispensable, car sinon, la ligne “MOV R0,#18” sera aussi exécutée (même si la valeur stockée dans le registre R4 est inférieure à 18 )",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 4"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_4.html#du-langage-de-haut-niveau-à-lassembleur",
    "href": "13_vonNeumann/neumann_cours_4.html#du-langage-de-haut-niveau-à-lassembleur",
    "title": "Cours : Partie 4",
    "section": "4. Du langage de haut niveau à l’assembleur",
    "text": "4. Du langage de haut niveau à l’assembleur\nLes langages de programmation « évolués » (Python, C++, …), destinés à être utilisés par des humains, se composent d’instructions complexes, opérant sur des types de données beaucoup plus complexes que des booléens. Il faudra donc passer par une étape de « conversion » du langage évolué vers le langage machine, chaque instruction du langage « évolué » donnant lieu à un grand nombre d’instructions « élémentaires » du langage machine. On distinguera l’opération de compilation (conversion de tout le code évolué en langage machine) de l’opération d’interprétation (la conversion est réalisée au fur et à mesure du déroulement du code).\nPython, par exemple, est un langage interprété : un programme, l’interpréteur Python, se charge de traduire les instructions du langage en code assembleur au fur et à mesure de son exécution.\nVoici ce que pourrait donner la “transformation” d’un programme Python tout simple en langage machine (plus précisément ici en assembleur).\nVoici le programme Python :\nx = 4\ny = 8\nif x == 10:\n    y = 9\nelse :\n    x=x+1\nz=6\net voici maintenant voici son équivalent en assembleur :\n\n\nAssembleur\n\nMOV R0, #4\nSTR R0,30\nMOV R0, #8\nSTR R0,75\nLDR R0,30\nCMP R0, #10\nBNE else\nMOV R0, #9\nSTR R0,75\nB endif\nelse:\nLDR R0,30\nADD R0, R0, #1\nSTR R0,30\nendif:\nMOV R0, #6\nSTR R0,23\nHALT\n\nComme vous pouvez le constater le moindre programme Python donne un programme assembleur relativement complexe.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 4"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_cours_4.html#compléments-dinformations",
    "href": "13_vonNeumann/neumann_cours_4.html#compléments-dinformations",
    "title": "Cours : Partie 4",
    "section": "5. Compléments d’informations",
    "text": "5. Compléments d’informations\n\nLe modèle de von Neumann sur interstices\nMémoire et unité centrale, un couple dédié à l’exécution des programmes sur interstices\nUne histoire de l’architecture des ordinateurs sur Lumni",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "Cours : Partie 4"
    ]
  },
  {
    "objectID": "13_vonNeumann/neumann_TP.html",
    "href": "13_vonNeumann/neumann_TP.html",
    "title": "T.P. : Le simulateur AQA",
    "section": "",
    "text": "Objectifs\n\n\n\n\nUtiliser un simulateur d’architecture de von Neumann\nComprendre une séquence d’instructions donnée en langage machine\nTraduire un programme Python simple en assembleur et visualiser son exécution.\n\n\n\n\n\n\n\n\n\n\nCritères d’évaluation\n\n\n\n\nAutonomie dans la réalisation du travail demandé.\nQualité du compte-rendu (précision des réponses aux questions).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 2 - Modèle d'architecture de von Neumann et Systèmes d'exploitation",
      "T.P. : Le simulateur AQA"
    ]
  },
  {
    "objectID": "14_algo/algo_exos.html",
    "href": "14_algo/algo_exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices"
    ]
  },
  {
    "objectID": "14_algo/algo_exos.html#exercice-1",
    "href": "14_algo/algo_exos.html#exercice-1",
    "title": "Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\n\nÉcrire un algorithme, en langage naturel (puis en Python si vous le souhaitez), qui compte le nombre d’apparitions d’un élément c dans une liste L de longueur n. Écrivez aussi 3 tests.\nDéterminer sa complexité dans le pire des cas.\nJustifier que cet algorithme se termine",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices"
    ]
  },
  {
    "objectID": "14_algo/algo_exos.html#exercice-2",
    "href": "14_algo/algo_exos.html#exercice-2",
    "title": "Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\n\nÉcrire un algorithme, en Python, qui vérifie qu’une liste L est triée dans l’ordre croissant. L’algorithme doit renvoyer True si la liste est triée et False sinon. Écrivez aussi 3 tests.\nDéterminer sa complexité dans le pire des cas.\nJustifier que cet algorithme se termine",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices"
    ]
  },
  {
    "objectID": "14_algo/algo_exos.html#exercice-3",
    "href": "14_algo/algo_exos.html#exercice-3",
    "title": "Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\n\nÉcrire un algorithme, en Python, qui compte le nombre de voyelles dans une chaîne de caractères Phrase de longueur n. Écrivez aussi 3 tests.\nDéterminer sa complexité dans le pire des cas.\nJustifier que cet algorithme se termine",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices"
    ]
  },
  {
    "objectID": "14_algo/algo_exos.html#exercice-4",
    "href": "14_algo/algo_exos.html#exercice-4",
    "title": "Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\nOn considère l’algorithme suivant :\nAlgorithme mystere(mot)\nEntrée : mot est une chaîne de caractères de longueur n\nSortie : Un booléen\ni ← 0\nj ← n-1\np ← Vrai\ntant que i &lt;= j faire\n    si mot[i] != mot[j] alors\n        p ← Faux\n    i ← i+1\n    j ← j-1\nretourner p\n\nExécuter cet algorithme pour mot = radar. Quelle est la fonction de cet algorithme ?\nMontrer que d = j − i est un variant de boucle. En déduire que cet algorithme se termine.\nQuel est la complexité dans le pire des cas de cet algorithme ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices"
    ]
  },
  {
    "objectID": "14_algo/algo_exos.html#exercice-5",
    "href": "14_algo/algo_exos.html#exercice-5",
    "title": "Exercices",
    "section": " Exercice 5",
    "text": "Exercice 5\n\nÉcrire un algorithme utilisant une boucle « Tant que » permettant de déterminer si un entier n strictement positif est une puissance de 2.\nMontrer que la boucle se termine.\nMontrer que l’algorithme est correct (c’est-à-dire qu’il résout le problème initial).\nQuelle est la complexité dans le pire des cas de cet algorithme ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices"
    ]
  },
  {
    "objectID": "14_algo/algo_exos.html#exercice-6",
    "href": "14_algo/algo_exos.html#exercice-6",
    "title": "Exercices",
    "section": " Exercice 6",
    "text": "Exercice 6\n\nTrouver un invariant de boucle dans l’algorithme suivant, puis en déduire la valeur retournée à la fin de l’exécution.\n\nAlgorithme mystere(n)\nEntrée : n est un entier strictement positif\nSortie : p est un entier\np ← 1\npour i allant de 1 à n faire\n    p ← 2×p\nretourner p\n\nQuelle est la complexité dans le pire des cas de cet algorithme ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices"
    ]
  },
  {
    "objectID": "16_tris/index.html",
    "href": "16_tris/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "16_tris/index.html#points-traités-dans-cette-séquence",
    "href": "16_tris/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "16_tris/tris_exos.html",
    "href": "16_tris/tris_exos.html",
    "title": "Exercices - Algorithmes de tris",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices - Algorithmes de tris"
    ]
  },
  {
    "objectID": "16_tris/tris_exos.html#exercice-1",
    "href": "16_tris/tris_exos.html#exercice-1",
    "title": "Exercices - Algorithmes de tris",
    "section": " Exercice 1",
    "text": "Exercice 1\nCet exercice est à faire dans Capytale.\nÉcrire une fonction trie_chaine qui prend en argument une liste de chaînes de caractères et qui modifie cette liste en la triant en fonction du nombre de lettres. Cette fonction ne renvoie rien.\nTester la fonction avec la liste [\"un\", \"deux\", \"trois\", \"quatre\", \"cinq\", \"six\", \"sept\", \"huit\", \"neuf\", \"dix\"].",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices - Algorithmes de tris"
    ]
  },
  {
    "objectID": "16_tris/tris_exos.html#exercice-2-le-tri-à-bulles",
    "href": "16_tris/tris_exos.html#exercice-2-le-tri-à-bulles",
    "title": "Exercices - Algorithmes de tris",
    "section": " Exercice 2 : le tri à bulles",
    "text": "Exercice 2 : le tri à bulles\nCet exercice est à faire dans Capytale.\nL’algorithme de tri à bulles est le suivant :\n\nOn parcourt la liste de gauche à droite.\nSi deux éléments consécutifs sont dans le mauvais ordre, on les échange.\nSi, à l’étape précédente, au moins un échange a eu lieu, on recommence à l’étape 1.\nSinon, la liste est triée et on arrête.\n\n\nÉcrire toutes les étapes du tri à bulles pour la liste [5, 3, 2, 4, 1].\nSoit \\(n\\) un entier naturel non nul et \\(L\\) une liste de \\(n\\) entiers rangés dans l’ordre décroissant (pire des cas). Combien d’échanges sont nécessaires pour trier \\(L\\) dans l’ordre croissant ? En déduire une évaluation de la complexité de cet algorithme.\nÉcrire une fonction tri_bulles qui prend en argument une liste de nombres et qui modifie cette liste en la triant par ordre croissant en utilisant l’algorithme du tri à bulles. Cette fonction ne renvoie rien.\nAjouter une variable compteur dans la fonction tri_bulles qui compte le nombre d’échanges effectués. Ce nombre doit être renvoyé par la fonction. Tester la fonction avec la liste [5, 3, 2, 4, 1] et vérifier que le compteur vaut bien 6.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices - Algorithmes de tris"
    ]
  },
  {
    "objectID": "16_tris/tris_exos.html#t.p.-bilan-et-compléments",
    "href": "16_tris/tris_exos.html#t.p.-bilan-et-compléments",
    "title": "Exercices - Algorithmes de tris",
    "section": " T.P. : Bilan et compléments",
    "text": "T.P. : Bilan et compléments\n\n\n\n\n\n\nImportant\n\n\n\nNotebook Capytale pour ce T.P. : Capytale \nCe T.P. est à faire dans Capytale en suivant le lien ci-dessus.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Exercices - Algorithmes de tris"
    ]
  },
  {
    "objectID": "17_recherche/recherche_cours.html",
    "href": "17_recherche/recherche_cours.html",
    "title": "Cours",
    "section": "",
    "text": "On s’intéresse ici au problème de la recherche d’une valeur dans un tableau que l’on supposera triée dans l’ordre croissant.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "17_recherche/recherche_cours.html#approche-naïve",
    "href": "17_recherche/recherche_cours.html#approche-naïve",
    "title": "Cours",
    "section": "1. Approche naïve",
    "text": "1. Approche naïve\nLa première idée qui peut venir à l’esprit est de considérer les éléments du tableau les uns après les autres et de les comparer avec l’élément recherché.\nOn peut ainsi écrire une fonction recherche_naive qui prend en paramètre un tableau tàbleau et une valeur valeur et qui renvoie l’indice de la première occurrence de valeur dans tableau ou -1 si valeur n’est pas dans tableau.\n\ndef recherche_naive(tableau, valeur):\n    for i in range(len(tableau)):\n        if tableau[i] == valeur:\n            return i\n    return -1\n\nTest de cette fonction :\n\nrecherche_naive([1, 2, 3, 4, 5], 3)\n\n2\n\n\n\nrecherche_naive([1, 2, 3, 4, 5], 6)\n\n-1\n\n\nLa complexité dans le pire des cas correspond ici au cas où la valeur recherchée n’est pas dans la liste. Il faut alors parcourir toutes les valeurs du tableau et faire \\(n\\) comparaisons, où \\(n\\) est la taille du tableau. L’algorithme naïf a donc une complexité linéaire en \\(\\mathcal{O}(n)\\).\nIl est possible d’être plus efficace en exploitant le fait que la liste est triée.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "17_recherche/recherche_cours.html#recherche-dichotomique",
    "href": "17_recherche/recherche_cours.html#recherche-dichotomique",
    "title": "Cours",
    "section": "2. Recherche dichotomique",
    "text": "2. Recherche dichotomique\n\nLe principe\nDe façon intuitive, la recherche dichotomique consiste à diviser par deux la zone de recherche à chaque étape.\nOn commence par considérer l’ensemble des éléments du tableau. On regarde ensuite la valeur de l’élément du milieu du tableau. Si cette valeur est inférieure à la valeur recherchée, alors on poursuit la recherche sur la moitié supérieure du tableau. Si la valeur est supérieure à la valeur recherchée, alors on poursuit la recherche sur la moitié inférieure. Si la valeur est égale à la valeur recherchée, on a trouvé l’élément recherché.\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\n\nOn considère le tableau tableau trié dans l’ordre croissant dans lequel on recherche la valeur valeur.\nOn définit les bornes gauche et droite du tableau : indices du premier et du dernier élément de la partie du tableau dans laquelle on recherche.\nTant que gauche est inférieur ou égal à droite :\n\nOn calcule l’indice milieu du milieu du tableau.\nSi tableau[milieu] est égal à valeur, on renvoie milieu.\nSi tableau[milieu] est inférieur à valeur, on met à jour gauche à milieu + 1. Lors de l’itération suivante, on ne considérera donc que la partie du tableau située à droite de milieu.\nSi tableau[milieu] est supérieur à valeur, on met à jour droite à milieu - 1. Lors de l’itération suivante, on ne considérera donc que la partie du tableau située à gauche de milieu.\n\nOn renvoie -1 si valeur n’est pas dans tableau.\n\n\n\nExemple\nOn considère le tableau [1,4,7,10,13,16,19,22,25] et on cherche la valeur 22.\nOn commence par considérer l’ensemble des éléments du tableau (gauche=0 et droite=8). On regarde ensuite la valeur de l’élément du milieu du tableau. Ici, il s’agit de l’élément d’indice 4 (milieu=4), qui vaut 13. La valeur recherchée est supérieure à 13, donc on ne considère que la partie du tableau située à droite de l’élément du milieu.\nOn répète alors l’opération sur la partie du tableau située à droite de l’élément du milieu (gauche=5 et droite=8). On obtient le tableau [16,19,22,25] et on cherche la valeur 22. L’élément du milieu de ce tableau vaut 19 (milieu=6), qui est inférieur à 22. On ne considère donc que la partie du tableau située à droite de l’élément du milieu.\nOn répète donc l’opération sur la partie du tableau située à droite (gauche=7 et droite=8). On obtient le tableau [22,25] et on cherche la valeur 22. L’élément du milieu de ce tableau vaut 22 (milieu=7), qui est égal à 22. On a donc trouvé la valeur recherchée et l’algorithme est terminé en trois étapes.\n\n\n\nRecherche dichotomique\n\n\n\n\nProgrammation\nÉcrivons une fonction recherche_dichotomique qui prend en paramètre un tableau tableau et une valeur valeur et qui renvoie l’indice d’une occurrence de valeur dans tableau ou -1 si valeur n’est pas dans tableau.\n\ndef recherche_dichotomique(tableau, valeur):\n    gauche = 0\n    droite = len(tableau) - 1\n    while gauche &lt;= droite:\n        milieu = (gauche + droite) // 2\n        if tableau[milieu] == valeur:\n            return milieu\n        elif tableau[milieu] &lt; valeur:\n            gauche = milieu + 1\n        else:\n            droite = milieu - 1\n    return -1\n\nTest de cette fonction :\n\nrecherche_dichotomique([1, 2, 3, 4, 5], 2)\n\n1\n\n\n\nrecherche_dichotomique([1, 2, 3, 4, 5], 6)\n\n-1\n\n\n\n\nPreuve de terminaison\nPour prouver que l’algorithme se termine, il faut prouver que la boucle while se termine, et donc que la condition d’arrêt gauche &gt; droite finit par être vérifiée ou bien que la condition tableau[milieu] == valeur est vérifiée.\nChoisissons comme variant de boucle la différence droite - gauche et plaçons-nous dans le cas le plus défavorable où la condition tableau[milieu] == valeur n’est jamais vérifiée. À chaque passage dans la boucle, soit gauche est remplacé par milieu, soit droite est remplacé par milieu. La différence droite - gauche est donc toujours au moins diminuée de moitié. Au bout d’un nombre fini d’itérations, notre variant de boucle devient donc inférieur ou égal à zéro et la boucle se termine.\nLa terminaison de l’algorithme est donc prouvée.\n\n\nPreuve de correction\nConsidérons la propriété suivante : à chaque étape de l’algorithme, la valeur recherchée est située dans la partie du tableau située entre les indices gauche et droite inclus, ou bien elle n’est pas dans le tableau.\nMontrons que cette propriété est un invariant de boucle. C’est-à-dire que cette propriété est vraie avant l’exécution de la première itération de la boucle et qu’elle est vraie après l’exécution de chaque itération de la boucle.\nInitialisation : avant l’exécution de la première itération de la boucle, si la valeur est dans le tableau, alors elle est située dans la partie du tableau située entre les indices gauche et droite inclus. En effet, gauche vaut 0 et droite vaut la taille du tableau moins un, donc la valeur recherchée est située dans la partie du tableau située entre les indices 0 et la taille du tableau moins un inclus (c’est le tableau entier !).\nConservation : supposons que la propriété est vraie à l’entrée dans une itération de la boucle while. Il y a trois possibilités :\n\ntableau[milieu] == valeur est vérifiée. Dans ce cas, la propriété est vraie à la sortie de l’itération de la boucle et l’algorithme retourne l’indice attendu.\ntableau[milieu] &lt; valeur est vérifiée. Dans ce cas, gauche est remplacé par milieu. La valeur recherchée est donc située dans la partie du tableau située entre les indices gauche et droite inclus, ou bien elle est absente du tableau.\ntableau[milieu] &gt; valeur est vérifiée. Dans ce cas, droite est remplacé par milieu. La valeur recherchée est donc située dans la partie du tableau située entre les indices gauche et droite inclus, ou bien elle est absente du tableau.\n\nConclusion : la propriété est donc un invariant de boucle.\nDeux cas sont à considérer pour conclure. Si le test tableau[milieu] == valeur est vérifié au cours des itérations, alors la valeur est trouvée dans le tableau et on retourne son indice milieu : c’est bien le comportement attendu. Si le test tableau[milieu] == valeur n’est jamais vérifié, alors l’algorithme se termine lorsque gauche &gt; droite. D’après notre invariant de boucle, soit la valeur est alors absente du tableau, soit elle est située dans la partie du tableau située entre les indices gauche et droite inclus. Mais cette partie du tableau est un tableau vide []. La valeur est donc absente du tableau et on retourne l’indice -1 : c’est bien le comportement attendu.\nL’algorithme est donc correct.\n\n\nComplexité\nPour évaluer la complexité de cet algorithme, nous allons évaluer le nombre d’itérations nécessaires en fonction de la taille \\(n\\) du tableau, dans le pire des cas, c’est-à-dire lorsque la valeur recherchée n’est pas dans le tableau.\nÀ chaque étape, la taille du sous-tableau contenant potentiellement la valeur recherchée est divisée par deux. Au bout de \\(k\\) étapes, la taille du sous-tableau est donc de \\(\\frac{n}{2^k}\\) environ. Si la valeur recherchée n’est pas dans le tableau, alors on finit par arriver à un tableau de taille 1 et la boucle se termine au tour suivant. Soit \\(k\\) le nombre d’itérations nécessaires pour que la taille du sous-tableau soit de 1. On a donc \\(\\frac{n}{2^k}\\approx 1\\), et par conséquent \\(n=2^k\\). On en déduit que \\(k=\\log_2 n\\).\nL’algorithme de recherche dichotomique est donc en \\(\\mathcal{O}(\\log n)\\). On parle de complexité logarithmique. Cette complexité est meilleure que la complexité linéaire.\n\n\n\n\n\n\nNotion de logarithme de base 2\n\n\n\nSi \\(x\\) est une puissance de 2, alors \\(\\log_2 x\\) est égal à l’exposant de cette puissance. Par exemple, \\(\\log_2 8 = 3\\) car \\(8 = 2^3\\).\n\n\nPour un tableau de départ de taille \\(16=2^4\\) dans lequel on cherche une valeur qui n’y est pas, on effectue 4 itérations :\n\nau premier tour, on divise le tableau en deux parties de taille \\(8=2^3\\) et on cherche dans la partie de gauche (par exemple) ;\nau deuxième tour, on divise la partie de gauche en deux parties de taille \\(4=2^2\\) et on cherche dans la partie de gauche (par exemple) ;\nau troisième tour, on divise la partie de gauche en deux parties de taille \\(2=2^1\\) et on cherche dans la partie de gauche (par exemple) ;\nau quatrième tour, on divise la partie de gauche en deux parties de taille \\(1=2^0\\) et on cherche dans la partie de gauche (par exemple).\n\nOn retrouve bien un nombre d’itérations de l’ordre de \\(\\log_2 n\\).\n\n\nComparaison expérimentale des deux algorithmes\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps_naive = []\ntemps_dicho = []\n# on applique la recherche dans le pire des cas : valeur absente su tableau\nvaleur = 1000\nfor n in tailles:\n    temps_naive.append(timeit.timeit(\n        \"recherche_naive([k for k in range(n)], valeur)\",\n        globals=globals(),\n        number=100\n    ))\n    temps_dicho.append(timeit.timeit(\n        \"recherche_dichotomique([k for k in range(n)], valeur)\",\n        globals=globals(),\n        number=100\n    ))\nplt.plot(tailles,temps_naive, 'b', label=\"Recherche naïve\")\nplt.plot(tailles,temps_dicho, 'r', label=\"Recherche dichotomique\")\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.legend()\nplt.show()",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "18_html/acti1_HTML.html",
    "href": "18_html/acti1_HTML.html",
    "title": "Activité : Page web et langage HTML",
    "section": "",
    "text": "Objectifs de cette activité\n\n\n\nÀ l’issue de cette activité, vous saurez :\n\ncomment est codée une page web simple ;\nreconnaître les principales balises HTML ;\ncréer une page HTML simple.\nPour cette activité, on utilisera de préférence le navigateur Firefox.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Page web et langage HTML"
    ]
  },
  {
    "objectID": "18_html/acti1_HTML.html#partie-1.-observation-dune-page-html-simple",
    "href": "18_html/acti1_HTML.html#partie-1.-observation-dune-page-html-simple",
    "title": "Activité : Page web et langage HTML",
    "section": "Partie 1. Observation d’une page HTML simple",
    "text": "Partie 1. Observation d’une page HTML simple\n\nOuvrir dans un nouvel onglet la page suivante : Tim_Berners.html. La page qui s’affiche est une page HTML contenant des informations textuelles avec une mise en forme (titres, paragraphes, liste à puce, liste numérotée, caractères gras, italiques, …), une image et un extrait de vidéo.\nFaire un clic droit dans la page et cliquer sur “Code source de la page” pour faire apparaître la page HTML source. Le fichier qui s’ouvre est un fichier texte. Il contient le descriptif de la page Web en langage HTML : c’est sous cette forme que le navigateur reçoit la page Web. Il interprète ensuite le langage HTML pour produire l’affichage obtenu à la question précédente.\n\n\n\n\n\n\n\nÀ savoir\n\n\n\nLorsque vous chargez la page web, celle-ci se trouve physiquement enregistrée sous forme de fichier HTML sur un serveur distant (un serveur est un ordinateur destiné à interagir avec d’autres ordinateurs, le plus souvent dans le contexte d’un réseau).\nCette page, une fois reçue par votre navigateur dans l’ordinateur local, appelé client, est lue par le navigateur qui interprète le langage HTML et produit l’affichage correspondant.\n\nIl s’agit d’un premier exemple de dialogue client-serveur, cette notion sera approfondie dans la suite.\n\n\n\nObserver le code HTML. Il est composé de balises, la plupart de la forme &lt;balise&gt;...&lt;/balise&gt;. Identifier les balises qui définissent :\n\nun titre ;\nun paragraphe ;\ndu texte en gras (pour montrer l’importance d’un mot ou d’un groupe de mots) ;\ndu texte en italique (pour insister sur un mot ou un groupe de mots) ;\nune liste à puces ;\nune liste numérotée.\n\nQuelles balises permettent :\n\nd’insérer une image ;\nd’insérer une vidéo.\n\nQuel semble être le rôle des balises &lt;html&gt;, &lt;head&gt; et &lt;body&gt; ?\nCertaines balises ne semblent servir à rien ! Lesquelles ? Nous verrons plus tard leur utilité éventuelle.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Page web et langage HTML"
    ]
  },
  {
    "objectID": "18_html/acti1_HTML.html#partie-2.-modification-dune-page-html-simple",
    "href": "18_html/acti1_HTML.html#partie-2.-modification-dune-page-html-simple",
    "title": "Activité : Page web et langage HTML",
    "section": "Partie 2. Modification d’une page HTML simple",
    "text": "Partie 2. Modification d’une page HTML simple\n\nOuvrir l’activité Capytale correspondant à cette partie : cliquez ici !.\nVous retrouvez le code HTML de la page Web précédente ainsi que son rendu dans le navigateur intégré à Capytale. Modifier la page Web afin qu’elle remplisse les spécifications suivantes :\n\nAjouter une deuxième photo différente de Timothy John Berners-Lee.\nAjouter un court paragraphe qui résume la biographie de Timothy John Berners-Lee. Ce paragraphe sera précédé d’un titre de niveau 2. Il contiendra certains mots sur lesquels vous voulez insister et d’autres dont vous montrerez l’importance.\nTransformer la liste à puce en liste numérotée et vice-versa.\nSupprimer la vidéo.\n\nUne fois toutes ces modifications effectuées, enregistrer votre travail dans Capytale.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Page web et langage HTML"
    ]
  },
  {
    "objectID": "18_html/acti1_HTML.html#partie-3.-création-dune-page-web",
    "href": "18_html/acti1_HTML.html#partie-3.-création-dune-page-web",
    "title": "Activité : Page web et langage HTML",
    "section": "Partie 3. Création d’une page Web",
    "text": "Partie 3. Création d’une page Web\nUtiliser les observations faites au cours de cette activité pour créer une page Web sur le sujet de votre choix.\nCette page devra comporter différentes balises, des images, des listes, etc.\nEnregistrer votre travail dans Capytale en suivant ce lien et le soumettre.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Page web et langage HTML"
    ]
  },
  {
    "objectID": "18_html/index.html",
    "href": "18_html/index.html",
    "title": "Programme",
    "section": "",
    "text": "Lors de la navigation sur le Web, les internautes interagissent avec leur machine par le biais des pages Web.\nL’Interface Homme-Machine (IHM) repose sur la gestion d’événements associés à des éléments graphiques munis de méthodes algorithmiques.\nLa compréhension du dialogue client-serveur déjà abordé en classe de seconde est consolidée, sur des exemples simples, en identifiant les requêtes du client, les calculs puis les réponses du serveur traitées par le client.\nIl ne s’agit pas de décrire exhaustivement les différents éléments disponibles, ni de développer une expertise dans les langages qui permettent de mettre en œuvre le dialogue tels que PHP ou JavaScript.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nModalités de l’interaction entre l’homme et la machine Événements\nIdentifier les différents composants graphiques permettant d’interagir avec une application Web. Identifier les événements que les fonctions associées aux différents composants graphiques sont capables de traiter.\nIl s’agit d’examiner le code HTML d’une page comprenant des composants graphiques et de distinguer ce qui relève de la description des composants graphiques en HTML de leur comportement (réaction aux événements) programmé par exemple en JavaScript.\n\n\nInteraction avec l’utilisateur dans une page Web\nAnalyser et modifier les méthodes exécutées lors d’un clic sur un bouton d’une page Web.\n\n\n\nInteraction client-serveur. Requêtes HTTP, réponses du serveur\nDistinguer ce qui est exécuté sur le client ou sur le serveur et dans quel ordre. Distinguer ce qui est mémorisé dans le client et retransmis au serveur. Reconnaître quand et pourquoi la transmission est chiffrée.\nIl s’agit de faire le lien avec ce qui a été vu en classe de seconde et d’expliquer comment on peut passer des paramètres à un site grâce au protocole HTTP.\n\n\nFormulaire d’une page Web\nAnalyser le fonctionnement d’un formulaire simple. Distinguer les transmissions de paramètres par les requêtes POST ou GET.\nDiscuter les deux types de requêtes selon le type des valeurs à transmettre et/ou leur confidentialité."
  },
  {
    "objectID": "19_css/acti2_CSS.html",
    "href": "19_css/acti2_CSS.html",
    "title": "Activité : Le couple HTML/CSS",
    "section": "",
    "text": "Objectifs de cette activité\n\n\n\nÀ l’issue de cette activité, vous saurez :\n\ncomment est codée la mise en page et le style d’une page Web ;\nreconnaître quelques exemples d’instructions CSS ;\ncréer une feuille de style et l’appliquer à une page HTML.\nPour cette activité, on utilisera de préférence le navigateur Firefox.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Le couple HTML/CSS"
    ]
  },
  {
    "objectID": "19_css/acti2_CSS.html#partie-1.-observation-dune-page-web-stylée",
    "href": "19_css/acti2_CSS.html#partie-1.-observation-dune-page-web-stylée",
    "title": "Activité : Le couple HTML/CSS",
    "section": "Partie 1. Observation d’une page Web stylée",
    "text": "Partie 1. Observation d’une page Web stylée\n\nOuvrir dans un nouvel onglet la page suivante : Tim_Berners_css.html. La page qui s’affiche est à peu près la même que celle que vous avez analysée dans l’activité 1, mais avec une application de différents styles.\nFaire un clic droit dans la page et cliquer sur “Code source de la page” pour faire apparaître la page HTML source. Quels sont les principaux changements ?\nDans la balise &lt;head&gt; de la page se trouve un lien vers la feuille de style CSS de la page. Ouvrir cette feuille dans un nouvel onglet et observer le code CSS définissant le style de la page Web.\nDécrire en quelques mots la syntaxe CSS et en relever les règles de base.\nRechercher, en comparant les fichiers CSS et HTML, le rôle des instructions .en_couleur et #titres et où elles s’appliquent.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Le couple HTML/CSS"
    ]
  },
  {
    "objectID": "19_css/acti2_CSS.html#partie-2.-modification-du-fichier-css",
    "href": "19_css/acti2_CSS.html#partie-2.-modification-du-fichier-css",
    "title": "Activité : Le couple HTML/CSS",
    "section": "Partie 2. Modification du fichier CSS",
    "text": "Partie 2. Modification du fichier CSS\n\nOuvrir l’activité Capytale correspondant à cette partie.\nVous trouverez la page Web et sa feuille de style. Modifier la feuille de style (et si nécessaire la page Web) :\n\nChanger les couleurs d’arrière-plan ;\nChanger la couleur du texte de tout le contenu de la section qui a pour identifiant “introduction” ;\nChanger la taille du texte de tous les éléments qui possèdent la classe “en_couleur” ;\nSupprimer l’indentation des paragraphes ;\nChanger les puces de la liste : vous utiliserez pour cela l’attribut list-style-type: square; ;\nDans la liste numérotée, changer les numéros en chiffres romains majuscules : vous utiliserez pour cela l’attribut list-style-type: upper-roman;.\n\nUne fois toutes ces modifications faites, enregistrer votre travail.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Le couple HTML/CSS"
    ]
  },
  {
    "objectID": "19_css/acti2_CSS.html#partie-3.-création-dun-fichier-css",
    "href": "19_css/acti2_CSS.html#partie-3.-création-dun-fichier-css",
    "title": "Activité : Le couple HTML/CSS",
    "section": "Partie 3. Création d’un fichier CSS",
    "text": "Partie 3. Création d’un fichier CSS\nDans cette partie, vous allez reprendre la page Web créée lors de l’activité sur le langage HTML et créer une feuille de style afin de la mettre en forme. Quand vous serez satisfait du résultat, enregistrer votre travail dans l’activité Capytale prévue à cet effet.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Le couple HTML/CSS"
    ]
  },
  {
    "objectID": "19_css/index.html",
    "href": "19_css/index.html",
    "title": "Programme",
    "section": "",
    "text": "Lors de la navigation sur le Web, les internautes interagissent avec leur machine par le biais des pages Web.\nL’Interface Homme-Machine (IHM) repose sur la gestion d’événements associés à des éléments graphiques munis de méthodes algorithmiques.\nLa compréhension du dialogue client-serveur déjà abordé en classe de seconde est consolidée, sur des exemples simples, en identifiant les requêtes du client, les calculs puis les réponses du serveur traitées par le client.\nIl ne s’agit pas de décrire exhaustivement les différents éléments disponibles, ni de développer une expertise dans les langages qui permettent de mettre en œuvre le dialogue tels que PHP ou JavaScript.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nModalités de l’interaction entre l’homme et la machine Événements\nIdentifier les différents composants graphiques permettant d’interagir avec une application Web. Identifier les événements que les fonctions associées aux différents composants graphiques sont capables de traiter.\nIl s’agit d’examiner le code HTML d’une page comprenant des composants graphiques et de distinguer ce qui relève de la description des composants graphiques en HTML de leur comportement (réaction aux événements) programmé par exemple en JavaScript.\n\n\nInteraction avec l’utilisateur dans une page Web\nAnalyser et modifier les méthodes exécutées lors d’un clic sur un bouton d’une page Web.\n\n\n\nInteraction client-serveur. Requêtes HTTP, réponses du serveur\nDistinguer ce qui est exécuté sur le client ou sur le serveur et dans quel ordre. Distinguer ce qui est mémorisé dans le client et retransmis au serveur. Reconnaître quand et pourquoi la transmission est chiffrée.\nIl s’agit de faire le lien avec ce qui a été vu en classe de seconde et d’expliquer comment on peut passer des paramètres à un site grâce au protocole HTTP.\n\n\nFormulaire d’une page Web\nAnalyser le fonctionnement d’un formulaire simple. Distinguer les transmissions de paramètres par les requêtes POST ou GET.\nDiscuter les deux types de requêtes selon le type des valeurs à transmettre et/ou leur confidentialité."
  },
  {
    "objectID": "20_js/index.html",
    "href": "20_js/index.html",
    "title": "Programme",
    "section": "",
    "text": "Lors de la navigation sur le Web, les internautes interagissent avec leur machine par le biais des pages Web.\nL’Interface Homme-Machine (IHM) repose sur la gestion d’événements associés à des éléments graphiques munis de méthodes algorithmiques.\nLa compréhension du dialogue client-serveur déjà abordé en classe de seconde est consolidée, sur des exemples simples, en identifiant les requêtes du client, les calculs puis les réponses du serveur traitées par le client.\nIl ne s’agit pas de décrire exhaustivement les différents éléments disponibles, ni de développer une expertise dans les langages qui permettent de mettre en œuvre le dialogue tels que PHP ou JavaScript.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nModalités de l’interaction entre l’homme et la machine Événements\nIdentifier les différents composants graphiques permettant d’interagir avec une application Web. Identifier les événements que les fonctions associées aux différents composants graphiques sont capables de traiter.\nIl s’agit d’examiner le code HTML d’une page comprenant des composants graphiques et de distinguer ce qui relève de la description des composants graphiques en HTML de leur comportement (réaction aux événements) programmé par exemple en JavaScript.\n\n\nInteraction avec l’utilisateur dans une page Web\nAnalyser et modifier les méthodes exécutées lors d’un clic sur un bouton d’une page Web.\n\n\n\nInteraction client-serveur. Requêtes HTTP, réponses du serveur\nDistinguer ce qui est exécuté sur le client ou sur le serveur et dans quel ordre. Distinguer ce qui est mémorisé dans le client et retransmis au serveur. Reconnaître quand et pourquoi la transmission est chiffrée.\nIl s’agit de faire le lien avec ce qui a été vu en classe de seconde et d’expliquer comment on peut passer des paramètres à un site grâce au protocole HTTP.\n\n\nFormulaire d’une page Web\nAnalyser le fonctionnement d’un formulaire simple. Distinguer les transmissions de paramètres par les requêtes POST ou GET.\nDiscuter les deux types de requêtes selon le type des valeurs à transmettre et/ou leur confidentialité."
  },
  {
    "objectID": "21_client-serveur/acti4_forms.html",
    "href": "21_client-serveur/acti4_forms.html",
    "title": "Activité : Formulaires Web",
    "section": "",
    "text": "Objectifs de cette activité\n\n\n\nÀ l’issue de cette activité, vous saurez :\n\ncréer un formulaire simple ;\ncomprendre son fonctionnement ;\ndistinguer les transmissions de paramètres par les méthodes GET et POST.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Formulaires Web"
    ]
  },
  {
    "objectID": "21_client-serveur/acti4_forms.html#que-sont-les-formulaires-web",
    "href": "21_client-serveur/acti4_forms.html#que-sont-les-formulaires-web",
    "title": "Activité : Formulaires Web",
    "section": "Que sont les formulaires Web ?",
    "text": "Que sont les formulaires Web ?\nLes formulaires Web sont l’un des principaux points d’interaction entre un utilisateur et un site Web. Les formulaires permettent aux utilisateurs de saisir des données, qui sont généralement envoyées à un serveur Web pour traitement et stockage, ou utilisées côté client pour mettre à jour immédiatement l’interface d’une manière ou d’une autre (par exemple, ajouter un autre élément à une liste, ou afficher ou masquer une fonctionnalité de l’interface utilisateur).\nLe code HTML d’un formulaire Web est composé d’un ou plusieurs contrôles de formulaire (parfois appelés widgets), ainsi que d’éléments supplémentaires pour aider à structurer le formulaire global. Les contrôles peuvent être des champs de texte à une ou plusieurs lignes, des listes déroulantes, des boutons, des cases à cocher ou des boutons radio, et sont principalement créés à l’aide de l’élément &lt;input&gt;.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Formulaires Web"
    ]
  },
  {
    "objectID": "21_client-serveur/acti4_forms.html#création-dun-formulaire-simple",
    "href": "21_client-serveur/acti4_forms.html#création-dun-formulaire-simple",
    "title": "Activité : Formulaires Web",
    "section": "Création d’un formulaire simple",
    "text": "Création d’un formulaire simple\nAvant de commencer à coder, il est toujours préférable de prendre du recul et de prendre le temps de réfléchir à votre formulaire. La conception d’une maquette rapide est toujours une bonne démarche.\nDans cette activité, nous allons créer un formulaire de récupération de mot de passe oublié. Faisons un croquis :\n\n\n\nCroquis du formulaire\n\n\nNotre formulaire contiendra deux champs de texte et un bouton. Nous demandons à l’utilisateur son identifiant et son e-mail. Appuyer sur le bouton enverra les données à un serveur Web.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Formulaires Web"
    ]
  },
  {
    "objectID": "21_client-serveur/acti4_forms.html#implémentation-de-notre-formulaire-html",
    "href": "21_client-serveur/acti4_forms.html#implémentation-de-notre-formulaire-html",
    "title": "Activité : Formulaires Web",
    "section": "Implémentation de notre formulaire HTML",
    "text": "Implémentation de notre formulaire HTML\nTout d’abord, créons le HTML pour notre formulaire. Nous utiliserons les éléments HTML suivants : &lt;form&gt;, &lt;label&gt;, &lt;input&gt;, et &lt;button&gt;.\nCliquer sur ce lien pour accéder à Capytale où cette activité sera réalisée.\nTous les formulaires commencent par un élément &lt;form&gt; de la forme :\n&lt;form action=\"\" method=\"post\"&gt;…&lt;/form&gt;\nCet élément définit un formulaire. C’est un élément conteneur, mais spécifiquement pour contenir des formulaires ; il prend également en charge certains attributs spécifiques pour configurer le comportement du formulaire. Tous ses attributs sont facultatifs, mais il est courant de toujours définir au moins les attributs action et method\n\nL’attribut action définit l’emplacement (URL) où les données collectées du formulaire doivent être envoyées lors de sa soumission. Pour l’instant, nous avons laissé cet attribut vide.\nL’attribut method définit la méthode HTTP avec laquelle envoyer les données (généralement GET ou POST).\n\nPour l’instant, ajoutez le code HTML ci-dessous dans le fichier index.html.\n&lt;form action=\"\" method=\"get\"&gt;\n    &lt;p&gt;Mot de passe oublié&lt;/p&gt;\n    &lt;label for=\"identifiant\"&gt;Identifiant&lt;/label&gt;&lt;br&gt;\n    &lt;input type=\"text\" id=\"identifiant\" name=\"user_id\" /&gt;&lt;br&gt;\n    &lt;label for=\"mail\"&gt;E-mail:&lt;/label&gt;&lt;br&gt;\n    &lt;input type=\"email\" id=\"mail\" name=\"user_email\" /&gt;&lt;br&gt;\n&lt;/form&gt;\nNotre formulaire de contact n’est pas complexe : la partie saisie de données contient deux champs de texte &lt;input&gt;, chacun avec un &lt;label&gt; correspondant :\n\nLe champ de saisie l’identifiant est un champ de texte sur une seule ligne.\nLe champ de saisie de l’e-mail est une entrée de type email : un champ texte d’une seule ligne qui n’accepte que les adresses e-mail.\n\nPour la convivialité et l’accessibilité, nous incluons une étiquette explicite &lt;label&gt; pour chaque contrôle de formulaire. Notez l’utilisation de l’attribut &lt;for&gt; sur tous les éléments &lt;label&gt;, qui prend comme valeur l’identifiant du contrôle de formulaire auquel il est associé — c’est ainsi que l’on associe un contrôle de formulaire à son libellé.\nIl y a un grand avantage à faire cela, car on associe ainsi l’étiquette au contrôle de formulaire, permettant aux utilisateurs de souris, de trackpad et d’appareils tactiles de cliquer sur l’étiquette pour activer le contrôle correspondant.\nDans l’élément &lt;input&gt;, l’attribut le plus important est l’attribut type. Cet attribut est extrêmement important car il définit la façon dont l’élément &lt;input&gt; apparaît et se comporte.\n\nDans notre exemple simple, nous utilisons le type text pour le premier &lt;input&gt; — la valeur par défaut pour cet attribut. Il représente un champ de texte de base sur une seule ligne qui accepte tout type de saisie de texte.\nPour le deuxième &lt;input&gt;, nous utilisons le type email, qui définit un champ de texte sur une seule ligne qui n’accepte qu’une adresse e-mail bien formée. Cela transforme un champ de texte de base en une sorte de champ “intelligent” qui effectuera des contrôles de validation sur les données saisies par l’utilisateur. Cela entraîne également l’apparition d’une disposition de clavier plus appropriée pour la saisie d’adresses e-mail (par exemple, avec un symbole @ par défaut) sur les appareils dotés de claviers dynamiques, comme les smartphones.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Formulaires Web"
    ]
  },
  {
    "objectID": "21_client-serveur/acti4_forms.html#ajout-du-bouton",
    "href": "21_client-serveur/acti4_forms.html#ajout-du-bouton",
    "title": "Activité : Formulaires Web",
    "section": "Ajout du bouton",
    "text": "Ajout du bouton\nLe balisage de notre formulaire est presque terminé ; il suffit d’ajouter un bouton pour permettre à l’utilisateur d’envoyer, ou “soumettre”, ses données une fois qu’il a rempli le formulaire. Ceci est fait en utilisant l’élément &lt;button&gt;.\nAjoutez ce qui suit juste avant la balise de fermeture &lt;/form&gt; :\n&lt;button type=\"submit\"&gt;Récupérer mon mot de passe&lt;/button&gt;\nL’élément &lt;button&gt; accepte également un attribut type — celui-ci accepte l’une des trois valeurs : submit, reset, ou button.\n\nUn clic sur un bouton submit (la valeur par défaut) envoie les données du formulaire vers la page web définie par l’attribut action de l’élément &lt;/form&gt;.\nUn clic sur un bouton reset réinitialise immédiatement tous les widgets du formulaire à leur valeur par défaut.\nUn clic sur un bouton button ne fait rien ! Cela semble idiot, mais c’est incroyablement utile pour créer des boutons personnalisés - vous pouvez définir la fonctionnalité choisie avec JavaScript.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Formulaires Web"
    ]
  },
  {
    "objectID": "21_client-serveur/acti4_forms.html#mise-en-forme-du-formulaire",
    "href": "21_client-serveur/acti4_forms.html#mise-en-forme-du-formulaire",
    "title": "Activité : Formulaires Web",
    "section": "Mise en forme du formulaire",
    "text": "Mise en forme du formulaire\nPour le moment, le formulaire a l’air plutôt moche.\nNous allons utiliser un fichier de style au format CSS pour le rendre plus agréable.\nTout d’abord, créer dans Capytale un fichier nommé style.css (si ce n’est pas déjà fait) et lier ce fichier au fichier HTML en ajoutant la ligne suivante dans l’entête de celui-ci :\n&lt;link rel=\"stylesheet\" href=\"style.css\"&gt;\nDans le fichier style.css, ajoutez le CSS suivant :\nform {\n  /* Centre le formulaire sur la page */\n  margin: 0 auto;\n  width: 400px;\n  /* Bordure du formulaire */\n  padding-left: 1em;\n  padding-right: 1em; \n  border: 1px solid #ccc;\n}\n\nform p {\n    border-bottom: 1px solid #99c1f1;\n    padding-bottom: 1em;\n}\n\nlabel {\n  display: inline-block;\n  width: 90px;\n  text-align: left;\n  padding-bottom: 0.5em;\n  padding-top: 0.5em;\n}\n\ninput {\n  font: 1em sans-serif;\n  width: 390px;\n  box-sizing: border-box;\n  border: 1px solid #999;\n}\n\ninput:focus {\n  /* S'applique quand le widget est activé */\n  border-color: #0000ff;\n}\n\nbutton {\n    display: block;\n    margin: 1em auto;\n    background-color: #66bbff;\n    color: white;\n    font-weight: bold;\n}\nEnregistrez et rechargez : votre formulaire devrait avoir l’air beaucoup moins laid.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Formulaires Web"
    ]
  },
  {
    "objectID": "21_client-serveur/acti4_forms.html#envoi-des-données-de-formulaire-à-votre-serveur-web",
    "href": "21_client-serveur/acti4_forms.html#envoi-des-données-de-formulaire-à-votre-serveur-web",
    "title": "Activité : Formulaires Web",
    "section": "Envoi des données de formulaire à votre serveur Web",
    "text": "Envoi des données de formulaire à votre serveur Web\nLa dernière partie, et peut-être la plus délicate, consiste à gérer les données du formulaire côté serveur. L’élément &lt;form&gt; définit où et comment envoyer les données grâce aux attributs action et method.\nNous fournissons un attribut name pour chaque contrôle de formulaire. Les noms sont importants à la fois côté client et côté serveur ; ils indiquent au navigateur quel nom donner à chaque donnée et, côté serveur, ils laissent le serveur gérer chaque donnée par son nom. Les données du formulaire sont envoyées au serveur sous forme de paires nom/valeur.\nPour nommer les données dans un formulaire, vous devez utiliser l’attribut name sur chaque widget de formulaire qui collectera une donnée spécifique.\nRegardons notre code de formulaire : modifiez comme indiqué ci-dessous la valeur de l’attribut action afin que les données soient envoyées à la page https://sitelf.fr/divers/acti4_forms.php :\n&lt;form action=\"https://sitelf.fr/divers/acti4_forms.php\" method=\"get\"&gt;\n  &lt;p&gt;Mot de passe oublié&lt;/p&gt;\n  &lt;label for=\"identifiant\"&gt;Identifiant&lt;/label&gt;&lt;br&gt;\n  &lt;input type=\"text\" id=\"identifiant\" name=\"user_id\" /&gt;&lt;br&gt;\n  &lt;label for=\"mail\"&gt;E-mail:&lt;/label&gt;&lt;br&gt;\n  &lt;input type=\"email\" id=\"mail\" name=\"user_email\" /&gt;&lt;br&gt;\n  &lt;button type=\"submit\"&gt;Récupérer mon mot de passe&lt;/button&gt;\n&lt;/form&gt;\nDans notre exemple, le formulaire enverra 2 données nommées “user_id” et ” user_email”. Ces données seront envoyées à l’URL https://sitelf.fr/divers/acti4_forms.php en utilisant la méthode HTTP GET.\nCôté serveur, le script à l’URL https://sitelf.fr/divers/acti4_forms.php recevra les données sous la forme d’une liste de 2 éléments clé/valeur contenus dans la requête HTTP. La façon dont ce script traitera ces données dépend de vous. Chaque langage côté serveur (PHP, Python, Ruby, Java, C#, etc.) possède son propre mécanisme de gestion des données de formulaire. Nous n’allons pas approfondir ce sujet ici.\nPour notre exemple, c’est le langage PHP qui est utilisé.\nVoici, pour information, le contenu du fichier acti4_forms.php (remarque : les éléments CSS sont ici directement inclus dans le fichier, ce qui n’est pas une bonne habitude) :\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"fr\"&gt;\n\n&lt;head&gt;\n    &lt;title&gt;Activité 4 : Formulaires &lt;/title&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n&lt;/head&gt;\n\n&lt;body style=\"width: 70%; margin: 0 auto;\"&gt;\n    &lt;h1 style=\"text-align: center;\"&gt; \n        &lt;?php\n        echo \"Bienvenue \" . $_GET['user_id'] . \" !\";\n        ?&gt;\n    &lt;/h1&gt;\n    &lt;h1 style=\"text-align: center;\"&gt;Alors ? Tu as encore oublié ton mot de passe ?&lt;/h1&gt;\n    &lt;h1 style=\"text-align: center;\"&gt;Quelle tête en l'air !&lt;/h1&gt;\n    &lt;?php\n    echo \"&lt;h1 style='text-align: center;'&gt;Bon, je te pardonne pour cette fois&lt;br&gt; et je t'envoie ton mot de passe à l'adresse&lt;br&gt;\". $_GET['user_email'] . \"&lt;/h1&gt;\";\n    ?&gt;\n    &lt;img src=\"elephant-1090828_1280.jpg\" width = \"70%\" alt=\"image ne pas oublier\" style=\"display: block; margin: 0 auto;\"&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\nTester le formulaire, à partir de Capytale : entrer un nom et une adresse e-mail, puis cliquer sur le bouton. Observer ce qu’il se passe.\nObserver l’URL affichée dans la barre d’adresse du navigateur. Que constatez-vous ?\nPour éviter cet affichage dans la barre d’adresse, on utilise plutôt la méthode HTTP POST pour l’envoi de données de formulaires.\nPour cela, modifier l’attribut method dans le fichier index.html :\n&lt;form action=\"https://sitelf.fr/divers/acti4_forms_bis.php\" method=\"post\"&gt;\nOn modifie aussi l’attribut action car le code PHP pour extraire les données transmises par la méthode POST n’est pas exactement le même.\nTester à nouveau cette nouvelle version du formulaire et observer l’URL affiché dans la barre d’adresse.\n\n\n\n\n\n\nRemarque\n\n\n\nEn réalité, la méthode POST n’est pas plus sécurisée que la méthode GET. Certes, les entrées du formulaire ne sont plus affichées dans l’URL, mais elles sont transmises dans le corps de la requête en clair : l’utilisation des outils de développement du navigateur vous le montrera.\nPour une vraie sécurité et empêcher que ces données puissent être interceptées, il faut les crypter et utiliser le protocole sécurisé HTTPS (programme de terminale).",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Activité : Formulaires Web"
    ]
  },
  {
    "objectID": "21_client-serveur/client-serveur_exos.html",
    "href": "21_client-serveur/client-serveur_exos.html",
    "title": "Exercices : le protocole HTTP",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Exercices : le protocole HTTP"
    ]
  },
  {
    "objectID": "21_client-serveur/client-serveur_exos.html#exercice-1-utilisation-des-outils-de-développement-du-navigateur",
    "href": "21_client-serveur/client-serveur_exos.html#exercice-1-utilisation-des-outils-de-développement-du-navigateur",
    "title": "Exercices : le protocole HTTP",
    "section": " Exercice 1 : Utilisation des outils de développement du navigateur",
    "text": "Exercice 1 : Utilisation des outils de développement du navigateur\nAvec un navigateur Web, demander la page d’adresse https://sitelf.fr/divers/mapageweb.html. Ouvrir la fenêtre d’outils de développement en appuyant sur la touche de fonction F12 et sélectionner l’onglet Réseau. On peut voir les entêtes de la requête et de la réponse HTTP. On s’intéresse ici à la requête concernant la page HTML elle-même.\n\nLa requête a-t-elle abouti ? Justifier.\nLa communication est-elle sécurisée ?\nQuelles informations sur le client sont transmises au serveur dans l’entête de la requête ?\nQuelles informations sur le serveur sont transmises au client dans l’entête de la réponse ?\nEffectuer une nouvelle requête avec l’URL https://sitelf.fr/Divers/mapageweb.html. Quel est le code d’état de la réponse ? Explication ?\nEffectuer une nouvelle requête avec l’URL https://sitelf.fr/divers/interdit/. Quel est le code d’état de la réponse ? Explication ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Exercices : le protocole HTTP"
    ]
  },
  {
    "objectID": "21_client-serveur/client-serveur_exos.html#exercice-2-http-et-python",
    "href": "21_client-serveur/client-serveur_exos.html#exercice-2-http-et-python",
    "title": "Exercices : le protocole HTTP",
    "section": " Exercice 2 : HTTP et python",
    "text": "Exercice 2 : HTTP et python\n\n\n\n\n\n\nLe module python requests\n\n\n\nIl est possible d’utiliser Python pour établir une connexion avec un serveur web. On peut pour cela utiliser le module requests (requêtes en anglais). On travaille ci-dessous dans la console Python.\n&gt;&gt;&gt; import requests\n&gt;&gt;&gt; reponse = requests.get(\"http://www.delafond.org/survielinux/\") # envoi d'un requête GET\n&gt;&gt;&gt; reponse  # la connexion est établie correctement (200 signifie OK)\n&lt;Response [200]&gt;\n&gt;&gt;&gt; reponse.request.headers # entête de la requête\n{'User-Agent': 'python-requests/2.28.1', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}\n&gt;&gt;&gt; reponse.headers # l'entête de la réponse du serveur\n{'Date': 'Thu, 03 Nov 2022 21:31:47 GMT', 'Content-Type': 'text/html', 'Transfer-Encoding': 'chunked',\n'Connection': 'keep-alive', 'Last-Modified': 'Sun, 28 Mar 2010 21:22:16 GMT', 'ETag': '\"681c5-482e2fd9d3200-gzip\"',\n'Accept-Ranges': 'bytes', 'Vary': 'Accept-Encoding', 'Content-Encoding': 'gzip', 'server': 'nginx'}\n&gt;&gt;&gt; reponse.content\nb'&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"&gt;\\n&lt;html&gt;\\n&lt;head&gt;\\n  \n&lt;meta http-equiv=\"CONTENT-TYPE\" content=\"text/html; charset=UTF-8\"&gt;\\n  \n&lt;title&gt;Guide de Survie du D\\xc3\\xa9butant sous Linux&lt;/title&gt;\\n  &lt;meta name=\"CREATED\" content=\"19981217;15162800\"&gt;\\n  \n&lt;meta name=\"CHANGEDBY\" content=\"G\\xc3\\xa9rard Delafond\"&gt;\\n  &lt;meta name=\"CHANGED\" content=\"20050528;7341900\"&gt;\\n  \n&lt;style&gt;\\n  &lt;!--\\n@page { size: 21cm 29.7cm }\\n--&gt;\\n\\n  &lt;/style&gt;\\n&lt;/head&gt;\\n\\n&lt;body lang=\"fr-FR\" \nbackground=\"pics/backdrop.png\" dir=\"ltr\"&gt;\\n&lt;p&gt;&lt;br&gt;\\n&lt;br&gt;\\n&lt;/p&gt;\\n\\n&lt;h1&gt;&lt;img src=\"pics/Survie330.jpg\" name=\"Image1\" \nalt=\"Logo_survie\"\\nalign=\"left\" width=\"799\" height=\"280\" border=\"0\"&gt;&lt;br clear=\"left\"&gt;\\nGuide de survie sous Linux:&lt;/h1&gt;\n... # réponse tronquée ...\nOn peut voir que la connexion est bien établie (code 200) entre le client (Python lui-même : User-Agent python) et le serveur (nommé ici nginx) qui héberge le site.\nLe contenu est en HTML, comme on s’y attend\nLa page a été modifiée pour la dernière fois en mars 2010.\nEt tout un tas d’informations moins pertinentes.\nLe contenu de la réponse est le code HTML lui-même. \n\n\n\nReproduire les commandes présentées ci-dessus pour joindre successivement : https://google.com et https://google.com/azeaze.\nComparer les codes réponses obtenus dans les deux cas. Que signifient-ils ? Que peut-on en déduire concernant la page https://google.com/azeaze ?\nMesurez la longueur du contenu de la réponse dans les deux cas. Comment expliquer cette différence ?",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Exercices : le protocole HTTP"
    ]
  },
  {
    "objectID": "21_client-serveur/exos_forms.html",
    "href": "21_client-serveur/exos_forms.html",
    "title": "Exercice : Formulaires",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Exercice : Formulaires"
    ]
  },
  {
    "objectID": "21_client-serveur/exos_forms.html#exercice-qcm",
    "href": "21_client-serveur/exos_forms.html#exercice-qcm",
    "title": "Exercice : Formulaires",
    "section": "Exercice (QCM)",
    "text": "Exercice (QCM)\n\nParmi les réponses suivantes, que permet d’effectuer la méthode POST du protocole HTTP ?\n\nRéponse A : Définir le style d’une page web\nRéponse B : Pirater des données bancaires\nRéponse C : Envoyer une page web vers le client\nRéponse D : Envoyer les données saisies dans un formulaire HTML vers un serveur\n\nUn site internet utilise une requête HTTP avec la méthode POST pour transmettre les données d’un formulaire. Laquelle des affirmations suivantes est incorrecte ?\n\nRéponse A : les données envoyées ne sont pas visibles\nRéponse B : il est possible de transmettre des données de type binaire\nRéponse C : les données transmises sont cryptées\nRéponse D : il n’y a pas de restriction de longueur pour les données transmises\n\nUn internaute clique sur un lien qui envoie la requête HTTP suivante à un serveur : http://jaimelaneige.com/ma_planche/traitement.php?nom=Snow&prenom=Jon Que demande cette requête au serveur ?\n\nRéponse A : de renvoyer le fichier traitement.php en identifiant nom et prénom à Snow et Jon\nRéponse B : d’exécuter le fichier traitement.php en identifiant nom et prénom à Snow et Jon\nRéponse C : d’indiquer si Jon Snow a bien pris son traitement\nRéponse D : de renvoyer le fichier traitement.php en affichant prénom et nom : Jon",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 3 - Web",
      "Exercice : Formulaires"
    ]
  },
  {
    "objectID": "21_client-serveur/index.html",
    "href": "21_client-serveur/index.html",
    "title": "Programme",
    "section": "",
    "text": "Lors de la navigation sur le Web, les internautes interagissent avec leur machine par le biais des pages Web.\nL’Interface Homme-Machine (IHM) repose sur la gestion d’événements associés à des éléments graphiques munis de méthodes algorithmiques.\nLa compréhension du dialogue client-serveur déjà abordé en classe de seconde est consolidée, sur des exemples simples, en identifiant les requêtes du client, les calculs puis les réponses du serveur traitées par le client.\nIl ne s’agit pas de décrire exhaustivement les différents éléments disponibles, ni de développer une expertise dans les langages qui permettent de mettre en œuvre le dialogue tels que PHP ou JavaScript.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nModalités de l’interaction entre l’homme et la machine Événements\nIdentifier les différents composants graphiques permettant d’interagir avec une application Web. Identifier les événements que les fonctions associées aux différents composants graphiques sont capables de traiter.\nIl s’agit d’examiner le code HTML d’une page comprenant des composants graphiques et de distinguer ce qui relève de la description des composants graphiques en HTML de leur comportement (réaction aux événements) programmé par exemple en JavaScript.\n\n\nInteraction avec l’utilisateur dans une page Web\nAnalyser et modifier les méthodes exécutées lors d’un clic sur un bouton d’une page Web.\n\n\n\nInteraction client-serveur. Requêtes HTTP, réponses du serveur\nDistinguer ce qui est exécuté sur le client ou sur le serveur et dans quel ordre. Distinguer ce qui est mémorisé dans le client et retransmis au serveur. Reconnaître quand et pourquoi la transmission est chiffrée.\nIl s’agit de faire le lien avec ce qui a été vu en classe de seconde et d’expliquer comment on peut passer des paramètres à un site grâce au protocole HTTP.\n\n\nFormulaire d’une page Web\nAnalyser le fonctionnement d’un formulaire simple. Distinguer les transmissions de paramètres par les requêtes POST ou GET.\nDiscuter les deux types de requêtes selon le type des valeurs à transmettre et/ou leur confidentialité."
  },
  {
    "objectID": "22_tables/index.html",
    "href": "22_tables/index.html",
    "title": "Programme",
    "section": "",
    "text": "Les données organisées en table correspondent à une liste de p-uplets nommés qui partagent les mêmes descripteurs. La mobilisation de ce type de structure de données permet de préparer les élèves à aborder la notion de base de données qui ne sera présentée qu’en classe terminale. Il s’agit d’utiliser un tableau doublement indexé ou un tableau de p-uplets, dans un langage de programmation ordinaire et non dans un système de gestion de bases de données.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nIndexation de tables\nImporter une table depuis un fichier texte tabulé ou un fichier CSV.\nEst utilisé un tableau doublement indexé ou un tableau de p-uplets qui partagent les mêmes descripteurs.\n\n\nRecherche dans une table\nRechercher les lignes d’une table vérifiant des critères exprimés en logique propositionnelle.\nLa recherche de doublons, les tests de cohérence d’une table sont présentés.\n\n\nTri d’une table\nTrier une table suivant une colonne.\nUne fonction de tri intégrée au système ou à une bibliothèque peut être utilisée.\n\n\nFusion de tables\nConstruire une nouvelle table en combinant les données de deux tables.\nLa notion de domaine de valeurs est mise en évidence."
  },
  {
    "objectID": "22_tables/tables_exos.html",
    "href": "22_tables/tables_exos.html",
    "title": "Exercices - Traitements de données en tables",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices - Traitements de données en tables"
    ]
  },
  {
    "objectID": "22_tables/tables_exos.html#exercice-1",
    "href": "22_tables/tables_exos.html#exercice-1",
    "title": "Exercices - Traitements de données en tables",
    "section": " Exercice 1",
    "text": "Exercice 1\nDans cet exercice, on utilise le fichier CSV listant les établissements scolaires du Cantal déjà rencontré dans le cours (Source : https://www.data.gouv.fr/fr/). Ce fichier utilise l’encodage UTF-8.\nAvertissement : Dans cet exercice, certaines questions nécessitent la comparaison de valeurs numériques alors que les données sont toutes au format chaîne de caractères. Il faut donc penser, si besoin, à convertir les données au format numérique adéquat.\n\nImporter ce fichier dans un programme Python et indexer les données sous la forme d’un tableau de dictionnaires nommé table_educ.\nCombien d’enregistrements contient cette table ?\nOpérations de sélection :\n\nEn utilisant une boucle, écrire des instructions permettant de définir le tableau etab_AURILLAC contenant les enregistrements qui correspondent à des établissement situés à Aurillac.\nEn utilisant une définition de tableau en compréhension, écrire une instruction permettant d’obtenir le tableau contenant les enregistrements de tous les établissements privés du Cantal.\n\nOpérations de projection :\n\nEn utilisant une boucle, écrire des instructions permettant d’obtenir le tableau de tous les codes UAI des établissements du Cantal.\nEn utilisant une définition de tableau en compréhension, écrire une instruction permettant d’obtenir le tableau de tous les noms d’établissements utilisés dans le Cantal.\nOn souhaite obtenir le tableau des noms de communes dans lesquelles existe au moins un établissement scolaire, sans répétition (une commune dans laquelle existent trois établissements ne doit apparaître qu’une fois). Trouver une solution pour ce faire.\n\nOpérations de tri :\n\nTrier les données par ordre croissant de code postaux.\nTrier les données d’Ouest en Est, puis du Nord au Sud.\nTrier les données suivant deux critères : d’abord la commune, puis à l’intérieur de chaque commmune, selin le statut : public en premier, privé en dernier.\n\nOpération de jointure :\n\nImporter le fichier CSV population_Cantal.csv et indexer les données sous la forme d’un tableau de dictionnaires nommé population (Source des données : Insee, Recensement de la population 2019). Ce fichier utilise l’encodage UTF-8.\nAttention: Ouvrir d’abord le fichier dans Notepad ++ et observer le délimiteur utilisé, le nom des attributs, …\nCombien d’enregistrements contient cette table ?\nÉcrire les instructions permettant d’effectuer la jointure entre les tables table_educ et population sous la forme d’une table nommée new_table qui reprend tous les attributs de la table table_educ en ajoutant à chaque enregistrement la population de la commune considérée sous la forme d’un champ nommé “population”.\nEnregistrer les données de la table new_table dans un nouveau fichier CSV nommé exo1_jointure.csv.\nOuvrir ce fichier dans un tableur. Certains enregistrements n’ont pas de valeur pour le champ “population”. Chercher la cause de cette anomalie et essayer de la corriger.\n\n\n\n\n\n\n\n\nÀ retenir\n\n\n\nLorsqu’on rapproche deux tables, il faut toujours veiller à la cohérence des noms des attributs, des formats des données (domaines de valeurs), aux doublons, …\nCela implique souvent un travail préliminaire de formatage des données avant de passer à leur exploitation proprement dite. Ce formatage a été fait pour vous dans cet exercice, sauf pour le petit problème restant qui est apparu dans la dernière question.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices - Traitements de données en tables"
    ]
  },
  {
    "objectID": "22_tables/tables_exos.html#exercice-2",
    "href": "22_tables/tables_exos.html#exercice-2",
    "title": "Exercices - Traitements de données en tables",
    "section": " Exercice 2",
    "text": "Exercice 2\nPour s’entraîner, on reprend le fichier population_Cantal.csv. Pour chaque question, écrire des instructions Python permettant d’y répondre. Vous pourrez dans certains cas proposer plusieurs solutions.\n\nConstruire la table des mêmes données, mais triées par population décroissante.\nFaire le tableau des noms de communes dont le nom complet se termine par “AC”. Combien y en a-t-il ?\nConstruire la table des enregistrements correspondant aux communes dont la population est comprise au sens large entre 1000 et 2000 habitants.\nQuestion ouverte : construire le tableau des noms de communes qui sont composés de plusieurs mots.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 5 - Python avancé",
      "Exercices - Traitements de données en tables"
    ]
  },
  {
    "objectID": "23_reseaux/index.html",
    "href": "23_reseaux/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nTransmission de données dans un réseau. Protocoles de communication. Architecture d’un réseau\nMettre en évidence l’intérêt du découpage des données en paquets et de leur encapsulation. Dérouler le fonctionnement d’un protocole simple de récupération de perte de paquets (bit alterné). Simuler ou mettre en oeuvre un réseau.\nLe protocole peut être expliqué et simulé en mode débranché. Le lien est fait avec ce qui a été vu en classe de seconde sur le protocole TCP/IP. Le rôle des différents constituants du réseau local de l’établissement est présenté."
  },
  {
    "objectID": "23_reseaux/index.html#points-traités-dans-cette-séquence",
    "href": "23_reseaux/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nTransmission de données dans un réseau. Protocoles de communication. Architecture d’un réseau\nMettre en évidence l’intérêt du découpage des données en paquets et de leur encapsulation. Dérouler le fonctionnement d’un protocole simple de récupération de perte de paquets (bit alterné). Simuler ou mettre en oeuvre un réseau.\nLe protocole peut être expliqué et simulé en mode débranché. Le lien est fait avec ce qui a été vu en classe de seconde sur le protocole TCP/IP. Le rôle des différents constituants du réseau local de l’établissement est présenté."
  },
  {
    "objectID": "23_reseaux/reseaux_exos.html",
    "href": "23_reseaux/reseaux_exos.html",
    "title": "TP dans Capytale",
    "section": "",
    "text": "Cliquer sur le lien suivant pour accéder au TP dans Capytale : Accès au TP",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 6 - Réseaux",
      "TP dans Capytale"
    ]
  },
  {
    "objectID": "24_protocoles/protocoles_cours.html",
    "href": "24_protocoles/protocoles_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Les bits transmis d’un ordinateur à un autre contiennent, en plus des données utiles (le mot «bonjour» dans un email), une multitude de données (tout aussi utiles) qui vont aider à l’acheminement de ces bits au bon endroit, puis au bon ordinateur, puis au bon logiciel. Les différents protocoles qui régissent cette transmission sont regroupés dans ce qui est appelé un modèle. Deux modèles synthétisent ces protocoles :\n\nle modèle Internet (ou modèle TCP/IP, 1974), organisé en 4 couches : liaison, réseau, transport, application.\nle modèle OSI (Open Systems Interconnection, 1984), organisé en 7 couches : physique, liaison, réseau, transport, session, présentation,application.\n\nCes deux modèles coïncident suivant le schéma ci-dessus. Ce sont des modèles théoriques. Leur utilisation dans la pratique est parfois plus floue, avec des protocoles à cheval sur plusieurs couches.\nDans la suite de ce cours, nous évoquerons les couches par leur numéro dans le modèle OSI.\n\nLors de son émission, un message va subir successivement toutes les transformations effectuées par chaque couche, depuis sa création (couche 7) jusqu’à sa transmission physique (couche 1).\nLorsque ce même message sera réceptionné, les transformations seront effectuées dans l’ordre inverse, jusqu’à la présentation du message au destinataire.\n\n\ncouches 7-6-5 — couches application-présentation-session : Ces couches (réunies dans le modèle Internet en une couche unique «application» ) regroupent les protocoles nécessaires à la bonne mise en forme d’un message (au sens large) avant sa transmission. Ces protocoles peuvent être de nature très différente : protocole HTTP pour la transmisson de pages web, protocole FTP pour le transfert de fichiers, protocoles POP ou IMAP pour le courrier électronique… \ncouche 4 — couche transport :\nLe protocole majeur de cette couche est le protocole TCP :\n\nil s’assure par SYN-ACK que l’émetteur et le récepteur sont prêts à échanger des messages.\nil découpe en segments numérotés le message à transmettre (côté émetteur) ou bien recompose le message total en remettant les segments dans l’ordre (côté récepteur).\nLes éléments échangés avec la couche inférieure sont des segments. \n\ncouche 3 — couche réseau :\nC’est la couche où chaque segment numéroté est encapsulé dans un paquet qui, suivant le protocole IP, va contenir son adresse source et son adresse de destination. C’est à ce niveau que se décide si le message doit rester dans le réseau local ou être envoyé sur un autre réseau via la passerelle du routeur.\nLes éléments échangés avec la couche inférieure sont des paquets. \ncouche 2 — couche liaison :\nC’est l’encapsulation finale du message. Suivant le protocole Ethernet, les informations sont transmises d’une carte réseau à une autre, grâce à leur adresse MAC (Media Access Controler).\nLes éléments échangés avec la couche inférieure sont des trames. \ncouche 1 — couche physique :\nC’est la couche où le message est transmis physiquement d’un point à un autre. Par signal lumineux (fibre optique), par ondes (wifi), par courant électrique (Ethernet)… Les éléments transmis sont les bits.\n\nLors de son parcours, une trame peut être partiellement décapsulée et remonter à la couche 3, avant de redescendre et de continuer son chemin. C’est le cas notamment lors du passage dans un routeur. Mais jamais, lors de son acheminement, le contenu réel du message n’est ouvert : les paquets transmis sont acheminés de manière identique, qu’ils contiennent les éléments constitutifs d’une vidéo YouTube ou d’un email à votre cousin.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 6 - Réseaux",
      "Cours"
    ]
  },
  {
    "objectID": "24_protocoles/protocoles_cours.html#modèle-osi-modèle-internet",
    "href": "24_protocoles/protocoles_cours.html#modèle-osi-modèle-internet",
    "title": "Cours",
    "section": "",
    "text": "Les bits transmis d’un ordinateur à un autre contiennent, en plus des données utiles (le mot «bonjour» dans un email), une multitude de données (tout aussi utiles) qui vont aider à l’acheminement de ces bits au bon endroit, puis au bon ordinateur, puis au bon logiciel. Les différents protocoles qui régissent cette transmission sont regroupés dans ce qui est appelé un modèle. Deux modèles synthétisent ces protocoles :\n\nle modèle Internet (ou modèle TCP/IP, 1974), organisé en 4 couches : liaison, réseau, transport, application.\nle modèle OSI (Open Systems Interconnection, 1984), organisé en 7 couches : physique, liaison, réseau, transport, session, présentation,application.\n\nCes deux modèles coïncident suivant le schéma ci-dessus. Ce sont des modèles théoriques. Leur utilisation dans la pratique est parfois plus floue, avec des protocoles à cheval sur plusieurs couches.\nDans la suite de ce cours, nous évoquerons les couches par leur numéro dans le modèle OSI.\n\nLors de son émission, un message va subir successivement toutes les transformations effectuées par chaque couche, depuis sa création (couche 7) jusqu’à sa transmission physique (couche 1).\nLorsque ce même message sera réceptionné, les transformations seront effectuées dans l’ordre inverse, jusqu’à la présentation du message au destinataire.\n\n\ncouches 7-6-5 — couches application-présentation-session : Ces couches (réunies dans le modèle Internet en une couche unique «application» ) regroupent les protocoles nécessaires à la bonne mise en forme d’un message (au sens large) avant sa transmission. Ces protocoles peuvent être de nature très différente : protocole HTTP pour la transmisson de pages web, protocole FTP pour le transfert de fichiers, protocoles POP ou IMAP pour le courrier électronique… \ncouche 4 — couche transport :\nLe protocole majeur de cette couche est le protocole TCP :\n\nil s’assure par SYN-ACK que l’émetteur et le récepteur sont prêts à échanger des messages.\nil découpe en segments numérotés le message à transmettre (côté émetteur) ou bien recompose le message total en remettant les segments dans l’ordre (côté récepteur).\nLes éléments échangés avec la couche inférieure sont des segments. \n\ncouche 3 — couche réseau :\nC’est la couche où chaque segment numéroté est encapsulé dans un paquet qui, suivant le protocole IP, va contenir son adresse source et son adresse de destination. C’est à ce niveau que se décide si le message doit rester dans le réseau local ou être envoyé sur un autre réseau via la passerelle du routeur.\nLes éléments échangés avec la couche inférieure sont des paquets. \ncouche 2 — couche liaison :\nC’est l’encapsulation finale du message. Suivant le protocole Ethernet, les informations sont transmises d’une carte réseau à une autre, grâce à leur adresse MAC (Media Access Controler).\nLes éléments échangés avec la couche inférieure sont des trames. \ncouche 1 — couche physique :\nC’est la couche où le message est transmis physiquement d’un point à un autre. Par signal lumineux (fibre optique), par ondes (wifi), par courant électrique (Ethernet)… Les éléments transmis sont les bits.\n\nLors de son parcours, une trame peut être partiellement décapsulée et remonter à la couche 3, avant de redescendre et de continuer son chemin. C’est le cas notamment lors du passage dans un routeur. Mais jamais, lors de son acheminement, le contenu réel du message n’est ouvert : les paquets transmis sont acheminés de manière identique, qu’ils contiennent les éléments constitutifs d’une vidéo YouTube ou d’un email à votre cousin.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 6 - Réseaux",
      "Cours"
    ]
  },
  {
    "objectID": "24_protocoles/protocoles_cours.html#observation-des-trames-avec-filius",
    "href": "24_protocoles/protocoles_cours.html#observation-des-trames-avec-filius",
    "title": "Cours",
    "section": "2. Observation des trames avec Filius",
    "text": "2. Observation des trames avec Filius\n\n2.1. Ping à travers un switch\nVous pouvez télécharger le fichier ping_switch.fls.\n\nRelions une machine 192.168.0.10 d’adresse MAC BC:81:81:42:9C:31 à une machine 192.168.0.11 d’adresse MAC 2A:AB:AC:27:D6:A7 à travers un switch.\n\n\n\nObservons la table SAT de notre switch : elle est vide, car aucune machine n’a encore cherché à communiquer.\n\n\n\nLançons un ping depuis 192.168.0.10 vers 192.168.0.11 et observons les données échangées :\n\n\n\nObservons de plus près la première ligne de données échangées.\n\n\nCette première ligne est une requête ARP. ARP est un protocole qui s’interface entre la couche 3 / réseau (appelée dans la capture d’écran Internet) et la couche 2 / liaison (appelée dans la capture d’écran Réseau). Comme indiqué dans le commentaire, elle consiste à un appel à tout le réseau : “Est-ce que quelqu’un ici possède l’IP 192.168.0.11 ?\nMessage 1 : « Qui possède l’IP 192.168.0.11 ? »\nIl faut comprendre à cette étape que l’adresse IP est totalement inutile pour répérer un ordinateur dans un sous-réseau. Ce sont les adresses MAC qui permettent de se repérer dans un sous-réseau. Les adresses IP, elles, permettront éventuellement d’acheminer le message jusqu’au bon sous-réseau (elles n’intéressent donc que les routeurs).\nRevenons à notre ping vers 192.168.0.11.\nLa commande arp -a effectuée dans un terminal de la machine 192.168.0.10 nous permet de voir qu’elle ne connaît encore personne dans son sous-réseau. La table de correspondance IP ⮀ MAC ne contient que l’adresse de broadcast 255.255.255.255, qui permet d’envoyer un message à tout le réseau.\n\nConstatant qu’elle ne sait pas quelle est l’adresse MAC de 192.168.0.11, la machine 192.168.0.10 commence donc par envoyer un message à tout le sous-réseau, par l’adresse MAC de broadcast FF:FF:FF:FF:FF:FF. Le switch va lui aussi relayer ce message à tous les équipements qui lui sont connectés (dans notre cas, un seul ordinateur).\nMessage 2 : « Moi ! »\nLa machine 192.168.0.11 s’est reconnue dans le message de broadcast de la machine 192.168.0.10. Elle lui répond pour lui donner son adresse MAC.\n\nÀ partir de ce moment, la machine 192.168.0.10 sait comment communiquer avec 192.168.0.11. Elle l’écrit dans sa table arp, afin de ne plus avoir à émettre le message n°1 :\n\nLe switch, qui a vu passer sur ses ports 0 et 1 des messages venant des cartes MAC BC:81:81:42:9C:31 et 2A:AB:AC:27:D6:A7, peut mettre à jour sa table SAT :\n\nPar la suite, il saura sur quel port rediriger les messages destinés à ces deux adresses MAC. Un switch est un équipement de réseau de la couche 2 du modèle OSI, il ne sait pas lire les adresses IP : il ne travaille qu’avec les adresses MAC.\nMessage 3 : le ping est envoyé\n\nSchématisons cette trame Ethernet (couche 2 du modèle OSI) :\n\nMessage 4 : le pong est retourné\n\n\n\n\n2.2. Ping à travers un routeur\nVous pouvez télécharger le fichier ping_routeur.fls.\n\nL’objectif est d’observer les différentes trames lors d’un ping entre :\n\nla machine 192.168.0.1 / 24 (adresse MAC F9:E1:D6:0B:29:03 ) et\nla machine 192.168.1.1 / 24 (adresse MAC D3:79:96:B8:5C:A4 )\n\nLe routeur est configuré ainsi :\n\ninterface sur le réseau A :\n\nIP : 192.168.0.254\nMAC : 77:C2:22:C9:5C:E7\n\ninterface sur le réseau B :\n\nIP : 192.168.1.254\nMAC : 66:E5:4E:7D:0B:B0\n\n\nÉtape 0 : le routeur signale sa présence\nLors de l’observation des messages reçus ou émis par la machine 192.168.0.1, on peut être intrigué par ce tout premier message reçu, émis par le routeur :\n\nOn peut y distinguer les 4 couches du modèle Internet. Le routeur, par ce message distribué à tous les éléments du sous-réseau A (il envoie un message équivalent sur son sous-réseau B), déclare sa présence, et le fait qu’il possède deux interfaces, une pour chaque réseau. Il se positionne ainsi comme une passerelle : «c’est par moi qu’il faudra passer si vous voulez sortir de votre sous-réseau». Dans cette trame envoyée figure son adresse MAC, de sorte que tous les membres de son sous-réseau pourront donc communiquer avec lui.\nÉtape 1 : de 192.168.0.1 vers le routeur\nLa machine 192.168.0.1 / 24 calcule que la machine 192.168.1.1 / 24 avec laquelle elle veut communiquer n’est pas dans son sous-réseau. Elle va donc envoyer son message à sa passerelle, qui est l’adresse du routeur dans son sous-réseau.\nCette première trame est :\n\nÉtape 2 : le routeur décapsule la trame\nLe routeur est un équipement de réseau de couche 3 (couche réseau). Il doit observer le contenu du paquet IP (sans remonter jusqu’au contenu du message) pour savoir, suivant le procédé de routage (voir cours de Terminale), où acheminer ce paquet.\nDans notre cas, l’adresse IP 192.168.1.1de destination lui est accessible : elle fait partie de son sous-réseau B.\nLe routeur va modifier la valeur du TTL (Time To Live), en la décrémentant de 1. Si, après de multiples routages, cette valeur devenait égale à 0, ce paquet serait détruit. Ceci a pour but d’éviter l’encombrement des réseaux avec des paquets ne trouvant pas leur destination.\n\n\n\n\n\n\nNAT : translation d’adresse\n\n\n\nDans notre cas, le routeur va laisser intacte l’adresse IP Source. Ce n’est pas toujours le cas. Dans le cas classique de la box qui relie votre domicile à internet, le routeur contenu dans celle-ci va remplacer l’adresse locale de votre ordinateur ou smartphone (ex 192.168.0.26) par son IP publique (celle apparaissant sur whatsmyip.com, par exemple). Elle effectue ce qu’on appelle une translation d’adresse (NAT).\nPourquoi ? Parce que sinon la réponse du serveur distant que vous interrogez serait envoyée sur une adresse locale (votre adresse 192.168.0.26), qui est introuvable depuis un réseau extérieur. Il faut donc remplacer toutes les adresses locales par l’IP publique de votre box. Pour éviter que la réponse du serveur web que vous avez interrogé ne soit affichée sur l’ordinateur de vos parents, le routeur affecte des ports différents à chaque machine de son sous-réseau. Ce port est inclus dans le message transmis au serveur, et il l’est aussi dans sa réponse : le routeur peut donc rediriger le trafic vers la bonne machine du sous-réseau.\n\n\nLe routeur va ré-encapsuler le paquet IP modifié, et créer une nouvelle trame Ethernet en modifiant :\n\nl’adresse MAC source : il va mettre l’adresse MAC de son interface dans le sous-réseau B.\nl’adresse MAC de destination : il va mettre l’adresse MAC de 192.168.1.1 (qu’il aura peut-être récupérée au préalable par le protocole ARP)\n\nCette deuxième trame est donc :\n\nOn peut observer dans Filius cette trame, en se positionnant sur l’interface 192.168.1.254 du routeur, ou sur 192.168.1.1 :\n\nEn suivant le même principe, la machine 192.168.1.1 pourra envoyer son pong.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 6 - Réseaux",
      "Cours"
    ]
  },
  {
    "objectID": "24_protocoles/protocoles_cours.html#protocole-du-bit-alterné",
    "href": "24_protocoles/protocoles_cours.html#protocole-du-bit-alterné",
    "title": "Cours",
    "section": "3. Protocole du bit alterné",
    "text": "3. Protocole du bit alterné\nCe protocole est un exemple simple de fiabilisation du transfert de données.\n\n1. Contexte\n\nAlice veut envoyer à Bob un message M, qu’elle a prédécoupé en sous-messages M0, M1, M2,…\nAlice envoie ses sous-messages à une cadence Δt fixée.\n\n\n\n2. Situation idéale\n\nDans cette situation, les sous-messages arrivent tous à destination dans le bon ordre. La transmission est correcte.\n\n\n3. Situation réelle\nMais parfois, les choses ne se passent pas toujours aussi bien. Car si on maîtrise parfaitement le timing de l’envoi des sous-messages d’Alice, on ne sait pas combien de temps vont mettre ces sous-messages pour arriver, ni même (attention je vais passer dans un tunnel) s’ils ne vont pas être détruits en route.\n\nLe sous-message M0 est arrivé après le M1, le message M2 n’est jamais arrivé…\nQue faire ?\nÉcartons l’idée de numéroter les sous-messages, afin que Bob puisse remettre dans l’ordre les messages arrivés, ou même redemander spécifiquement des sous-messages perdus. C’est ce que réalise le protocole TCP (couche 4 — transport), c’est très efficace, mais cher en ressources. Essayons de trouver une solution plus basique.\n\n\n3. Solution naïve…\nPourquoi ne pas demander à Bob d’envoyer un signal pour dire à Alice qu’il vient bien de recevoir son sous-message ? Nous appelerons ce signal ACK (comme acknowledgement, traduisible par «accusé de réception»). Ce signal ACK permettra à Alice de renvoyer un message qu’elle considérera comme perdu :\n\nN’ayant pas reçu le ACK consécutif à son message M1, Alice suppose (avec raison) que ce message n’est pas parvenu jusqu’à Bob, et donc renvoie le message M1.\n\n\n4. Mais peu efficace…\n\nLe deuxième ACK de Bob a mis trop de temps pour arriver (ou s’est perdu en route) et donc Alice a supposé que son sous-message M1 n’était pas arrivé. Elle l’a donc renvoyé, et Bob se retrouve avec deux fois le sous-message M1. La transmission est incorrecte. En faisant transiter un message entre Bob et Alice, nous multiplions par 2 la probabilité que des problèmes techniques de transmission interviennent. Et pour l’instant rien ne nous permet de les détecter.\n\n\n5. Bob prend le contrôle\nBob va maintenant intégrer une méthode de validation du sous-message reçu. Il pourra décider de le garder ou de l’écarter. Le but est d’éviter les doublons.\nPour réaliser ceci, Alice va rajouter à chacun de ses sous-messages un bit de contrôle, que nous appelerons FLAG (drapeau). Au départ, ce FLAG vaut 0. Quand Bob reçoit un FLAG, il renvoie un ACK égal au FLAG reçu.\nAlice va attendre ce ACK contenant le même bit que son dernier FLAG envoyé :\n\ntant qu’elle ne l’aura pas reçu, elle continuera à envoyer le même sous-message, avec le même FLAG.\ndès qu’elle l’a reçu, elle peut envoyer un nouveau sous-message en inversant («alternant») le bit de son dernier FLAG (d’où le nom de ce protocole).\n\nBob, de son côté, va contrôler la validité de ce qu’il reçoit : il ne gardera que les sous-messages dont le FLAG est égal à l’inverse de son dernier ACK. C’est cette méthode qui lui permettra d’écarter les doublons.\nObservons ce protocole dans plusieurs cas :\n\n5.1 Cas où le sous-message est perdu\n\n\n\n5.2 Cas où le ACK est perdu\n\nLe protocole a bien détecté le doublon du sous-message M1.\n\n\n5.3 Cas où un sous-message est en retard\n\nLe protocole a bien détecté le doublon du sous-message M1… mais que se passerait-il si notre premier sous-message M1 était encore plus en retard ?\n\n\n\n6. Conclusion\nLe protocole du bit alterné a longtemps été utilisé au sein de la couche 2 du modèle OSI (distribution des trames Ethernet). Simple et léger, il peut toutefois être facilement mis en défaut, ce qui explique qu’il ait été remplacé par des protocoles plus performants.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 6 - Réseaux",
      "Cours"
    ]
  },
  {
    "objectID": "25_kppv/index.html",
    "href": "25_kppv/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nAlgorithme des k plus proches voisins\nÉcrire un algorithme qui prédit la classe d’un élément en fonction de la classe majoritaire de ses k plus proches voisins\nIl s’agit d’un exemple d’algorithme d’apprentissage."
  },
  {
    "objectID": "25_kppv/kppv_cours.html",
    "href": "25_kppv/kppv_cours.html",
    "title": "Présentation",
    "section": "",
    "text": "L’algorithme des k plus proches voisins appartient à la famille des algorithmes d’apprentissage automatique (machine learning). L’idée d’apprentissage automatique ne date pas d’hier, puisque le terme de machine learning a été utilisé pour la première fois par l’informaticien américain Arthur Samuel en 1959. Les algorithmes d’apprentissage automatique ont connu un fort regain d’intérêt au début des années 2000 notamment grâce à la quantité de données disponibles sur internet.\nL’algorithme des k plus proches voisins est un algorithme d’apprentissage supervisé, il est nécessaire d’avoir des données classées. À partir d’un ensemble E de données classées, il sera possible de classer (déterminer la classe) d’une nouvelle donnée (donnée n’appartenant pas à E). L’algorithme des k plus proches voisins est une bonne introduction aux principes des algorithmes d’apprentissage automatique, il est en effet relativement simple à comprendre.\n\n\n\n\n\n\nPrincipe\n\n\n\nL’algorithme des k plus proches voisins est basé sur une idée simple : si une majorité des voisins d’un point sont de la classe C, alors ce point est probablement de la classe C. Pour déterminer la classe d’un point, l’algorithme va donc chercher les k points les plus proches de ce point et déterminer la classe majoritaire parmi ces k points.\nPour cela :\n\nOn dispose d’un jeu de données d’apprentissage (ensemble E) composé de données dont on connaît la classe.\nOn dispose d’une nouvelle donnée dont on souhaite déterminer la classe.\nOn calcule la distance entre la nouvelle donnée et chaque donnée de l’ensemble E.\nOn sélectionne les k données de l’ensemble E les plus proches de la nouvelle donnée.\nOn détermine la classe majoritaire parmi ces k données.\nLa nouvelle donnée est classée dans la classe majoritaire.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Présentation"
    ]
  },
  {
    "objectID": "25_kppv/kppv_cours.html#introduction",
    "href": "25_kppv/kppv_cours.html#introduction",
    "title": "Présentation",
    "section": "",
    "text": "L’algorithme des k plus proches voisins appartient à la famille des algorithmes d’apprentissage automatique (machine learning). L’idée d’apprentissage automatique ne date pas d’hier, puisque le terme de machine learning a été utilisé pour la première fois par l’informaticien américain Arthur Samuel en 1959. Les algorithmes d’apprentissage automatique ont connu un fort regain d’intérêt au début des années 2000 notamment grâce à la quantité de données disponibles sur internet.\nL’algorithme des k plus proches voisins est un algorithme d’apprentissage supervisé, il est nécessaire d’avoir des données classées. À partir d’un ensemble E de données classées, il sera possible de classer (déterminer la classe) d’une nouvelle donnée (donnée n’appartenant pas à E). L’algorithme des k plus proches voisins est une bonne introduction aux principes des algorithmes d’apprentissage automatique, il est en effet relativement simple à comprendre.\n\n\n\n\n\n\nPrincipe\n\n\n\nL’algorithme des k plus proches voisins est basé sur une idée simple : si une majorité des voisins d’un point sont de la classe C, alors ce point est probablement de la classe C. Pour déterminer la classe d’un point, l’algorithme va donc chercher les k points les plus proches de ce point et déterminer la classe majoritaire parmi ces k points.\nPour cela :\n\nOn dispose d’un jeu de données d’apprentissage (ensemble E) composé de données dont on connaît la classe.\nOn dispose d’une nouvelle donnée dont on souhaite déterminer la classe.\nOn calcule la distance entre la nouvelle donnée et chaque donnée de l’ensemble E.\nOn sélectionne les k données de l’ensemble E les plus proches de la nouvelle donnée.\nOn détermine la classe majoritaire parmi ces k données.\nLa nouvelle donnée est classée dans la classe majoritaire.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Présentation"
    ]
  },
  {
    "objectID": "25_kppv/kppv_cours.html#exemple",
    "href": "25_kppv/kppv_cours.html#exemple",
    "title": "Présentation",
    "section": "Exemple",
    "text": "Exemple\nOn cherche à classifier des iris en fonction de la taille de leurs pétales. Le jeu de données suivant (ensemble E) présente 6 fleurs pour lesquelles on connaît la classe.\n\n\n\n\n\n\n\n\n\nNom de la fleur\nClasse\nLongueur du pétale (cm)\nLargeur du pétale (cm)\n\n\n\n\nIris Setosa 1\nSetosa\n1.4\n0.2\n\n\nIris Setosa 2\nSetosa\n1.5\n0.2\n\n\nIris Versicolor 1\nVersicolor\n4.7\n1.4\n\n\nIris Versicolor 2\nVersicolor\n4.3\n1.5\n\n\nIris Virginica 1\nVirginica\n5.5\n2.1\n\n\nIris Virginica 2\nVirginica\n5.6\n2.2\n\n\n\nSur la représentation ci-dessous, on a représenté les iris de la classe Setosa en vert, ceux de la classe Versicolor en bleu et ceux de la classe Virginica en rouge.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Données\nX = np.array([[1.4, 0.2], [1.5, 0.2], [4.7, 1.4], [4.3, 1.5], [5.5, 2.1], [5.6, 2.2]])\ny = np.array([1, 1, 0, 0, 2, 2])\n\n# Représentation avec les couleurs rouge, vert et bleu\nplt.scatter(X[y == 0, 0], X[y == 0, 1], color='red', label='Versicolor')\nplt.scatter(X[y == 1, 0], X[y == 1, 1], color='blue', label='Setosa')\nplt.scatter(X[y == 2, 0], X[y == 2, 1], color='green', label='Virginica')\nplt.xlabel('Longueur du pétale (cm)')\nplt.ylabel('Largeur du pétale (cm)')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nConsidérons maintenant une fleur d’iris “Iris X” dont les pétales ont une longueur de 3,5 cm et une largeur de 0,75 cm. On souhaite déterminer la classe de cette fleur.\nAjoutons le point correspondant à “Iris X” sur le graphique précédent.\n\n\nCode\nplt.scatter(X[y == 0, 0], X[y == 0, 1], color='red', label='Versicolor')\nplt.scatter(X[y == 1, 0], X[y == 1, 1], color='blue', label='Setosa')\nplt.scatter(X[y == 2, 0], X[y == 2, 1], color='green', label='Virginica')\nplt.scatter(3.5, 0.75, color='black', label='Iris X')\nplt.xlabel('Longueur du pétale (cm)')\nplt.ylabel('Largeur du pétale (cm)')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nPour déterminer la classe de “Iris X”, on va calculer la distance entre “Iris X” et chacune des fleurs de l’ensemble E. Nous utilisons ici la distance euclidienne définie par la formule :\n\\[AB=\\sqrt{(x_B-x_A)^2+(y_B-y_A)^2}\\]\npour deux points \\(A\\) et \\(B\\) de coordonnées respectivement \\((x_A, y_A)\\) et \\((x_B, y_B)\\) dans un repère orthonormé du plan.\nOn obtient les résultats suivants :\n\n\n\nNom de la fleur\nDistance à Iris X (cm)\n\n\n\n\nIris Setosa 1\n2.17\n\n\nIris Setosa 2\n2.07\n\n\nIris Versicolor 1\n1.36\n\n\nIris Versicolor 2\n1.10\n\n\nIris Virginica 1\n2.41\n\n\nIris Virginica 2\n2.55\n\n\n\nOn décide de donner au paramètre \\(k\\) la valeur 3. Cela signifie que l’on cherche les 3 points les plus proches de “Iris X” et on détermine la classe majoritaire parmi ces 3 points.\nD’après le tableau ci-dessus, les trois fleurs les plus proches de “Iris X” sont “Iris Versicolor 2”, “Iris Versicolor 1” et “Iris Setosa 2”. On détermine donc que “Iris X” est de la classe Versicolor.\nRemarque : en réalité, le nombre d’élément de l’ensemble E doit être le plus grand possible pour que l’algorithme soit efficace.\n\n\n\n\n\n\nImportant\n\n\n\nDeux points importants influent sur le résultat de l’algorithme :\n\nLe choix de la distance entre les points : la distance euclidienne n’est pas toujours la meilleure distance possible. Il est parfois préférable d’utiliser d’autres distances. On utilise parfois la distance Manhattan, définie par : \\[AB=|x_B-x_A|+|y_B-y_A|\\]\nLe choix du nombre de voisins : le nombre de voisins \\(k\\) doit être suffisamment grand, mais pas trop, pour que l’algorithme soit efficace. En général, on choisit une valeur impaire pour éviter les cas d’égalité.\n\n\n\nExercice : les pétales d’un iris ont une longueur de 2,5 cm et une largeur de 1,25 cm. Déterminer la classe de cette fleur.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Présentation"
    ]
  },
  {
    "objectID": "26_gloutons/exos_gloutons.html",
    "href": "26_gloutons/exos_gloutons.html",
    "title": "Exercice 1 : problème du rendu de monnaie",
    "section": "",
    "text": "!!! info le problème Un achat en espèces se traduit par un échange de pièces et de billets. Dans la zone euro, le système en vigueur, en mettant de côté les centimes d’euros, met à disposition des pièces ou billets de 1 €, 2 €, 5 €, 10 €, 20 €, 50 €, 100 €, 200 €, 500 €. Le problème du rendu de monnaie s’énonce alors de la façon suivante : en supposant que nous avons à notre disposition un nombre illimité de ces pièces ou billets, comment rendre une somme donnée de façon optimale, c’est-à-dire avec le nombre minimal de pièces ou billets ? !!!\nQuestion 1 : Supposons que la somme à rendre est de 7 €. Faire la liste de toutes les façons de rendre une telle somme. Quelle est la façon optimale ?\nSans s’en rendre compte, tout individu met généralement en œuvre un algorithme glouton. Il choisit d’abord la pièce ou le billet de valeur maximale qu’il peut rendre, sans rendre trop évidemment ! Puis il réitère cela tant qu’il reste quelque chose à rendre.\nQuestion 2 : Appliquer cette méthode pour déterminer la façon optimale de rendre 463 €.\nPour mettre en œuvre cet algorithme glouton en Python, on définit tout d’abord le système de monnaie via une liste contenant les valeurs des pièces et billets du système par valeurs décroissantes. Pour le système européen, on écrit par exemple l’instruction suivante.\n\nsysteme_monnaie_europeen = [500,200,100,50,20,10,5,2,1]\n\nOn utilise également une variable de type entier somme_a_rendre initialement égale à la somme à rendre.\nL’algorithme consiste alors à parcourir la liste précédente de gauche à droite. Pour chaque élément de cette liste, on vérifie qu’il est bien plus petit que la somme à rendre, auquel cas on le soustrait de la somme à rendre et on le stocke dans la liste des pièces et billets à rendre, sinon on passe à l’élément suivant. On s’arrête enfin lorsque la somme à rendre est égale à zéro.\nNous mettons l’ensemble du code dans une fonction qui prend pour arguments la somme à rendre et le système de monnaie, puis renvoie la liste des pièces ou billets à rendre.\n\ndef rendu(somme_a_rendre, systeme_monnaie):\n    liste_pieces = [] # liste des pièces à rendre\n    i = 0 # indice de la pièce à rendre dans la liste systeme_monnaie\n    while somme_a_rendre &gt; 0: # tant qu'il reste quelque chose à rendre\n        valeur = systeme_monnaie[i] # valeur de la pièce à rendre\n        if valeur &gt; somme_a_rendre: # la pièce a une valeur trop élevée\n            i += 1 # on avance alors dans la liste\n        else: # la pièce peut être rendue\n            ... # on ajoute la pièce dans la liste des pièces à rendre\n            ... # on met à jour la somme à rendre\n    return liste_pieces\n\nQuestion 3 : Compléter les deux lignes en pointillés du code précédent, puis exécuter les cellules ci-dessous pour tester le code.\n\nrendu(7,systeme_monnaie_europeen)\n\n\nrendu(463,systeme_monnaie_europeen)\n\n\nExercice 2 : Problème du sac à dos\nOn dispose d’objets ayant chacun une masse et une valeur en euros, et d’un sac ne pouvant supporter plus d’une certaine masse. Il s’agit alors de remplir le sac en maximisant la valeur totale des objets et sans dépasser la masse maximale. Ce problème, malgré sa simplicité, est un problème majeur d’optimisation.\nSupposons que l’on dispose d’un sac de contenance maximale 30 kg et quatre objets A, B, C et D dont les caractéristiques sont les suivantes :\n\n\n\nObjet\nA\nB\nC\nD\n\n\n\n\nMasse\n13 kg\n12 kg\n8 kg\n10 kg\n\n\nValeur\n70 €\n40 €\n30 €\n30 €\n\n\n\nQuestion 4 : Calculer ci-dessous la liste des rapports Valeurs/Masse \\(\\frac{v_i}{m_i}\\), appelés efficacité de chaque objet. L’algorithme glouton que nous proposons consiste alors à classer les objets dans l’ordre décroissant de leur efficacité. On remplit ensuite le sac en prenant les objets un à un dans cet ordre, tant que le sac peut encore les contenir. Déterminer la combinaison d’objets fournie par cet algorithme. Quel est la valeur totale de cette combinaison ?\nPour mettre en œuvre l’algorithme glouton que nous venons d’étudier pour le problème du sac à dos, nous créons tout d’abord une variable Max contenant la capacité maximale (en kilogrammes) du sac. Nous créons ensuite trois listes liste_noms, liste_masses et liste_valeurs qui contiennent respectivement les noms, masses et valeurs de chacun des objets.\nConsidérons un sac de contenance maximale 10 kg et des objets dont les caractéristiques sont les suivantes :\n\n\n\nObjet\nA\nB\nC\nD\nE\nF\n\n\n\n\nMasse\n7 kg\n6 kg\n4 kg\n3 kg\n2 kg\n1 kg\n\n\nValeur\n9100 €\n6000 €\n4800 €\n2700 €\n2800 €\n200 e\n\n\n\nNous écrivons alors les instructions suivantes :\n\nMax = 10 # contenance maximale du sac\nliste_noms = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"] # liste des noms des objets\nliste_masses = [7,6,4,3,2,1] # liste des masses des objets\nliste_valeurs = [9100,6000,4800,2700,2800,200] # liste des valeurs des objets\n\nQuestion 5 : Créer une liste L dont le i-ème élément est une liste contenant l’efficacité du i-ème élément, son nom, sa masse et sa valeur. Vérifier que L contient bien ce que l’on veut.\nQuestion 6 : Exécuter la cellule ci-dessous pour trier la liste de l’objet le plus “efficace” à l’objet le moins “efficace”.\n\nL_triee=sorted(L,reverse=True)\n\nQuestion 7 : Le code ci-dessous met en œuvre l’algorithme glouton. Compléter les lignes en pointillés.\n\nliste_objets = [] # liste des noms des objets rangés dans le sac\nSomme_masses = 0 # somme des masses des objets déjà rangés\nfor i in range(len(L_triee)):\n    if Max &gt;= ... : # l'objet d'indice i peut être rangé\n        liste_objets.append(...) # on range l'objet d'indice i\n        Somme_masses += ... # on met à jour la somme des masses\n\nQuestion 8: : En déduire la combinaison fournie par l’algorithme glouton et la masse totale de cette combinaison.\nQuestion 9 : Modifier le code précédent afin de déterminer également la valeur totale de la combinaison trouvée."
  },
  {
    "objectID": "26_gloutons/gloutons_cours.html",
    "href": "26_gloutons/gloutons_cours.html",
    "title": "Cours",
    "section": "",
    "text": "Une chenille mangeuse de pucerons se déplace sur l’arbre ci-dessous, du haut vers le bas uniquement. Les nombres sur l’arbre indiquent le nombre de pucerons présents à chaque nœud. La chenille mange tous les pucerons qu’elle rencontre le long de son chemin. Le but de la chenille est évidemment de manger un maximum de pucerons.\n\nOn voit facilement que pour manger le maximum de pucerons, la chenille doit suivre le chemin \\(3 \\rightarrow 4 \\rightarrow 20\\) qui lui permet de manger 27 pucerons. Ce résultat est l’optimum global du problème.\nCependant, la chenille est trop gloutonne, et elle n’a pas une vision globale de l’arbre. Elle choisit donc à chaque étape le nœud présentant le plus grand nombre de pucerons. Ce nombre est ce que l’on appelle l’optimum local pour cette étape. Avec cette méthode, la chenille va suivre le chemin : \\(3 \\rightarrow 7 \\rightarrow 11\\) qui lui permet de manger 21 pucerons. Cela ne correspond pas à l’optimum global du problème.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "26_gloutons/gloutons_cours.html#problème-du-rendu-de-monnaie",
    "href": "26_gloutons/gloutons_cours.html#problème-du-rendu-de-monnaie",
    "title": "Cours",
    "section": "3.1. Problème du rendu de monnaie",
    "text": "3.1. Problème du rendu de monnaie\n\nÉnoncé\nOn dispose de pièces de monnaie de valeurs 1, 2, 5, 10, 20, 50, 100, 200 et 500. On souhaite rendre une somme \\(S\\) en utilisant le moins de pièces possible.\n\n\nAlgorithme glouton\nPour rendre la somme \\(S\\), on commence par rendre la plus grande pièce possible, puis on continue avec la pièce de valeur la plus grande possible, et ainsi de suite.\n\n\nExemple\nRendre la somme \\(S = 93\\).\n\nOn rend la pièce de 50.\nIl reste à rendre \\(93 - 50 = 43\\).\nOn rend la pièce de 20.\nIl reste à rendre \\(43 - 20 = 23\\).\nOn rend la pièce de 20.\nIl reste à rendre \\(23 - 20 = 3\\).\nOn rend la pièce de 2.\nIl reste à rendre \\(3 - 2 = 1\\).\nOn rend la pièce de 1.\n\nOn a donc rendu 5 pièces. On peut vérifier que cette solution est optimale.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "26_gloutons/gloutons_cours.html#problème-du-sac-à-dos",
    "href": "26_gloutons/gloutons_cours.html#problème-du-sac-à-dos",
    "title": "Cours",
    "section": "3.2. Problème du sac à dos",
    "text": "3.2. Problème du sac à dos\n\nÉnoncé\nOn dispose d’un sac à dos pouvant contenir une masse maximale \\(M\\). On dispose de \\(n\\) objets, chacun ayant un poids \\(p_i\\) et une valeur \\(v_i\\). On souhaite remplir le sac à dos de manière à maximiser la valeur totale des objets contenus, sans dépasser la masse maximale \\(M\\).\n\n\nAlgorithme glouton\nOn commence par trier les objets par ordre décroissant de leur rapport \\(\\frac{v_i}{p_i}\\). On remplit ensuite le sac à dos avec les objets dans cet ordre, en prenant le maximum possible de chaque objet.\n\n\nExemple\nOn dispose de 4 objets :\n\nObjet 1 : \\(p_1 = 2\\), \\(v_1 = 10\\)\nObjet 2 : \\(p_2 = 3\\), \\(v_2 = 5\\)\nObjet 3 : \\(p_3 = 4\\), \\(v_3 = 1\\)\nObjet 4 : \\(p_4 = 1\\), \\(v_4 = 2\\)\n\nOn dispose d’un sac à dos pouvant contenir une masse maximale de 5.\n\nOn calcule les rapports \\(\\frac{v_i}{p_i}\\) :\n\nObjet 1 : \\(\\frac{10}{2} = 5\\)\nObjet 2 : \\(\\frac{5}{3} \\approx 1.67\\)\nObjet 3 : \\(\\frac{1}{4} = 0.25\\)\nObjet 4 : \\(\\frac{2}{1} = 2\\)\n\nOn trie les objets par ordre décroissant de leur rapport :\n\nObjet 1 : \\(\\frac{10}{2} = 5\\)\nObjet 4 : \\(\\frac{2}{1} = 2\\)\nObjet 2 : \\(\\frac{5}{3} \\approx 1.67\\)\nObjet 3 : \\(\\frac{1}{4} = 0.25\\)\n\nOn remplit le sac à dos :\n\nOn prend l’objet 1.\nIl reste à remplir \\(5 - 2 = 3\\).\nOn prend l’objet 4.\nIl reste à remplir \\(3 - 1 = 2\\).\nOn ne peut pas prendre l’objet 2 car son poids est trop grand.\nOn ne peut pas prendre l’objet 3 car son poids est trop grand.\n\n\nOn a donc rempli le sac à dos avec les objets 1 et 4, pour une valeur totale de 12. Cette solution n’est pas optimale.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 7 - Algorithmes",
      "Cours"
    ]
  },
  {
    "objectID": "26_gloutons/index.html",
    "href": "26_gloutons/index.html",
    "title": "Programme",
    "section": "",
    "text": "Algorithmique\nLe concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nAlgorithmes gloutons\nRésoudre un problème grâce à un algorithme glouton\nExemples : problèmes du sac à dos ou du rendu de monnaie. Les algorithmes gloutons constituent une méthode algorithmique parmi d’autres qui seront vues en terminale"
  },
  {
    "objectID": "27_ihm/ihm_exos.html",
    "href": "27_ihm/ihm_exos.html",
    "title": "Activités",
    "section": "",
    "text": "Pour s’initier à la programmation d’interfaces homme-machine et des objets connectés, nous allons utiliser les parcours Quick-pi mis en place par l’association France-IOI. Cliquer sur l’image ci-dessous pour y accéder.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 8 - Interfaces homme-machine et robotique",
      "Activités"
    ]
  },
  {
    "objectID": "27_ihm/ihm_exos.html#parcours-quick-pi",
    "href": "27_ihm/ihm_exos.html#parcours-quick-pi",
    "title": "Activités",
    "section": "",
    "text": "Pour s’initier à la programmation d’interfaces homme-machine et des objets connectés, nous allons utiliser les parcours Quick-pi mis en place par l’association France-IOI. Cliquer sur l’image ci-dessous pour y accéder.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 8 - Interfaces homme-machine et robotique",
      "Activités"
    ]
  },
  {
    "objectID": "27_ihm/out.html",
    "href": "27_ihm/out.html",
    "title": "Systèmes embarqués",
    "section": "",
    "text": "Un système informatique embarqué est un système de traitement de l’information autonome ne possédant pas d’entrée et sortie standard comme le clavier et l’écran. Les informations sont reçues de l’extérieur par le biais de capteurs, elles sont traités par un processeur et selon le programme du système des actions physiques peuvent être déclenchées avec des actionneurs. Les capteurs sont des périphériques d’entrée et les actionneurs des périphériques de sortie.\n\nLes signaux capturés sont analogiques, analogues au phénomène : par exemple la rotation de l’axe d’un anémomètre qui mesure la vitesse du vent sur une station météo. Pour être traités par le processeur, ils sont numérisés transformés en un nombre fini d’informations codées par des 0 et des 1 par échantillonnage (nombre fini de relevés) et quantification (nombre fini de valeurs possibles).\nLes microcontrôleurs sont des circuits intégrés qui concentrent une mémoire, un processeur, des entrées-sorties comme un ordinateur mais se caractérisent par une miniaturisation accrue, une plus faible consommation électrique et des performances moindres, mais suffisantes pour des applications toujours plus nombreuses avec les progrès techniques.\nLes systèmes informatiques embarqués sont utilisés dans tous les domaines : l’industrie (robots), le transport (avionique, automobile, métro …), la médecine (pacemakers, imagerie …), la maison (domotique, appareils ménagers …), les télécommunications (téléphonie …), le monde du travail (contrôle d’accès …), les loisirs (vélo électrique …).\nOn parle d’informatique ubiquitaire pour désigner cette omniprésence de l’informatique dans notre environnement.\nLes ordiphones modernes ne sont pas des microcontrôleurs mais des ordinateurs miniatures bien plus puissants que les systèmes de guidage des premières missions Apollo qui ont amené l’homme sur la lune ! Ils sont dotés de nombreux capteurs.\n\n\n\n\nimage\n\n\nSource : flickr / Intel Free Press\n\n\n\n\n\n\n\n\nimage\n\n\nSource : Yassine Haddab Université de Montpellier\n\n\nUn algorithme de contrôle fréquent sur un système informatique embarqué consiste en une boucle infinie où s’enchaînent capture d’événements par les émetteurs, traitement puis action par les actionneurs.\nInitialiser les actionneurs à leur position de départ\nTant que Vrai \n    Lire les informations des capteurs\n    Traiter ces informations\n    Calculer des informations sur les actionneurs\n    Transmettre ces informations aux actionneurs\n\n\n\n\n\nPour chaque question, sélectionner l’unique réponse correcte.\n\nIdentifier parmi les éléments suivants celui qui n’est pas un capteur.\n\n2\n\nhaut-parleur\ncaméra\naccéléromètre\nmicrophone\n\n\nParmi les éléments suivants, lequel est un capteur ?\n\n2\n\nun bouton poussoir\nun moteur\nune diode électroluminescente\nun afficheur à cristaux liquides\n\n\nOn réalise une petite station météo.\nQuel composant est un capteur ?\n\n2\n\nl’afficheur LCD\nl’écran de l’ordinateur\nla LED\nle thermomètre\n\n\nParmi les dispositifs d’entrée et de sortie suivants, lequel est uniquement un capteur ?\n\n2\n\nla diode\nl’écran tactile\nle thermomètre\nle moteur pas à pas"
  },
  {
    "objectID": "27_ihm/out.html#architecture",
    "href": "27_ihm/out.html#architecture",
    "title": "Systèmes embarqués",
    "section": "",
    "text": "Un système informatique embarqué est un système de traitement de l’information autonome ne possédant pas d’entrée et sortie standard comme le clavier et l’écran. Les informations sont reçues de l’extérieur par le biais de capteurs, elles sont traités par un processeur et selon le programme du système des actions physiques peuvent être déclenchées avec des actionneurs. Les capteurs sont des périphériques d’entrée et les actionneurs des périphériques de sortie.\n\nLes signaux capturés sont analogiques, analogues au phénomène : par exemple la rotation de l’axe d’un anémomètre qui mesure la vitesse du vent sur une station météo. Pour être traités par le processeur, ils sont numérisés transformés en un nombre fini d’informations codées par des 0 et des 1 par échantillonnage (nombre fini de relevés) et quantification (nombre fini de valeurs possibles).\nLes microcontrôleurs sont des circuits intégrés qui concentrent une mémoire, un processeur, des entrées-sorties comme un ordinateur mais se caractérisent par une miniaturisation accrue, une plus faible consommation électrique et des performances moindres, mais suffisantes pour des applications toujours plus nombreuses avec les progrès techniques.\nLes systèmes informatiques embarqués sont utilisés dans tous les domaines : l’industrie (robots), le transport (avionique, automobile, métro …), la médecine (pacemakers, imagerie …), la maison (domotique, appareils ménagers …), les télécommunications (téléphonie …), le monde du travail (contrôle d’accès …), les loisirs (vélo électrique …).\nOn parle d’informatique ubiquitaire pour désigner cette omniprésence de l’informatique dans notre environnement.\nLes ordiphones modernes ne sont pas des microcontrôleurs mais des ordinateurs miniatures bien plus puissants que les systèmes de guidage des premières missions Apollo qui ont amené l’homme sur la lune ! Ils sont dotés de nombreux capteurs.\n\n\n\n\nimage\n\n\nSource : flickr / Intel Free Press"
  },
  {
    "objectID": "27_ihm/out.html#programmation",
    "href": "27_ihm/out.html#programmation",
    "title": "Systèmes embarqués",
    "section": "",
    "text": "image\n\n\nSource : Yassine Haddab Université de Montpellier\n\n\nUn algorithme de contrôle fréquent sur un système informatique embarqué consiste en une boucle infinie où s’enchaînent capture d’événements par les émetteurs, traitement puis action par les actionneurs.\nInitialiser les actionneurs à leur position de départ\nTant que Vrai \n    Lire les informations des capteurs\n    Traiter ces informations\n    Calculer des informations sur les actionneurs\n    Transmettre ces informations aux actionneurs"
  },
  {
    "objectID": "27_ihm/out.html#qcm-type-e3c2",
    "href": "27_ihm/out.html#qcm-type-e3c2",
    "title": "Systèmes embarqués",
    "section": "",
    "text": "Pour chaque question, sélectionner l’unique réponse correcte.\n\nIdentifier parmi les éléments suivants celui qui n’est pas un capteur.\n\n2\n\nhaut-parleur\ncaméra\naccéléromètre\nmicrophone\n\n\nParmi les éléments suivants, lequel est un capteur ?\n\n2\n\nun bouton poussoir\nun moteur\nune diode électroluminescente\nun afficheur à cristaux liquides\n\n\nOn réalise une petite station météo.\nQuel composant est un capteur ?\n\n2\n\nl’afficheur LCD\nl’écran de l’ordinateur\nla LED\nle thermomètre\n\n\nParmi les dispositifs d’entrée et de sortie suivants, lequel est uniquement un capteur ?\n\n2\n\nla diode\nl’écran tactile\nle thermomètre\nle moteur pas à pas"
  },
  {
    "objectID": "27_ihm/out.html#fiabilité-et-sécurité",
    "href": "27_ihm/out.html#fiabilité-et-sécurité",
    "title": "Systèmes embarqués",
    "section": "Fiabilité et sécurité",
    "text": "Fiabilité et sécurité\n\nLa sûreté est la garantie qu’un système fait ce qu’il doit faire et ne fait pas ce qu’il ne doit pas faire. Les programmes des systèmes embarqués doivent parfois s’exécuter avec des contraintes fortes (manque de ressource, temps de réaction très rapide) et ils ne sont pas toujours développés avec la rigueur nécessaire. Les bugs sont donc fréquents. Parfois bénins (une mauvaise gestion des années bissextiles a provoqué l’arrêt du lecteur MP3 Zune de Microsoft le 31/12/2008, ils peuvent avoir a des conséquences dramatiques : les bugs du Therac 25 (appareil de radiographie) ou du contrôle moteur sur les Toyota Camry ont provoqué plusieurs morts.\nLa confidentialité est une problématique majeure des systèmes embarqués qui collectent des données personnelles sur leurs utilisateurs, comme par exemple les cartes électroniques de transport comme le pass Navigoo ou la carte Técély.\nLa sécurité est souvent un point faible des systèmes embarqués, qui manquent de ressources matérielles, ont des cycles de vie long sans mise à jour et mettent en jeu des modes de communication sans contact particulièrement vulnérables.\nPar exemple, une voiture ne peut démarrer que si la carte de démarrage se trouve à proximité car la carte et la voiture partagent un secret commun permettant de déverrouiller le système antidémarrage. L’attaque par relais permet de déjouer ce protocole en relayant la communication : un pirate se trouve près de la voiture et l’autre près de la carte et par un leurre technologique ils font croire aux deux parties qu’elles sont à proximité. Tous les systèmes embarqués qui communiquent sans contact (carte bancaire, carte d’accès …) sont vulnérables à cette attaque.\n\n\n\n\nimage\n\n\nSource : Image : Martial Régereau [CC BY-SA 3.0], via Wikimedia Commons"
  },
  {
    "objectID": "27_ihm/out.html#qcm-type-e3c2-1",
    "href": "27_ihm/out.html#qcm-type-e3c2-1",
    "title": "Systèmes embarqués",
    "section": "QCM type E3C2",
    "text": "QCM type E3C2\n\nPour chaque question, sélectionner l’unique réponse correcte.\n\nLequel de ces objets n’est pas un périphérique ?\n\n2\n\nle clavier\nune clé USB\nla carte graphique\nla carte mère\n\n\nLequel de ces périphériques n’est pas un périphérique d’entrée ?\n\n2\n\nle moniteur\nle clavier\nla souris\nle scanner"
  },
  {
    "objectID": "27_ihm/out.html#internet-des-objets",
    "href": "27_ihm/out.html#internet-des-objets",
    "title": "Systèmes embarqués",
    "section": "Internet des objets",
    "text": "Internet des objets\n\nUn objet connecté est un système informatique embarqué disposant d’une connexion à un réseau local ou à L’Internet.\nLes Interfaces Homme Machine des objets connectés sont souvent des applications Web disponibles sur Smartphone.\n\n\n\n\n\nimage\n\n\nSource : Yassine Haddab Université de Montpellier\n\nAvec la baisse des coûts des microcontrôleurs et des puces Wifi, les objets connectés se multiplient. On peut en fabriquer facilement à partir de cartes Arduino, de Raspberry Pi ou de cartes Wifi ESP8266. Actuellement, il existe plus d’objets que d’humains connectés à Internet et leur nombre va augmenter fortement dans les prochaines années avec la baisse de coût des . On parle d’IOT pour Internet Of Things pour désigner l’ensemble des objets connectés à l’Internet.\nOn estime à 50 milliards le nombre d’objets connectés en 2020."
  },
  {
    "objectID": "27_ihm/out.html#fiabilité-et-sécurité-1",
    "href": "27_ihm/out.html#fiabilité-et-sécurité-1",
    "title": "Systèmes embarqués",
    "section": "Fiabilité et sécurité",
    "text": "Fiabilité et sécurité\nLes objets connectés permettent d’ajouter de l’intelligence dans notre environnement à tous les niveaux : le corps (mes indicateurs de santé, ma nourriture), la maison(appareils, système de chauffage), les réseaux (électrique, de circulation), les transports (véhicules autonomes), la prévention des risques (incendies) …De plus la collaboration entre objets connectés, leur connexion à des bases de données en ligne, augmente considérablement leur puissance même si chaque objet a des ressources matérielles limitées.\nNéanmoins les vulnérabilités des systèmes embarqués sont amplifiées s’ils sont connectés.\nLa cyberattaque d’un serveur DNS majeur par des milliers de caméras de surveillance transformées en bots, a gravement perturbé Internet en Octobre 2016. La prise de contrôle à distance par des hackers de la Jeep Cherokee en 2015 ou des failles détectées dans des pacemakers sont des exemples parmi bien d’autres illustrant le fait que la révolution de l’internet des objets ne pourra se faire sans des progrès sur le plan de leur sécurité.\nEnfin la moisson de données personnelles que peuvent collecter des objets connectés comme les assistants personnels proposés par les GAFAM doit absolument être contrôlée."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spécialité NSI - Première",
    "section": "",
    "text": "Bienvenue !\nCe site est destiné à regrouper les cours et les exercices concernant l’enseignement de spécialité NSI de première du lycée Émile Duclaux d’Aurillac.\nLien vers l’ENT du lycée : https://cas.ent.auvergnerhonealpes.fr/login\nLien vers Capytale : https://capytale2.ac-paris.fr/web/c-auth/list\nLien vers Replit : https://replit.com/team/premiere-nsi\nLien vers le programme officiel : Programme officiel première NSI"
  },
  {
    "objectID": "02_python/python_bool.html#introduction",
    "href": "02_python/python_bool.html#introduction",
    "title": "Zoom sur les booléens",
    "section": "",
    "text": "Pour l’instant, nous avons vu deux grands types de données : les nombres (entier ou flottant) et les chaînes de caractères, il existe un troisième type tout aussi important que les deux premiers : les booléens. Un booléen est un type de données qui ne peut prendre que deux valeurs : vrai (True) ou faux (False). Une expression est soit True, soit False.\nLes opérateurs de comparaison renvoient des booléens.\n\n\n\n\n\n\nOpérateurs de comparaison\n\n\n\n\na == 0 : teste si a est égal à 0 ;\na != 0 : teste si a est différent de 0 ;\na &lt; 0 : teste si a est strictement inférieur à 0 ;\na &gt; 0 : teste si a est strictement supérieur à 0 ;\na &lt;= 0 : teste si a est inférieur ou égal à 0 ;\na &gt;= 0 : teste si a est supérieur ou égal à 0.\n\n\n\n\n\n\n\n\n\nATTENTION\n\n\n\nNotez le double égal == qui permet de distinguer un test d’égalité d’une affectation (association d’une valeur à un nom (variable)). Le fait de confondre le “simple égal” et le “double égal” est une erreur classique qu’il faut éviter.\n\n\nEn programmation informatique, un booléen est un type de variable à deux états (généralement notés vrai et faux), destiné à représenter les valeurs de vérité de la logique et l’algèbre booléenne. Il est nommé ainsi d’après George Boole (1815-1864), fondateur dans le milieu du XIXe siècle de l’algèbre portant son nom.\nNous avons vu qu’en Python, les deux valeurs booléennes sont notées True et False.\nDe manière équivalente, on adopte souvent une notation numérique en associant 1 à True et 0 à False.",
    "crumbs": [
      "{{< fa house-chimney-window >}} Accueil",
      "Ch. 1 - Python : les bases",
      "Zoom sur les booléens"
    ]
  }
]
[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "algo1/generalites.html",
    "href": "algo1/generalites.html",
    "title": "Notions de base (Cours)",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème."
  },
  {
    "objectID": "algo1/generalites.html#introduction",
    "href": "algo1/generalites.html#introduction",
    "title": "Notions de base (Cours)",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème."
  },
  {
    "objectID": "algo1/generalites.html#terminaison-dun-algorithme",
    "href": "algo1/generalites.html#terminaison-dun-algorithme",
    "title": "Notions de base (Cours)",
    "section": "2. Terminaison d’un algorithme",
    "text": "2. Terminaison d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la terminaison d’un algorithme, c’est prouver que l’algorithme se termine dans tous les cas. C’est notamment très important lorsque l’algorithme comporte des boucles conditionnelles.\n\n\nPrenons comme exemple l’algorithme suivant qui calcule la puissance entière d’un nombre :\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nComment justifier que cet algorithme se termine dans tous les cas ? Cela revient à montrer que la boucle conditionnelle while compteur &lt; n se termine après un nombre fini d’itérations. Pour cela, on utilise un variant de boucle : c’est une valeur qui évolue à chaque itération de la boucle et qui permet de prouver que celle-ci se termine.\nDans notre exemple, on peut choisir comme variant de boucle la valeur de la variable \\(compteur\\). En effet, cette variable est initialisée à 0 et est incrémentée de 1 à chaque itération. Après \\(n\\) itérations, la condition de sortie de boucle sera donc vraie et la boucle se terminera.\nLa terminaison de l’algorithme est donc démontrée."
  },
  {
    "objectID": "algo1/generalites.html#correction-dun-algorithme",
    "href": "algo1/generalites.html#correction-dun-algorithme",
    "title": "Notions de base (Cours)",
    "section": "3. Correction d’un algorithme",
    "text": "3. Correction d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la correction d’un algorithme, c’est prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\n\n\nConsidérons à nouveau l’algorithme de calcul de puissance entière. Comment prouver que cet algorithme calcule bien la puissance entière d’un nombre ?\nOn utilise pour cela un invariant de boucle : c’est une propriété qui est vraie avant et après chaque itération de la boucle, et qui doit permettre de prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\nDans notre exemple de calcul de puissance entière, on peut choisir comme invariant de boucle la propriété suivante : \\[p=x^{compteur}\\]\n\n\n\n\n\n\nPour prouver q’une propriété est un invariant de boucle…\n\n\n\nIl faut démontrer :\n\nInitialisation : la propriété est vraie avant le premier passage dans la boucle\nConservation : si la propriété est vraie avant une itération, alors elle sera aussi vraie après cette itération.\nConclusion : une fois la boucle terminée, la propriété est vraie.\n\n\n\nCette méthode de raisonnement est appelée raisonnement par récurrence et est très utilisée en mathématiques (au programme en spécialité mathématiques de terminale).\nDans notre exemple, on a :\n\nInitialisation : La propriété est vraie avec les valeurs initiales des variables car \\(x^0=1\\) et \\(p=1\\).\nConservation : Si nous avons \\(p=x^{compteur}\\) avant une itération, alors nous avons \\(x^{compteur+1}=x^{compteur}\\times x = p\\times x\\). le passage dans la boucle augmente \\(compteur\\) de 1 et remplace \\(p\\) par \\(p\\times x\\). Après l’itération, la propriété \\(p=x^{compteur}\\) est donc encore vraie.\nConclusion : En sortie de boucle, on a donc \\(p=x^{compteur}\\). Or on a aussi l’égalité \\(compteur = n\\) qui a provoqué la sortie de boucle. Finalement, nous avons donc \\(p=x^n\\), ce qui prouve que l’algorithme effectue bien l’opération attendue."
  },
  {
    "objectID": "algo1/generalites.html#complexité",
    "href": "algo1/generalites.html#complexité",
    "title": "Notions de base (Cours)",
    "section": "4. Complexité",
    "text": "4. Complexité\nLa durée d’exécution d’un programme traduisant un algorithme donné va dépendre des performances de la machine sur laquelle le programme est exécuté, mais aussi du nombre d’instructions élémentaires mobilisées lors de son exécution. Une partie de ce temps d’exécution provient donc de la façon dont l’algorithme est écrit et non de la façon dont il est programmé.\nOn parle de complexité temporelle d’un algorithme (et non d’un programme) pour mesurer l’efficacité intrinsèque de l’algorithme. Dans la pratique, il s’agit de compter le nombre d’opérations élémentaires (affectations, comparaisons, calculs arithmétiques, …) effectuées par l’algorithme.\nLa complexité en temps d’un algorithme dépend :\n\nde la taille des données passées en paramètres : plus ces données seront volumineuses, plus il faudra d’opérations élémentaires pour les traiter. On notera \\(n\\) le nombre de données à traiter.\nde la donnée en elle-même, de la façon dont sont réparties les différentes valeurs qui la constituent. Par exemple, si on effectue une recherche séquentielle d’un élément dans une liste non triée, on parcourt un par un les éléments jusqu’à trouver, ou pas, celui recherché. Ce parcours peut s’arrêter dès le début si le premier élément est “le bon”. Mais on peut également être amené à parcourir la liste en entier si l’élément cherché est en dernière position, ou même n’y figure pas.\n\nCette remarque conduit à préciser la définition de la complexité en temps. On peut en effet distinguer deux formes de complexité en temps :\n\nla complexité dans le meilleur des cas : c’est la situation la plus favorable, par exemple : recherche d’un élément situé à la première position d’une liste ;\nla complexité dans le pire des cas : c’est la situation la plus défavorable, par exemple : recherche d’un élément dans une liste alors qu’il n’y figure pas.\n\nOn calculera le plus souvent la complexité dans le pire des cas, car elle est la plus pertinente. Il vaut mieux en effet toujours envisager le pire.\n\nOrdres de grandeurs\nPour comparer des algorithmes, il n’est pas nécessaire de calculer la valeur exacte de la complexité, mais seulement un ordre de grandeur asymptotique, noté en mathématiques \\(\\mathcal{O}\\) (notation “grand O”). La définition rigoureuse de cette notation n’est pas au programme de NSI. Il faut cependant en avoir une idée intuitive : dire que la complexité d’un algorithme est en \\(\\mathcal{O}(n^2)\\), par exemple, signifie que cette complexité croît, lorsque \\(n\\) devient grand, de la même façon que la fonction carré. Plus précisément, elle est majorée par une fonction du type \\(c\\times n^2\\), où \\(c\\) est un réel positif.\nLes classes de complexité à connaître en première, de la meilleure à la pire :\n\n\n\n\n\n\n\n\n\\(\\mathcal{O}\\)\nType de complexité\nExemple\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nconstante\nAccès à une cellule de tableau\n\n\n\\(\\mathcal{O}(n)\\)\nlinéaire\nRecherche du maximum dans un tableau non trié\n\n\n\\(\\mathcal{O}(n^2)\\)\nquadratique\nParcours d’un tableau à deux dimensions\n\n\n\\(\\mathcal{O}(n^3)\\)\ncubique\nParcours d’un tableau à trois dimensions\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nReprenons l’algorithme du calcul de la puissance d’un nombre.\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nNous comptons la complexité en termes d’opérations arithmétiques : additions et multiplications. À chaque passage dans la boucle, nous avons deux opérations et la boucle est parcourue \\(n\\) fois . Nous avons donc au total une complexité de \\(2n\\) opérations arithmétiques, donc une complexité en \\(\\mathcal{O}(n)\\), linéaire.\n\n\n\nVisualisation graphique du temps d’exécution\nEn utilisant le module timeit comme expliqué dans cet article, on peut visualiser graphiquement le temps d’exécution de l’algorithme en fonction de la taille des données.\n\nimport matplotlib.pyplot as plt\nimport timeit\n\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\n\nabscisses = [k for k in range(0, 20, 1)]\nordonnees = []\nfor n in abscisses:\n    ordonnees.append(timeit.timeit('puissance(2, n)', number=100, globals=globals()))\n\nfig, ax = plt.subplots()\nax.set_xlabel('n')\nax.set_ylabel('temps (s)')\nplt.plot(abscisses, ordonnees, 'r')\nplt.show()\n\n\n\n\n\n\n\n\nLa courbe obtenue est proche d’une droite, ce qui est cohérent avec la complexité linéaire de l’algorithme.."
  },
  {
    "objectID": "algo1/index.html",
    "href": "algo1/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "algo1/index.html#points-traités-dans-cette-séquence",
    "href": "algo1/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "algo1/parcoursTableau.html",
    "href": "algo1/parcoursTableau.html",
    "title": "Parcours séquentiel d’un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#recherche-dune-occurrence",
    "href": "algo1/parcoursTableau.html#recherche-dune-occurrence",
    "title": "Parcours séquentiel d’un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#recherche-dun-extremum",
    "href": "algo1/parcoursTableau.html#recherche-dun-extremum",
    "title": "Parcours séquentiel d’un tableau",
    "section": "2. Recherche d’un extremum",
    "text": "2. Recherche d’un extremum\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui recherche le plus grand élément du tableau. Pour cela, on commence par choisir comme maximum temporaire le premier élément du tableau. On parcourt ensuite le tableau en testant à chaque fois si la valeur courante est plus grande que le maximum temporaire. Si c’est le cas, on met à jour le maximum temporaire avec la valeur courante.\n\ndef max(tab):\n    \"\"\"Retourne le plus grand élément du tableau\"\"\"\n    m = tab[0]\n    for i in range(1, len(tab)):\n        if tab[i] &gt; m:\n            m = tab[i]\n    return m\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(max(tab))\n\n2023\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau, sauf la première. Il y a donc au total \\(n-1\\) itérations. Nous avons aussi \\(n-1\\) comparaisons. Au total, le nombre d’opérations est donc de \\(2n-2\\). On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#calcul-dune-moyenne",
    "href": "algo1/parcoursTableau.html#calcul-dune-moyenne",
    "title": "Parcours séquentiel d’un tableau",
    "section": "3. Calcul d’une moyenne",
    "text": "3. Calcul d’une moyenne\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui calcule la moyenne des éléments du tableau.\n\ndef moyenne(tab):\n    \"\"\"Retourne la moyenne des éléments du tableau\"\"\"\n    s = 0\n    for i in range(len(tab)):\n        s += tab[i]\n    return s / len(tab)\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(moyenne(tab))\n\n409.4\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. Nous avons aussi \\(n\\) additions et une division. Au total, le nombre d’opérations est donc de \\(2n+1\\). On peut donc dire que l’algorithme est encore de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spécialité NSI - Première",
    "section": "",
    "text": "Bienvenue !\nCe site est destiné à regrouper les cours et les exercices concernant l’enseignement de spécialité NSI de première du lycée Émile Duclaux d’Aurillac.\nLien vers l’ENT du lycée : https://cas.ent.auvergnerhonealpes.fr/login"
  },
  {
    "objectID": "ressources.html",
    "href": "ressources.html",
    "title": "Sources utilisées",
    "section": "",
    "text": "Pour rédiger ce cours et préparer les exercices, TP, projets présentés ici, j’ai utilisé de nombreuses sources que je vais essayer de citer ici, sans prétendre être exhaustif.\n\nDocuments d’accompagnement Eduscol.\nContenus du MOOC “Numérique et Sciences Informatiques : les fondamentaux” de l’INRIA, disponible sur la plateforme fun-mooc.\nApprendre à programmer avec Python 3, Gérard Swinnen, éditions Eyrolles, 2012. Disponible en ligne\nLe site interstices : https://interstices.info/.\nLes images et illustrations sont soit produites par mes soins, soit issues de Pixabay ou de Wikimedia commons ou encore de Pexels et, dans tous les cas, libres de droits.\nCours de David Roche.\nCours de Frédéric Junier.\nCours de Van Zuijlen Stéphan.\nCours de Konieczko Quentin\nCours de Olivier Lécluse\nCours du Lycée Blaise Pascal de Clermont-Ferrand\nCours du lycée Champollion de Grenoble\nCours du site Lyceum\nCours du site Mon Lycée Numérique\nCours du Lycée Stanislas de Wissembourg\nCours d’informatique de François Brucker (école Centrale de Marseille)\nCours de Philippe Rigaux sur les bases de données.\nCours de Gilles Lassus\nLe site MDN Web Docs : excellentissime ressource pour tout apprendre sur les langages HTML, CSS, Javascript et le protocole HTTP.\nLe site de M. JANVIER."
  }
]
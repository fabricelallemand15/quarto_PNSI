[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "algo1/generalites.html",
    "href": "algo1/generalites.html",
    "title": "Notions de base (Cours)",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème."
  },
  {
    "objectID": "algo1/generalites.html#introduction",
    "href": "algo1/generalites.html#introduction",
    "title": "Notions de base (Cours)",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème."
  },
  {
    "objectID": "algo1/generalites.html#terminaison-dun-algorithme",
    "href": "algo1/generalites.html#terminaison-dun-algorithme",
    "title": "Notions de base (Cours)",
    "section": "2. Terminaison d’un algorithme",
    "text": "2. Terminaison d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la terminaison d’un algorithme, c’est prouver que l’algorithme se termine dans tous les cas. C’est notamment très important lorsque l’algorithme comporte des boucles conditionnelles.\n\n\nPrenons comme exemple l’algorithme suivant qui calcule la puissance entière d’un nombre :\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nComment justifier que cet algorithme se termine dans tous les cas ? Cela revient à montrer que la boucle conditionnelle while compteur &lt; n se termine après un nombre fini d’itérations. Pour cela, on utilise un variant de boucle : c’est une valeur qui évolue à chaque itération de la boucle et qui permet de prouver que celle-ci se termine.\nDans notre exemple, on peut choisir comme variant de boucle la valeur de la variable \\(compteur\\). En effet, cette variable est initialisée à 0 et est incrémentée de 1 à chaque itération. Après \\(n\\) itérations, la condition de sortie de boucle sera donc vraie et la boucle se terminera.\nLa terminaison de l’algorithme est donc démontrée."
  },
  {
    "objectID": "algo1/generalites.html#correction-dun-algorithme",
    "href": "algo1/generalites.html#correction-dun-algorithme",
    "title": "Notions de base (Cours)",
    "section": "3. Correction d’un algorithme",
    "text": "3. Correction d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la correction d’un algorithme, c’est prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\n\n\nConsidérons à nouveau l’algorithme de calcul de puissance entière. Comment prouver que cet algorithme calcule bien la puissance entière d’un nombre ?\nOn utilise pour cela un invariant de boucle : c’est une propriété qui est vraie avant et après chaque itération de la boucle, et qui doit permettre de prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\nDans notre exemple de calcul de puissance entière, on peut choisir comme invariant de boucle la propriété suivante : \\[p=x^{compteur}\\]\n\n\n\n\n\n\nPour prouver q’une propriété est un invariant de boucle…\n\n\n\nIl faut démontrer :\n\nInitialisation : la propriété est vraie avant le premier passage dans la boucle\nConservation : si la propriété est vraie avant une itération, alors elle sera aussi vraie après cette itération.\nConclusion : une fois la boucle terminée, la propriété est vraie.\n\n\n\nCette méthode de raisonnement est appelée raisonnement par récurrence et est très utilisée en mathématiques (au programme en spécialité mathématiques de terminale).\nDans notre exemple, on a :\n\nInitialisation : La propriété est vraie avec les valeurs initiales des variables car \\(x^0=1\\) et \\(p=1\\).\nConservation : Si nous avons \\(p=x^{compteur}\\) avant une itération, alors nous avons \\(x^{compteur+1}=x^{compteur}\\times x = p\\times x\\). le passage dans la boucle augmente \\(compteur\\) de 1 et remplace \\(p\\) par \\(p\\times x\\). Après l’itération, la propriété \\(p=x^{compteur}\\) est donc encore vraie.\nConclusion : En sortie de boucle, on a donc \\(p=x^{compteur}\\). Or on a aussi l’égalité \\(compteur = n\\) qui a provoqué la sortie de boucle. Finalement, nous avons donc \\(p=x^n\\), ce qui prouve que l’algorithme effectue bien l’opération attendue."
  },
  {
    "objectID": "algo1/generalites.html#complexité",
    "href": "algo1/generalites.html#complexité",
    "title": "Notions de base (Cours)",
    "section": "4. Complexité",
    "text": "4. Complexité\nLa durée d’exécution d’un programme traduisant un algorithme donné va dépendre des performances de la machine sur laquelle le programme est exécuté, mais aussi du nombre d’instructions élémentaires mobilisées lors de son exécution. Une partie de ce temps d’exécution provient donc de la façon dont l’algorithme est écrit et non de la façon dont il est programmé.\nOn parle de complexité temporelle d’un algorithme (et non d’un programme) pour mesurer l’efficacité intrinsèque de l’algorithme. Dans la pratique, il s’agit de compter le nombre d’opérations élémentaires (affectations, comparaisons, calculs arithmétiques, …) effectuées par l’algorithme.\nLa complexité en temps d’un algorithme dépend :\n\nde la taille des données passées en paramètres : plus ces données seront volumineuses, plus il faudra d’opérations élémentaires pour les traiter. On notera \\(n\\) le nombre de données à traiter.\nde la donnée en elle-même, de la façon dont sont réparties les différentes valeurs qui la constituent. Par exemple, si on effectue une recherche séquentielle d’un élément dans une liste non triée, on parcourt un par un les éléments jusqu’à trouver, ou pas, celui recherché. Ce parcours peut s’arrêter dès le début si le premier élément est “le bon”. Mais on peut également être amené à parcourir la liste en entier si l’élément cherché est en dernière position, ou même n’y figure pas.\n\nCette remarque conduit à préciser la définition de la complexité en temps. On peut en effet distinguer deux formes de complexité en temps :\n\nla complexité dans le meilleur des cas : c’est la situation la plus favorable, par exemple : recherche d’un élément situé à la première position d’une liste ;\nla complexité dans le pire des cas : c’est la situation la plus défavorable, par exemple : recherche d’un élément dans une liste alors qu’il n’y figure pas.\n\nOn calculera le plus souvent la complexité dans le pire des cas, car elle est la plus pertinente. Il vaut mieux en effet toujours envisager le pire.\n\nOrdres de grandeurs\nPour comparer des algorithmes, il n’est pas nécessaire de calculer la valeur exacte de la complexité, mais seulement un ordre de grandeur asymptotique, noté en mathématiques \\(\\mathcal{O}\\) (notation “grand O”). La définition rigoureuse de cette notation n’est pas au programme de NSI. Il faut cependant en avoir une idée intuitive : dire que la complexité d’un algorithme est en \\(\\mathcal{O}(n^2)\\), par exemple, signifie que cette complexité croît, lorsque \\(n\\) devient grand, de la même façon que la fonction carré. Plus précisément, elle est majorée par une fonction du type \\(c\\times n^2\\), où \\(c\\) est un réel positif.\nLes classes de complexité à connaître en première, de la meilleure à la pire :\n\n\n\n\n\n\n\n\n\\(\\mathcal{O}\\)\nType de complexité\nExemple\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nconstante\nAccès à une cellule de tableau\n\n\n\\(\\mathcal{O}(n)\\)\nlinéaire\nRecherche du maximum dans un tableau non trié\n\n\n\\(\\mathcal{O}(n^2)\\)\nquadratique\nParcours d’un tableau à deux dimensions\n\n\n\\(\\mathcal{O}(n^3)\\)\ncubique\nParcours d’un tableau à trois dimensions\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nReprenons l’algorithme du calcul de la puissance d’un nombre.\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nNous comptons la complexité en termes d’opérations arithmétiques : additions et multiplications. À chaque passage dans la boucle, nous avons deux opérations et la boucle est parcourue \\(n\\) fois . Nous avons donc au total une complexité de \\(2n\\) opérations arithmétiques, donc une complexité en \\(\\mathcal{O}(n)\\), linéaire.\n\n\n\nVisualisation graphique du temps d’exécution\nEn utilisant le module timeit comme expliqué dans cet article, on peut visualiser graphiquement le temps d’exécution de l’algorithme en fonction de la taille des données.\n\nimport matplotlib.pyplot as plt\nimport timeit\n\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\n\nabscisses = [k for k in range(0, 20, 1)]\nordonnees = []\nfor n in abscisses:\n    ordonnees.append(timeit.timeit('puissance(2, n)', number=100, globals=globals()))\n\nfig, ax = plt.subplots()\nax.set_xlabel('n')\nax.set_ylabel('temps (s)')\nplt.plot(abscisses, ordonnees, 'r')\nplt.show()\n\n\n\n\n\n\n\n\nLa courbe obtenue est proche d’une droite, ce qui est cohérent avec la complexité linéaire de l’algorithme.."
  },
  {
    "objectID": "algo1/index.html",
    "href": "algo1/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "algo1/index.html#points-traités-dans-cette-séquence",
    "href": "algo1/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "algo1/parcoursTableau.html",
    "href": "algo1/parcoursTableau.html",
    "title": "Parcours séquentiel d’un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#recherche-dune-occurrence",
    "href": "algo1/parcoursTableau.html#recherche-dune-occurrence",
    "title": "Parcours séquentiel d’un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#recherche-dun-extremum",
    "href": "algo1/parcoursTableau.html#recherche-dun-extremum",
    "title": "Parcours séquentiel d’un tableau",
    "section": "2. Recherche d’un extremum",
    "text": "2. Recherche d’un extremum\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui recherche le plus grand élément du tableau. Pour cela, on commence par choisir comme maximum temporaire le premier élément du tableau. On parcourt ensuite le tableau en testant à chaque fois si la valeur courante est plus grande que le maximum temporaire. Si c’est le cas, on met à jour le maximum temporaire avec la valeur courante.\n\ndef max(tab):\n    \"\"\"Retourne le plus grand élément du tableau\"\"\"\n    m = tab[0]\n    for i in range(1, len(tab)):\n        if tab[i] &gt; m:\n            m = tab[i]\n    return m\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(max(tab))\n\n2023\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau, sauf la première. Il y a donc au total \\(n-1\\) itérations. Nous avons aussi \\(n-1\\) comparaisons. Au total, le nombre d’opérations est donc de \\(2n-2\\). On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#calcul-dune-moyenne",
    "href": "algo1/parcoursTableau.html#calcul-dune-moyenne",
    "title": "Parcours séquentiel d’un tableau",
    "section": "3. Calcul d’une moyenne",
    "text": "3. Calcul d’une moyenne\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui calcule la moyenne des éléments du tableau.\n\ndef moyenne(tab):\n    \"\"\"Retourne la moyenne des éléments du tableau\"\"\"\n    s = 0\n    for i in range(len(tab)):\n        s += tab[i]\n    return s / len(tab)\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(moyenne(tab))\n\n409.4\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. Nous avons aussi \\(n\\) additions et une division. Au total, le nombre d’opérations est donc de \\(2n+1\\). On peut donc dire que l’algorithme est encore de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spécialité NSI - Première",
    "section": "",
    "text": "Bienvenue !\nCe site est destiné à regrouper les cours et les exercices concernant l’enseignement de spécialité NSI de première du lycée Émile Duclaux d’Aurillac.\nLien vers l’ENT du lycée : https://cas.ent.auvergnerhonealpes.fr/login"
  },
  {
    "objectID": "ressources.html",
    "href": "ressources.html",
    "title": "Sources utilisées",
    "section": "",
    "text": "Pour rédiger ce cours et préparer les exercices, TP, projets présentés ici, j’ai utilisé de nombreuses sources que je vais essayer de citer ici, sans prétendre être exhaustif.\n\nDocuments d’accompagnement Eduscol.\nContenus du MOOC “Numérique et Sciences Informatiques : les fondamentaux” de l’INRIA, disponible sur la plateforme fun-mooc.\nApprendre à programmer avec Python 3, Gérard Swinnen, éditions Eyrolles, 2012. Disponible en ligne\nLe site interstices : https://interstices.info/.\nLes images et illustrations sont soit produites par mes soins, soit issues de Pixabay ou de Wikimedia commons ou encore de Pexels et, dans tous les cas, libres de droits.\nCours de David Roche.\nCours de Frédéric Junier.\nCours de Van Zuijlen Stéphan.\nCours de Konieczko Quentin\nCours de Olivier Lécluse\nCours du Lycée Blaise Pascal de Clermont-Ferrand\nCours du lycée Champollion de Grenoble\nCours du site Lyceum\nCours du site Mon Lycée Numérique\nCours du Lycée Stanislas de Wissembourg\nCours d’informatique de François Brucker (école Centrale de Marseille)\nCours de Philippe Rigaux sur les bases de données.\nCours de Gilles Lassus\nLe site MDN Web Docs : excellentissime ressource pour tout apprendre sur les langages HTML, CSS, Javascript et le protocole HTTP.\nLe site de M. JANVIER."
  },
  {
    "objectID": "algo1/tris.html",
    "href": "algo1/tris.html",
    "title": "Algorithmes de tris",
    "section": "",
    "text": "Dans cette partie du cours, nous allons étudier deux algorithmes de tris : le tri par insertion et le tri par sélection.\nÉtant donné un tableau de nombres, l’objectif est d’écrire une fonction qui renvoie un tableau contenant les mêmes nombres mais dans l’ordre croissant."
  },
  {
    "objectID": "algo1/tris.html#tri-par-insertion",
    "href": "algo1/tris.html#tri-par-insertion",
    "title": "Algorithmes de tris",
    "section": "1. Tri par insertion",
    "text": "1. Tri par insertion\n\nLe principe\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\nEn commençant par le deuxième élément du tableau :\n\nOn compare l’élément courant avec l’élément précédent.\nSi l’élément courant est plus petit, on échange les deux éléments.\nOn continue à comparer et échanger l’élément courant avec les éléments précédents jusqu’à ce que l’élément courant soit plus grand que l’élément précédent.\n\n\n\n\n\n\n\n\nExemple : Soit à trier le tableau \\([5,2,7,3]\\).\n\nOn commence par le deuxième élément du tableau, c’est-à-dire l’élément 2. On compare l’élément 2 avec l’élément 5. L’élément 2 est plus petit que l’élément 5, on échange les deux éléments. Le tableau est donc \\([2,5,7,3]\\).\nOn continue avec l’élément 7. L’élément 7 est plus grand que l’élément 5, on ne fait rien.\nOn continue avec l’élément 3. L’élément 3 est plus petit que l’élément 7, on échange les deux éléments. Le tableau est donc \\([2,5,3,7]\\). On continue à comparer et échanger l’élément 3 avec les éléments précédents jusqu’à ce que l’élément 3 soit plus grand que l’élément 5. Le tableau est donc \\([2,3,5,7]\\). L’algorithme est terminé. Le tableau est trié.\n\n\n\nProgrammation\n\ndef tri_insertion(tableau: list) -&gt; list:\n    \"\"\"Tri en place par insertion le tableau passé en paramètre.\"\"\"\n1    for i in range(1, len(tableau)):\n2        j = i\n3        while j &gt; 0 and tableau[j] &lt; tableau[j-1]:\n4            tableau[j], tableau[j-1] = tableau[j-1], tableau[j]\n5            j -= 1\n    return tableau\n\n\n1\n\nOn commence à l’indice 1 qui correspond au deuxième élément du tableau.\n\n2\n\nOn stocke l’indice courant dans une variable j pour pouvoir le modifier.\n\n3\n\nTant que l’indice courant est supérieur à 0 et que l’élément courant est plus petit que l’élément précédent, on échange les deux éléments.\n\n4\n\nOn échange les deux éléments.\n\n5\n\nL’élément courant est maintenant l’élément précédent, on décrémente donc l’indice courant.\n\n\n\n\nTest de l’algorithme :\n\ntri_insertion([5, 2, 4, 6, 1, 3])\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nPreuve de terminaison\nMontrons que l’algorithme termine.\nD’une part, il est certain que la boucle for, boucle bornée par nature, se termine. D’autre part, la boucle while se termine aussi. La variable j peut être est un variant de boucle. À chaque itération, sa valeur de diminue de 1 : elle finit donc toujours par atteindre 0.\nLa terminaison de l’algorithme est donc prouvée.\n\n\nPreuve de correction\nMontrons que l’algorithme trie bien le tableau.\nPour cela, considérons la propriété suivante : à chaque itération, le sous-tableau composé des i premiers éléments est trié. Montrons que cette propriété est un invariant de boucle.\n\nInitialisation : au début de l’algorithme, le sous-tableau composé uniquement du premier élément est trié.\nConservation : supposons que le le sous-tableau composé des i premiers éléments est trié : \\([e_0, e_1, \\ldots, e_{i-1}]\\) avec \\(e_0\\leqslant e_1\\leqslant \\ldots \\leqslant e_{i-1}\\). L’algorithme considère alors l’élément \\(e_i\\) et le compare avec les éléments précédents. Si \\(e_i\\) est plus petit que \\(e_{i-1}\\), on échange les deux éléments. On continue alors à comparer \\(e_i\\) avec les éléments précédents jusqu’à ce que \\(e_i\\) soit plus grand que l’élément précédent. Le sous-tableau composé des i+1 premiers éléments est alors trié.\nConclusion : à la fin de l’algorithme i a la valeur n-1 ce qui correspond à l’indice du dernier élément du tableau. Le sous-tableau composé des n premiers éléments est donc trié. Or, n est le nombre d’éléments du tableau, donc le tableau entier est trié.\n\nLa correction de l’algorithme est donc prouvée.\n\n\nComplexité\nOn recherche la complexité dans le pire des cas. Le pire des cas est le cas où le tableau de départ est rangé dans l’ordre décroissant.\nNotons \\(n\\) la taille du tableau de départ.\nLa boucle for comporte \\(n-1\\) itérations.\nDans le cas où le tableau de départ est rangé dans l’ordre décroissant, la boucle while comporte 1 opération, puis 2, puis 3, etc. jusqu’à \\(n-1\\) opérations pour la dernière itération. On obtient donc la somme suivante pour le nombre total d’opérations :\n\\[1+2+3+\\ldots+(n-1)=\\frac{n(n-1)}{2}\\]\nSachant que \\(\\frac{n(n-1)}{2} = \\frac{n^2-n}{2}\\), il s’agit donc d’une complexité quadratique, en \\(\\mathcal{O}(n^2)\\)."
  },
  {
    "objectID": "algo1/tris.html#tri-par-sélection",
    "href": "algo1/tris.html#tri-par-sélection",
    "title": "Algorithmes de tris",
    "section": "2. Tri par sélection",
    "text": "2. Tri par sélection\n\n\n\n\n\n\nLe principe\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\nEn commençant par le premier élément du tableau :\n\nOn recherche le plus petit élément parmi les éléments suivants du tableau.\nOn échange l’élément courant avec le plus petit élément.\n\n\n\nExemple : Soit à trier le tableau \\([5,2,3,7]\\).\n\nOn commence par le premier élément, 5. On recherche le plus petit élément parmi les éléments suivants du tableau, c’est-à-dire 2. On échange 5 et 2 : le tableau est maintenant \\([2,5,3,7]\\).\nL’élément courant est maintenant le deuxième du tableau, c’est donc encore 5. On recherche le plus petit élément parmi les éléments suivants du tableau, c’est-à-dire 3. On échange 5 et 3 : le tableau est maintenant \\([2,3,5,7]\\).\nL’élément courant est maintenant le troisième du tableau, c’est donc encore 5. On recherche le plus petit élément parmi les éléments suivants du tableau, mais aucun n’est plus petit que 5. On ne fait donc rien.\nL’élément courant est maintenant le dernier du tableau, c’est donc 7. On ne fait donc rien et le tableau est trié.\n\n\n\nProgrammation\n\ndef tri_selection(tableau: list) -&gt; list:\n    \"\"\"Trie en place par sélection le tableau passé en paramètre.\"\"\"\n1    for i in range(len(tableau)):\n2        min = i\n3        for j in range(i+1, len(tableau)):\n4            if tableau[j] &lt; tableau[min]:\n                min = j\n5        tableau[i], tableau[min] = tableau[min], tableau[i]\n    return tableau\n\n\n1\n\nOn commence à l’indice 0 qui correspond au premier élément du tableau.\n\n2\n\nOn stocke l’indice courant dans une variable min pour pouvoir le modifier.\n\n3\n\nOn parcourt le tableau à partir de l’indice i+1 jusqu’à la fin.\n\n4\n\nSi l’élément courant est plus petit que l’élément stocké dans min, on met à jour min.\n\n5\n\nOn échange les deux éléments.\n\n\n\n\nTest de l’algorithme :\n\ntri_selection([5, 2, 4, 6, 1, 3])\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nPreuve de terminaison\nL’algorithme se termine puisqu’il comporte deux boucles for qui sont toutes deux bornées par nature.\n\n\nPreuve de correction\nMontrons que l’algorithme trie bien le tableau.\nPour cela, considérons la propriété suivante : à chaque itération, le sous-tableau composé des i premiers éléments est trié. Montrons que cette propriété est un invariant de boucle.\n\nInitialisation : au début de l’algorithme, le sous-tableau composé uniquement du premier élément est trié.\nConservation : supposons que le le sous-tableau composé des i premiers éléments est trié : \\([e_0, e_1, \\ldots, e_{i-1}]\\) avec \\(e_0\\leqslant e_1\\leqslant \\ldots \\leqslant e_{i-1}\\). Par construction, tous les éléments suivants sont supérieurs à \\(e_{i-1}\\). L’algorithme considère alors l’élément \\(e_i\\) et le compare avec les éléments suivants. Si un élément est plus petit que \\(e_i\\), on échange les deux éléments. Le sous-tableau composé des i+1 premiers éléments est alors trié.\nConslusion : à la fin de l’algorithme i a la valeur n-1 ce qui correspond à l’indice du dernier élément du tableau. Le sous-tableau composé des n premiers éléments est donc trié. Or, n est le nombre d’éléments du tableau, donc le tableau entier est trié.\n\nLa correction de l’algorithme est donc prouvée.\n\n\nComplexité\nOn recherche la complexité dans le pire des cas. Le pire des cas est le cas où le tableau de départ est rangé dans l’ordre décroissant.\nNotons \\(n\\) la taille du tableau de départ.\nLa boucle for i comporte \\(n-1\\) itérations. La boucle for j comporte \\(n-1\\) itérations pour la première itération, puis \\(n-2\\) itérations pour la seconde itération, etc. jusqu’à 1 opération pour la dernière itération. On obtient donc la somme suivante pour le nombre total d’opérations :\n\\[n-1+(n-2)+(n-3)+\\ldots+1=\\frac{n(n-1)}{2}\\]\nSachant que \\(\\frac{n(n-1)}{2} = \\frac{n^2-n}{2}\\), il s’agit donc d’une complexité quadratique, en \\(\\mathcal{O}(n^2)\\)."
  },
  {
    "objectID": "algo1/tris.html#observation-expérimentale-de-la-complexité",
    "href": "algo1/tris.html#observation-expérimentale-de-la-complexité",
    "title": "Algorithmes de tris",
    "section": "3. Observation expérimentale de la complexité",
    "text": "3. Observation expérimentale de la complexité\n\nTri par insertion\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps = []\n# on applique le tri dans le pire des cas : tableau trié dans l'ordre décroissant\nfor n in tailles:\n    temps.append(timeit.timeit(\n        \"tri_insertion([n-k for k in range(n)])\",\n        globals=globals(),\n        number=1\n    ))\nplt.plot(tailles, temps)\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nTri par sélection\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps = []\n# on applique le tri dans le pire des cas : tableau trié dans l'ordre décroissant\nfor n in tailles:\n    temps.append(timeit.timeit(\n        \"tri_selection([n-k for k in range(n)])\",\n        globals=globals(),\n        number=1\n    ))\nplt.plot(tailles, temps)\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.show()\n\n\n\n\n\n\n\n\nDans les deux cas, la forme grossièrement parabolique de la courbe est caractéristique de la complexité quadratique."
  }
]
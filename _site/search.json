[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "algo1/exos_recherche.html",
    "href": "algo1/exos_recherche.html",
    "title": "Exercices - Recherche dichotomique",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "algo1/exos_recherche.html#fa-desktop-t.p.-bilan-et-compléments",
    "href": "algo1/exos_recherche.html#fa-desktop-t.p.-bilan-et-compléments",
    "title": "Exercices - Recherche dichotomique",
    "section": " T.P. : Bilan et compléments",
    "text": "T.P. : Bilan et compléments\n\n\n\n\n\n\nImportant\n\n\n\nNotebook Capytale pour ce T.P. : Capytale \nCe T.P. est à faire dans Capytale en suivant le lien ci-dessus."
  },
  {
    "objectID": "algo1/exos_tris.html",
    "href": "algo1/exos_tris.html",
    "title": "Exercices - Algorithmes de tris",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "algo1/exos_tris.html#fa-desktop-exercice-1",
    "href": "algo1/exos_tris.html#fa-desktop-exercice-1",
    "title": "Exercices - Algorithmes de tris",
    "section": " Exercice 1",
    "text": "Exercice 1\nCet exercice est à faire dans Capytale.\nÉcrire une fonction trie_chaine qui prend en argument une liste de chaînes de caractères et qui modifie cette liste en la triant en fonction du nombre de lettres. Cette fonction ne renvoie rien.\nTester la fonction avec la liste [\"un\", \"deux\", \"trois\", \"quatre\", \"cinq\", \"six\", \"sept\", \"huit\", \"neuf\", \"dix\"]."
  },
  {
    "objectID": "algo1/exos_tris.html#fa-desktop-exercice-2-le-tri-à-bulles",
    "href": "algo1/exos_tris.html#fa-desktop-exercice-2-le-tri-à-bulles",
    "title": "Exercices - Algorithmes de tris",
    "section": " Exercice 2 : le tri à bulles",
    "text": "Exercice 2 : le tri à bulles\nCet exercice est à faire dans Capytale.\nL’algorithme de tri à bulles est le suivant :\n\nOn parcourt la liste de gauche à droite.\nSi deux éléments consécutifs sont dans le mauvais ordre, on les échange.\nSi, à l’étape précédente, au moins un échange a eu lieu, on recommence à l’étape 1.\nSinon, la liste est triée et on arrête.\n\n\nÉcrire toutes les étapes du tri à bulles pour la liste [5, 3, 2, 4, 1].\nSoit \\(n\\) un entier naturel non nul et \\(L\\) une liste de \\(n\\) entiers rangés dans l’ordre décroissant (pire des cas). Combien d’échanges sont nécessaires pour trier \\(L\\) dans l’ordre croissant ? En déduire une évaluation de la complexité de cet algorithme.\nÉcrire une fonction tri_bulles qui prend en argument une liste de nombres et qui modifie cette liste en la triant par ordre croissant en utilisant l’algorithme du tri à bulles. Cette fonction ne renvoie rien.\nAjouter une variable compteur dans la fonction tri_bulles qui compte le nombre d’échanges effectués. Ce nombre doit être renvoyé par la fonction. Tester la fonction avec la liste [5, 3, 2, 4, 1] et vérifier que le compteur vaut bien 6."
  },
  {
    "objectID": "algo1/exos_tris.html#fa-desktop-t.p.-bilan-et-compléments",
    "href": "algo1/exos_tris.html#fa-desktop-t.p.-bilan-et-compléments",
    "title": "Exercices - Algorithmes de tris",
    "section": " T.P. : Bilan et compléments",
    "text": "T.P. : Bilan et compléments\n\n\n\n\n\n\nImportant\n\n\n\nNotebook Capytale pour ce T.P. : Capytale \nCe T.P. est à faire dans Capytale en suivant le lien ci-dessus."
  },
  {
    "objectID": "algo1/generalites.html",
    "href": "algo1/generalites.html",
    "title": "Notions de base (Cours)",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème."
  },
  {
    "objectID": "algo1/generalites.html#introduction",
    "href": "algo1/generalites.html#introduction",
    "title": "Notions de base (Cours)",
    "section": "",
    "text": "L’algorithmique est la science qui étudie les algorithmes. Un algorithme est une suite d’instructions permettant de résoudre un problème.\nPour résoudre un problème, il existe souvent plusieurs algorithmes possibles.\nLes objectifs de cette partie du cours sont d’apprendre à :\n\nprouver qu’un algorithme donné se termine en un temps fini ;\nprouver qu’un algorithme donné réalise bien ce pour quoi il a été écrit ;\ncomparer deux algorithmes différents répondant au même problème."
  },
  {
    "objectID": "algo1/generalites.html#terminaison-dun-algorithme",
    "href": "algo1/generalites.html#terminaison-dun-algorithme",
    "title": "Notions de base (Cours)",
    "section": "2. Terminaison d’un algorithme",
    "text": "2. Terminaison d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la terminaison d’un algorithme, c’est prouver que l’algorithme se termine dans tous les cas. C’est notamment très important lorsque l’algorithme comporte des boucles conditionnelles.\n\n\nPrenons comme exemple l’algorithme suivant qui calcule la puissance entière d’un nombre :\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nComment justifier que cet algorithme se termine dans tous les cas ? Cela revient à montrer que la boucle conditionnelle while compteur &lt; n se termine après un nombre fini d’itérations. Pour cela, on utilise un variant de boucle : c’est une valeur qui évolue à chaque itération de la boucle et qui permet de prouver que celle-ci se termine.\nDans notre exemple, on peut choisir comme variant de boucle la valeur de la variable \\(compteur\\). En effet, cette variable est initialisée à 0 et est incrémentée de 1 à chaque itération. Après \\(n\\) itérations, la condition de sortie de boucle sera donc vraie et la boucle se terminera.\nLa terminaison de l’algorithme est donc démontrée."
  },
  {
    "objectID": "algo1/generalites.html#correction-dun-algorithme",
    "href": "algo1/generalites.html#correction-dun-algorithme",
    "title": "Notions de base (Cours)",
    "section": "3. Correction d’un algorithme",
    "text": "3. Correction d’un algorithme\n\n\n\n\n\n\nDéfinition\n\n\n\nProuver la correction d’un algorithme, c’est prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\n\n\nConsidérons à nouveau l’algorithme de calcul de puissance entière. Comment prouver que cet algorithme calcule bien la puissance entière d’un nombre ?\nOn utilise pour cela un invariant de boucle : c’est une propriété qui est vraie avant et après chaque itération de la boucle, et qui doit permettre de prouver que l’algorithme réalise bien ce pour quoi il a été écrit.\nDans notre exemple de calcul de puissance entière, on peut choisir comme invariant de boucle la propriété suivante : \\[p=x^{compteur}\\]\n\n\n\n\n\n\nPour prouver q’une propriété est un invariant de boucle…\n\n\n\nIl faut démontrer :\n\nInitialisation : la propriété est vraie avant le premier passage dans la boucle\nConservation : si la propriété est vraie avant une itération, alors elle sera aussi vraie après cette itération.\nConclusion : une fois la boucle terminée, la propriété est vraie.\n\n\n\nCette méthode de raisonnement est appelée raisonnement par récurrence et est très utilisée en mathématiques (au programme en spécialité mathématiques de terminale).\nDans notre exemple, on a :\n\nInitialisation : La propriété est vraie avec les valeurs initiales des variables car \\(x^0=1\\) et \\(p=1\\).\nConservation : Si nous avons \\(p=x^{compteur}\\) avant une itération, alors nous avons \\(x^{compteur+1}=x^{compteur}\\times x = p\\times x\\). le passage dans la boucle augmente \\(compteur\\) de 1 et remplace \\(p\\) par \\(p\\times x\\). Après l’itération, la propriété \\(p=x^{compteur}\\) est donc encore vraie.\nConclusion : En sortie de boucle, on a donc \\(p=x^{compteur}\\). Or on a aussi l’égalité \\(compteur = n\\) qui a provoqué la sortie de boucle. Finalement, nous avons donc \\(p=x^n\\), ce qui prouve que l’algorithme effectue bien l’opération attendue."
  },
  {
    "objectID": "algo1/generalites.html#complexité",
    "href": "algo1/generalites.html#complexité",
    "title": "Notions de base (Cours)",
    "section": "4. Complexité",
    "text": "4. Complexité\nLa durée d’exécution d’un programme traduisant un algorithme donné va dépendre des performances de la machine sur laquelle le programme est exécuté, mais aussi du nombre d’instructions élémentaires mobilisées lors de son exécution. Une partie de ce temps d’exécution provient donc de la façon dont l’algorithme est écrit et non de la façon dont il est programmé.\nOn parle de complexité temporelle d’un algorithme (et non d’un programme) pour mesurer l’efficacité intrinsèque de l’algorithme. Dans la pratique, il s’agit de compter le nombre d’opérations élémentaires (affectations, comparaisons, calculs arithmétiques, …) effectuées par l’algorithme.\nLa complexité en temps d’un algorithme dépend :\n\nde la taille des données passées en paramètres : plus ces données seront volumineuses, plus il faudra d’opérations élémentaires pour les traiter. On notera \\(n\\) le nombre de données à traiter.\nde la donnée en elle-même, de la façon dont sont réparties les différentes valeurs qui la constituent. Par exemple, si on effectue une recherche séquentielle d’un élément dans une liste non triée, on parcourt un par un les éléments jusqu’à trouver, ou pas, celui recherché. Ce parcours peut s’arrêter dès le début si le premier élément est “le bon”. Mais on peut également être amené à parcourir la liste en entier si l’élément cherché est en dernière position, ou même n’y figure pas.\n\nCette remarque conduit à préciser la définition de la complexité en temps. On peut en effet distinguer deux formes de complexité en temps :\n\nla complexité dans le meilleur des cas : c’est la situation la plus favorable, par exemple : recherche d’un élément situé à la première position d’une liste ;\nla complexité dans le pire des cas : c’est la situation la plus défavorable, par exemple : recherche d’un élément dans une liste alors qu’il n’y figure pas.\n\nOn calculera le plus souvent la complexité dans le pire des cas, car elle est la plus pertinente. Il vaut mieux en effet toujours envisager le pire.\n\nOrdres de grandeurs\nPour comparer des algorithmes, il n’est pas nécessaire de calculer la valeur exacte de la complexité, mais seulement un ordre de grandeur asymptotique, noté en mathématiques \\(\\mathcal{O}\\) (notation “grand O”). La définition rigoureuse de cette notation n’est pas au programme de NSI. Il faut cependant en avoir une idée intuitive : dire que la complexité d’un algorithme est en \\(\\mathcal{O}(n^2)\\), par exemple, signifie que cette complexité croît, lorsque \\(n\\) devient grand, de la même façon que la fonction carré. Plus précisément, elle est majorée par une fonction du type \\(c\\times n^2\\), où \\(c\\) est un réel positif.\nLes classes de complexité à connaître en première, de la meilleure à la pire :\n\n\n\n\n\n\n\n\n\\(\\mathcal{O}\\)\nType de complexité\nExemple\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nconstante\nAccès à une cellule de tableau\n\n\n\\(\\mathcal{O}(n)\\)\nlinéaire\nRecherche du maximum dans un tableau non trié\n\n\n\\(\\mathcal{O}(n^2)\\)\nquadratique\nParcours d’un tableau à deux dimensions\n\n\n\\(\\mathcal{O}(n^3)\\)\ncubique\nParcours d’un tableau à trois dimensions\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nReprenons l’algorithme du calcul de la puissance d’un nombre.\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\nNous comptons la complexité en termes d’opérations arithmétiques : additions et multiplications. À chaque passage dans la boucle, nous avons deux opérations et la boucle est parcourue \\(n\\) fois . Nous avons donc au total une complexité de \\(2n\\) opérations arithmétiques, donc une complexité en \\(\\mathcal{O}(n)\\), linéaire.\n\n\n\nVisualisation graphique du temps d’exécution\nEn utilisant le module timeit comme expliqué dans cet article, on peut visualiser graphiquement le temps d’exécution de l’algorithme en fonction de la taille des données.\n\nimport matplotlib.pyplot as plt\nimport timeit\n\ndef puissance(x: float, n: int) -&gt; float:\n    \"\"\"retourne x^n\"\"\"\n    p = 1\n    compteur = 0\n    while compteur &lt; n:\n        compteur = compteur + 1\n        p = p * x\n    return p\n\nabscisses = [k for k in range(0, 20, 1)]\nordonnees = []\nfor n in abscisses:\n    ordonnees.append(timeit.timeit('puissance(2, n)', number=100, globals=globals()))\n\nfig, ax = plt.subplots()\nax.set_xlabel('n')\nax.set_ylabel('temps (s)')\nplt.plot(abscisses, ordonnees, 'r')\nplt.show()\n\n\n\n\n\n\n\n\nLa courbe obtenue est proche d’une droite, ce qui est cohérent avec la complexité linéaire de l’algorithme.."
  },
  {
    "objectID": "algo1/index.html",
    "href": "algo1/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "algo1/index.html#points-traités-dans-cette-séquence",
    "href": "algo1/index.html#points-traités-dans-cette-séquence",
    "title": "Programme",
    "section": "",
    "text": "Le concept de méthode algorithmique est introduit ; de nouveaux exemples seront vus en terminale. Quelques algorithmes classiques sont étudiés. L’étude de leurs coûts respectifs prend tout son sens dans le cas de données nombreuses, qui peuvent être préférentiellement des données ouvertes.\nIl est nécessaire de montrer l’intérêt de prouver la correction d’un algorithme pour lequel on dispose d’une spécification précise, notamment en mobilisant la notion d’invariant sur des exemples simples. La nécessité de prouver la terminaison d’un programme est mise en évidence dès qu’on utilise une boucle non bornée (ou, en terminale, des fonctions récursives) grâce à la mobilisation de la notion de variant sur des exemples simples.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nParcours séquentiel d’un tableau\nÉcrire un algorithme de recherche d’une occurrence sur des valeurs de type quelconque. Écrire un algorithme de recherche d’un extremum, de calcul d’une moyenne.\nOn montre que le coût est linéaire.\n\n\nTris par insertion, par sélection\nÉcrire un algorithme de tri. Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection.\nLa terminaison de ces algorithmes est à justifier. On montre que leur coût est quadratique dans le pire cas.\n\n\nRecherche dichotomique dans un tableau trié\nMontrer la terminaison de la recherche dichotomique à l’aide d’un variant de boucle.\nDes assertions peuvent être utilisées. La preuve de la correction peut être présentée par le professeur"
  },
  {
    "objectID": "algo1/parcoursTableau.html",
    "href": "algo1/parcoursTableau.html",
    "title": "Parcours séquentiel d’un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#recherche-dune-occurrence",
    "href": "algo1/parcoursTableau.html#recherche-dune-occurrence",
    "title": "Parcours séquentiel d’un tableau",
    "section": "",
    "text": "Considérons un tableau. On souhaite disposer d’un algorithme permettant de rechercher une occurrence d’une valeur donnée dans ce tableau. Plus précisément, nous allons définir une fonction qui recherche une valeur donnée dans un tableau et qui retourne le tableau des indices des occurrences de cette valeur dans le tableau. Dans le cas où la valeur n’est pas présente dans le tableau, la fonction retournera un tableau vide.\nLa méthode est très simple. On parcourt le tableau en testant à chaque fois si la valeur courante est égale à la valeur recherchée. Si c’est le cas, on ajoute l’indice de la valeur courante dans le tableau des indices des occurrences.\n\ndef occurrences(tab, val):\n    \"\"\"Retourne un tableau contenant les indices des occurrences de val dans tab\"\"\"\n    indices = []\n    for i in range(len(tab)):\n        if tab[i] == val:\n            indices.append(i)\n    return indices\n\nExemple d’utilisation :\n\ntab = [\"DO\", \"RE\", \"MI\", \"FA\", \"SOL\", \"LA\", \"SI\", \"DO\"]\nprint(occurrences(tab, \"DO\"))\nprint(occurrences(tab, \"MI\"))\nprint(occurrences(tab, \"UT\"))\n\n[0, 7]\n[2]\n[]\n\n\nComplexité de l’algorithme : Comptons le nombre d’itérations et de tests. Notons \\(n\\) la taille du tableau, l’algorithme parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. De plus, nous avons \\(n\\) tests. Il y a donc \\(2n\\) opérations au total. On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#recherche-dun-extremum",
    "href": "algo1/parcoursTableau.html#recherche-dun-extremum",
    "title": "Parcours séquentiel d’un tableau",
    "section": "2. Recherche d’un extremum",
    "text": "2. Recherche d’un extremum\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui recherche le plus grand élément du tableau. Pour cela, on commence par choisir comme maximum temporaire le premier élément du tableau. On parcourt ensuite le tableau en testant à chaque fois si la valeur courante est plus grande que le maximum temporaire. Si c’est le cas, on met à jour le maximum temporaire avec la valeur courante.\n\ndef max(tab):\n    \"\"\"Retourne le plus grand élément du tableau\"\"\"\n    m = tab[0]\n    for i in range(1, len(tab)):\n        if tab[i] &gt; m:\n            m = tab[i]\n    return m\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(max(tab))\n\n2023\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau, sauf la première. Il y a donc au total \\(n-1\\) itérations. Nous avons aussi \\(n-1\\) comparaisons. Au total, le nombre d’opérations est donc de \\(2n-2\\). On peut donc dire que l’algorithme est de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/parcoursTableau.html#calcul-dune-moyenne",
    "href": "algo1/parcoursTableau.html#calcul-dune-moyenne",
    "title": "Parcours séquentiel d’un tableau",
    "section": "3. Calcul d’une moyenne",
    "text": "3. Calcul d’une moyenne\nDans cette partie, nous considérons un tableau dont les éléments sont des nombres. Nous allons définir une fonction qui calcule la moyenne des éléments du tableau.\n\ndef moyenne(tab):\n    \"\"\"Retourne la moyenne des éléments du tableau\"\"\"\n    s = 0\n    for i in range(len(tab)):\n        s += tab[i]\n    return s / len(tab)\n\nExemple d’utilisation :\n\ntab = [201, 203, 35, 448, 55, 16, 2023, 14, 999, 100]\nprint(moyenne(tab))\n\n409.4\n\n\nComplexité de l’algorithme : La boucle for parcourt toutes les valeurs du tableau. Il y a donc au total \\(n\\) itérations. Nous avons aussi \\(n\\) additions et une division. Au total, le nombre d’opérations est donc de \\(2n+1\\). On peut donc dire que l’algorithme est encore de complexité \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "algo1/recherche.html",
    "href": "algo1/recherche.html",
    "title": "Recherche dichotomique dans un tableau trié",
    "section": "",
    "text": "On s’intéresse ici au problème de la recherche d’une valeur dans un tableau que l’on supposera triée dans l’ordre croissant."
  },
  {
    "objectID": "algo1/recherche.html#approche-naïve",
    "href": "algo1/recherche.html#approche-naïve",
    "title": "Recherche dichotomique dans un tableau trié",
    "section": "1. Approche naïve",
    "text": "1. Approche naïve\nLa première idée qui peut venir à l’esprit est de considérer les éléments du tableau les uns après les autres et de les comparer avec l’élément recherché.\nOn peut ainsi écrire une fonction recherche_naive qui prend en paramètre un tableau tàbleau et une valeur valeur et qui renvoie l’indice de la première occurrence de valeur dans tableau ou -1 si valeur n’est pas dans tableau.\n\ndef recherche_naive(tableau, valeur):\n    for i in range(len(tableau)):\n        if tableau[i] == valeur:\n            return i\n    return -1\n\nTest de cette fonction :\n\nrecherche_naive([1, 2, 3, 4, 5], 3)\n\n2\n\n\n\nrecherche_naive([1, 2, 3, 4, 5], 6)\n\n-1\n\n\nLa complexité dans le pire des cas correspond ici au cas où la valeur recherchée n’est pas dans la liste. Il faut alors parcourir toutes les valeurs du tableau et faire \\(n\\) comparaisons, où \\(n\\) est la taille du tableau. L’algorithme naïf a donc une complexité linéaire en \\(\\mathcal{O}(n)\\).\nIl est possible d’être plus efficace en exploitant le fait que la liste est triée."
  },
  {
    "objectID": "algo1/recherche.html#recherche-dichotomique",
    "href": "algo1/recherche.html#recherche-dichotomique",
    "title": "Recherche dichotomique dans un tableau trié",
    "section": "2. Recherche dichotomique",
    "text": "2. Recherche dichotomique\n\nLe principe\nDe façon intuitive, la recherche dichotomique consiste à diviser par deux la zone de recherche à chaque étape.\nOn commence par considérer l’ensemble des éléments du tableau. On regarde ensuite la valeur de l’élément du milieu du tableau. Si cette valeur est inférieure à la valeur recherchée, alors on poursuit la recherche sur la moitié supérieure du tableau. Si la valeur est supérieure à la valeur recherchée, alors on poursuit la recherche sur la moitié inférieure. Si la valeur est égale à la valeur recherchée, on a trouvé l’élément recherché.\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\n\nOn considère le tableau tableau trié dans l’ordre croissant dans lequel on recherche la valeur valeur.\nOn définit les bornes gauche et droite du tableau : indices du premier et du dernier élément de la partie du tableau dans laquelle on recherche.\nTant que gauche est inférieur ou égal à droite :\n\nOn calcule l’indice milieu du milieu du tableau.\nSi tableau[milieu] est égal à valeur, on renvoie milieu.\nSi tableau[milieu] est inférieur à valeur, on met à jour gauche à milieu + 1. Lors de l’itération suivante, on ne considèrera donc que la partie du tableau située à droite de milieu.\nSi tableau[milieu] est supérieur à valeur, on met à jour droite à milieu - 1. Lors de l’itération suivante, on ne considèrera donc que la partie du tableau située à gauche de milieu.\n\nOn renvoie -1 si valeur n’est pas dans tableau.\n\n\n\nExemple\nOn considère le tableau [1,4,7,10,13,16,19,22,25] et on cherche la valeur 22.\nOn commence par considérer l’ensemble des éléments du tableau (gauche=0 et droite=8). On regarde ensuite la valeur de l’élément du milieu du tableau. Ici, il s’agit de l’élément d’indice 4 (milieu=4), qui vaut 13. La valeur recherchée est supérieure à 13, donc on ne considère que la partie du tableau située à droite de l’élément du milieu.\nOn répète alors l’opération sur la partie du tableau située à droite de l’élément du milieu (gauche=5 et droite=8). On obtient le tableau [16,19,22,25] et on cherche la valeur 22. L’élément du milieu de ce tableau vaut 19 (milieu=6), qui est inférieur à 22. On ne considère donc que la partie du tableau située à droite de l’élément du milieu.\nOn répète donc l’opération sur la partie du tableau située à droite (gauche=7 et droite=8). On obtient le tableau [22,25] et on cherche la valeur 22. L’élément du milieu de ce tableau vaut 22 (milieu=7), qui est égal à 22. On a donc trouvé la valeur recherchée et l’algorithme est terminé en trois étapes.\n\n\n\nRecherche dichotomique\n\n\n\n\nProgrammation\nÉcrivons une fonction recherche_dichotomique qui prend en paramètre un tableau tableau et une valeur valeur et qui renvoie l’indice d’une occurrence de valeur dans tableau ou -1 si valeur n’est pas dans tableau.\n\ndef recherche_dichotomique(tableau, valeur):\n    gauche = 0\n    droite = len(tableau) - 1\n    while gauche &lt;= droite:\n        milieu = (gauche + droite) // 2\n        if tableau[milieu] == valeur:\n            return milieu\n        elif tableau[milieu] &lt; valeur:\n            gauche = milieu + 1\n        else:\n            droite = milieu - 1\n    return -1\n\nTest de cette fonction :\n\nrecherche_dichotomique([1, 2, 3, 4, 5], 2)\n\n1\n\n\n\nrecherche_dichotomique([1, 2, 3, 4, 5], 6)\n\n-1\n\n\n\n\nPreuve de terminaison\nPour prouver que l’algorithme se termine, il faut prouver que la boucle while se termine, et donc que la condition d’arrêt gauche &gt; droite finit par être vérifiée ou bien que la condition tableau[milieu] == valeur est vérifiée.\nChoisissons comme variant de boucle la différence droite - gauche et plaçons-nous dans le cas le plus défavorable où la condition tableau[milieu] == valeur n’est jamais vérifiée. À chaque passage dans la boucle, soit gauche est incrémenté de 1, soit droite est décrémenté de 1. La différence droite - gauche est donc toujours diminuée de 1. Au bout d’un nombre fini d’itérations (au maximum égal à la taille du tableau moins un), la condition notre variant de boucle devient donc égal à zéro et la boucle se termine.\nLa terminaison de l’algorithme est donc prouvée.\n\n\nPreuve de correction\nConsidérons la propriété suivante : à chaque étape de l’algorithme, la valeur recherchée est située dans la partie du tableau située entre les indices gauche et droite inclus, ou bien elle n’est pas dans le tableau.\nMontrons que cette propriété est un invariant de boucle. C’est-à-dire que cette propriété est vraie avant l’exécution de la première itération de la boucle et qu’elle est vraie après l’exécution de chaque itération de la boucle.\nInitialisation : avant l’exécution de la première itération de la boucle, si la valeur est dans le tableau, alors elle est située dans la partie du tableau située entre les indices gauche et droite inclus. En effet, gauche vaut 0 et droite vaut la taille du tableau moins un, donc la valeur recherchée est située dans la partie du tableau située entre les indices 0 et la taille du tableau moins un inclus (c’est le tableau entier !).\nConservation : supposons que la propriété est vraie à l’entrée dans une itération de la boucle while. Il y a trois possibilités :\n\ntableau[milieu] == valeur est vérifiée. Dans ce cas, la propriété est vraie à la sortie de l’itération de la boucle et l’algorithme retourne l’indice attendu.\ntableau[milieu] &lt; valeur est vérifiée. Dans ce cas, gauche est incrémenté de 1. La valeur recherchée est donc située dans la partie du tableau située entre les indices gauche et droite inclus, ou bien elle est absente du tableau.\ntableau[milieu] &gt; valeur est vérifiée. Dans ce cas, droite est décrémenté de 1. La valeur recherchée est donc située dans la partie du tableau située entre les indices gauche et droite inclus, ou bien elle est absente du tableau.\n\nConclusion : la propriété est donc un invariant de boucle.\nDeux cas sont à considérer pour conclure. Si le test tableau[milieu] == valeur est vérifié au cours des itérations, alors la valeur est trouvée dans le tableau et on retourne son indice milieu : c’est bien le comportement attendu. Si le test tableau[milieu] == valeur n’est jamais vérifié, alors l’algorithme se termine lorsque gauche &gt; droite. D’après notre invariant de boucle, soit la valeur est alors absente du tableau, soit elle est située dans la partie du tableau située entre les indices gauche et droite inclus. Mais cette partie du tableau est un tableau vide []. La valeur est donc absente du tableau et on retourne l’indice -1 : c’est bien le comportement attendu.\nL’algorithme est donc correct.\n\n\nComplexité\nPour évaluer la complexité de cet algorithme, nous allons évaluer le nombre d’itérations nécessaires en fonction de la taille \\(n\\) du tableau, dans le pire des cas, c’est-à-dire lorsque la valeur recherchée n’est pas dans le tableau.\nÀ chaque étape, la taille du sous-tableau contenant potentiellement la valeur recherchée est divisée par deux. Au bout de \\(k\\) étapes, la taille du sous-tableau est donc de \\(\\frac{n}{2^k}\\) environ. Si la valeur recherchée n’est pas dans le tableau, alors on finit par arriver à un tableau de taille 1 et la boucle se termine au tour suivant. Soit \\(k\\) le nombre d’itérations nécessaires pour que la taille du sous-tableau soit de 1. On a donc \\(\\frac{n}{2^k}\\approx 1\\), et par conséquent \\(n=2^k\\). On en déduit que \\(k=\\log_2 n\\).\nL’algorithme de recherche dichotomique est donc en \\(\\mathcal{O}(\\log n)\\). On parle de complexité logarithmique. Cette complexité est meilleure que la complexité linéaire.\n\n\n\n\n\n\nNotion de logarithme de base 2\n\n\n\nSi \\(x\\) est une puissance de 2, alors \\(\\log_2 x\\) est égal à l’exposant de cette puissance. Par exemple, \\(\\log_2 8 = 3\\) car \\(8 = 2^3\\).\n\n\nPour un tableau de départ de taille \\(16=2^4\\) dans lequel on cherche une valeur qui n’y est pas, on effectue 4 itérations :\n\nau premier tour, on divise le tableau en deux parties de taille \\(8=2^3\\) et on cherche dans la partie de gauche (par exemple) ;\nau deuxième tour, on divise la partie de gauche en deux parties de taille \\(4=2^2\\) et on cherche dans la partie de gauche (par exemple) ;\nau troisième tour, on divise la partie de gauche en deux parties de taille \\(2=2^1\\) et on cherche dans la partie de gauche (par exemple) ;\nau quatrième tour, on divise la partie de gauche en deux parties de taille \\(1=2^0\\) et on cherche dans la partie de gauche (par exemple).\n\nOn retrouve bien un nombre d’itérations de l’ordre de \\(\\log_2 n\\).\n\n\nComparaison expérimentale des deux algorithmes\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps_naive = []\ntemps_dicho = []\n# on applique la recherche dans le pire des cas : valeur absente su tableau\nvaleur = 1000\nfor n in tailles:\n    temps_naive.append(timeit.timeit(\n        \"recherche_naive([k for k in range(n)], valeur)\",\n        globals=globals(),\n        number=100\n    ))\n    temps_dicho.append(timeit.timeit(\n        \"recherche_dichotomique([k for k in range(n)], valeur)\",\n        globals=globals(),\n        number=100\n    ))\nplt.plot(tailles,temps_naive, 'b', label=\"Recherche naïve\")\nplt.plot(tailles,temps_dicho, 'r', label=\"Recherche dichotomique\")\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "algo1/tris.html",
    "href": "algo1/tris.html",
    "title": "Algorithmes de tris",
    "section": "",
    "text": "Dans cette partie du cours, nous allons étudier deux algorithmes de tris : le tri par insertion et le tri par sélection.\nÉtant donné un tableau de nombres, l’objectif est d’écrire une fonction qui renvoie un tableau contenant les mêmes nombres mais dans l’ordre croissant."
  },
  {
    "objectID": "algo1/tris.html#tri-par-insertion",
    "href": "algo1/tris.html#tri-par-insertion",
    "title": "Algorithmes de tris",
    "section": "1. Tri par insertion",
    "text": "1. Tri par insertion\n\nLe principe\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\nEn commençant par le deuxième élément du tableau :\n\nOn compare l’élément courant avec l’élément précédent.\nSi l’élément courant est plus petit, on échange les deux éléments.\nOn continue à comparer et échanger l’élément courant avec les éléments précédents jusqu’à ce que l’élément courant soit plus grand que l’élément précédent.\n\n\n\n\n\n\n\n\nExemple : Soit à trier le tableau \\([5,2,7,3]\\).\n\nOn commence par le deuxième élément du tableau, c’est-à-dire l’élément 2. On compare l’élément 2 avec l’élément 5. L’élément 2 est plus petit que l’élément 5, on échange les deux éléments. Le tableau est donc \\([2,5,7,3]\\).\nOn continue avec l’élément 7. L’élément 7 est plus grand que l’élément 5, on ne fait rien.\nOn continue avec l’élément 3. L’élément 3 est plus petit que l’élément 7, on échange les deux éléments. Le tableau est donc \\([2,5,3,7]\\). On continue à comparer et échanger l’élément 3 avec les éléments précédents jusqu’à ce que l’élément 3 soit plus grand que l’élément 5. Le tableau est donc \\([2,3,5,7]\\). L’algorithme est terminé. Le tableau est trié.\n\n\n\nProgrammation\n\ndef tri_insertion(tableau: list) -&gt; list:\n    \"\"\"Tri en place par insertion le tableau passé en paramètre.\"\"\"\n1    for i in range(1, len(tableau)):\n2        j = i\n3        while j &gt; 0 and tableau[j] &lt; tableau[j-1]:\n4            tableau[j], tableau[j-1] = tableau[j-1], tableau[j]\n5            j -= 1\n    return tableau\n\n\n1\n\nOn commence à l’indice 1 qui correspond au deuxième élément du tableau.\n\n2\n\nOn stocke l’indice courant dans une variable j pour pouvoir le modifier.\n\n3\n\nTant que l’indice courant est supérieur à 0 et que l’élément courant est plus petit que l’élément précédent, on échange les deux éléments.\n\n4\n\nOn échange les deux éléments.\n\n5\n\nL’élément courant est maintenant l’élément précédent, on décrémente donc l’indice courant.\n\n\n\n\nTest de l’algorithme :\n\ntri_insertion([5, 2, 4, 6, 1, 3])\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nPreuve de terminaison\nMontrons que l’algorithme se termine.\nD’une part, il est certain que la boucle for, boucle bornée par nature, se termine. D’autre part, la boucle while se termine aussi. La variable j est un variant de boucle. À chaque itération, sa valeur diminue de 1 : elle finit donc toujours par atteindre 0.\nLa terminaison de l’algorithme est donc prouvée.\n\n\nPreuve de correction\nMontrons que l’algorithme trie bien le tableau.\nPour cela, considérons la propriété suivante : à chaque itération, le sous-tableau composé des i premiers éléments est trié. Montrons que cette propriété est un invariant de boucle.\n\nInitialisation : au début de l’algorithme, le sous-tableau composé uniquement du premier élément est trié.\nConservation : supposons que le le sous-tableau composé des i premiers éléments est trié : \\([e_0, e_1, \\ldots, e_{i-1}]\\) avec \\(e_0\\leqslant e_1\\leqslant \\ldots \\leqslant e_{i-1}\\). L’algorithme considère alors l’élément \\(e_i\\) et le compare avec les éléments précédents. Si \\(e_i\\) est plus petit que \\(e_{i-1}\\), on échange les deux éléments. On continue alors à comparer \\(e_i\\) avec les éléments précédents jusqu’à ce que \\(e_i\\) soit plus grand que l’élément précédent. Le sous-tableau composé des i+1 premiers éléments est alors trié.\nConclusion : à la fin de l’algorithme i a la valeur n-1 ce qui correspond à l’indice du dernier élément du tableau. Le sous-tableau composé des n premiers éléments est donc trié. Or, n est le nombre d’éléments du tableau, donc le tableau entier est trié.\n\nLa correction de l’algorithme est donc prouvée.\n\n\nComplexité\nOn recherche la complexité dans le pire des cas. Le pire des cas est le cas où le tableau de départ est rangé dans l’ordre décroissant.\nNotons \\(n\\) la taille du tableau de départ.\nLa boucle for comporte \\(n-1\\) itérations.\nDans le cas où le tableau de départ est rangé dans l’ordre décroissant, la boucle while comporte 1 opération, puis 2, puis 3, etc. jusqu’à \\(n-1\\) opérations pour la dernière itération. On obtient donc la somme suivante pour le nombre total d’opérations :\n\\[1+2+3+\\ldots+(n-1)=\\frac{n(n-1)}{2}\\]\nSachant que \\(\\frac{n(n-1)}{2} = \\frac{n^2-n}{2}\\), il s’agit donc d’une complexité quadratique, en \\(\\mathcal{O}(n^2)\\)."
  },
  {
    "objectID": "algo1/tris.html#tri-par-sélection",
    "href": "algo1/tris.html#tri-par-sélection",
    "title": "Algorithmes de tris",
    "section": "2. Tri par sélection",
    "text": "2. Tri par sélection\n\n\n\n\n\n\nLe principe\n\n\n\n\n\n\nPrincipe de l’algorithme\n\n\n\nEn commençant par le premier élément du tableau :\n\nOn recherche le plus petit élément parmi les éléments suivants du tableau.\nOn échange l’élément courant avec le plus petit élément.\n\n\n\nExemple : Soit à trier le tableau \\([5,2,3,7]\\).\n\nOn commence par le premier élément, 5. On recherche le plus petit élément parmi les éléments suivants du tableau, c’est-à-dire 2. On échange 5 et 2 : le tableau est maintenant \\([2,5,3,7]\\).\nL’élément courant est maintenant le deuxième du tableau, c’est donc encore 5. On recherche le plus petit élément parmi les éléments suivants du tableau, c’est-à-dire 3. On échange 5 et 3 : le tableau est maintenant \\([2,3,5,7]\\).\nL’élément courant est maintenant le troisième du tableau, c’est donc encore 5. On recherche le plus petit élément parmi les éléments suivants du tableau, mais aucun n’est plus petit que 5. On ne fait donc rien.\nL’élément courant est maintenant le dernier du tableau, c’est donc 7. On ne fait donc rien et le tableau est trié.\n\n\n\nProgrammation\n\ndef tri_selection(tableau: list) -&gt; list:\n    \"\"\"Trie en place par sélection le tableau passé en paramètre.\"\"\"\n1    for i in range(len(tableau)):\n2        min = i\n3        for j in range(i+1, len(tableau)):\n4            if tableau[j] &lt; tableau[min]:\n                min = j\n5        tableau[i], tableau[min] = tableau[min], tableau[i]\n    return tableau\n\n\n1\n\nOn commence à l’indice 0 qui correspond au premier élément du tableau.\n\n2\n\nOn stocke l’indice courant dans une variable min pour pouvoir le modifier.\n\n3\n\nOn parcourt le tableau à partir de l’indice i+1 jusqu’à la fin.\n\n4\n\nSi l’élément courant est plus petit que l’élément stocké dans min, on met à jour min.\n\n5\n\nOn échange les deux éléments.\n\n\n\n\nTest de l’algorithme :\n\ntri_selection([5, 2, 4, 6, 1, 3])\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\nPreuve de terminaison\nL’algorithme se termine puisqu’il comporte deux boucles for qui sont toutes deux bornées par nature.\n\n\nPreuve de correction\nMontrons que l’algorithme trie bien le tableau.\nPour cela, considérons la propriété suivante : à chaque itération, le sous-tableau composé des i premiers éléments est trié. Montrons que cette propriété est un invariant de boucle.\n\nInitialisation : au début de l’algorithme, le sous-tableau composé uniquement du premier élément est trié.\nConservation : supposons que le le sous-tableau composé des i premiers éléments est trié : \\([e_0, e_1, \\ldots, e_{i-1}]\\) avec \\(e_0\\leqslant e_1\\leqslant \\ldots \\leqslant e_{i-1}\\). Par construction, tous les éléments suivants sont supérieurs à \\(e_{i-1}\\). L’algorithme considère alors l’élément \\(e_i\\) et le compare avec les éléments suivants. Si un élément est plus petit que \\(e_i\\), on échange les deux éléments. Le sous-tableau composé des i+1 premiers éléments est alors trié.\nConslusion : à la fin de l’algorithme i a la valeur n-1 ce qui correspond à l’indice du dernier élément du tableau. Le sous-tableau composé des n premiers éléments est donc trié. Or, n est le nombre d’éléments du tableau, donc le tableau entier est trié.\n\nLa correction de l’algorithme est donc prouvée.\n\n\nComplexité\nOn recherche la complexité dans le pire des cas. Le pire des cas est le cas où le tableau de départ est rangé dans l’ordre décroissant.\nNotons \\(n\\) la taille du tableau de départ.\nLa boucle for i comporte \\(n-1\\) itérations. La boucle for j comporte \\(n-1\\) itérations pour la première itération, puis \\(n-2\\) itérations pour la seconde itération, etc. jusqu’à 1 opération pour la dernière itération. On obtient donc la somme suivante pour le nombre total d’opérations :\n\\[n-1+(n-2)+(n-3)+\\ldots+1=\\frac{n(n-1)}{2}\\]\nSachant que \\(\\frac{n(n-1)}{2} = \\frac{n^2-n}{2}\\), il s’agit donc d’une complexité quadratique, en \\(\\mathcal{O}(n^2)\\)."
  },
  {
    "objectID": "algo1/tris.html#observation-expérimentale-de-la-complexité",
    "href": "algo1/tris.html#observation-expérimentale-de-la-complexité",
    "title": "Algorithmes de tris",
    "section": "3. Observation expérimentale de la complexité",
    "text": "3. Observation expérimentale de la complexité\n\nTri par insertion\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps = []\n# on applique le tri dans le pire des cas : tableau trié dans l'ordre décroissant\nfor n in tailles:\n    temps.append(timeit.timeit(\n        \"tri_insertion([n-k for k in range(n)])\",\n        globals=globals(),\n        number=1\n    ))\nplt.plot(tailles, temps)\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nTri par sélection\n\nimport timeit\nimport matplotlib.pyplot as plt\n\ntailles = [i for i in range(1, 500)]\ntemps = []\n# on applique le tri dans le pire des cas : tableau trié dans l'ordre décroissant\nfor n in tailles:\n    temps.append(timeit.timeit(\n        \"tri_selection([n-k for k in range(n)])\",\n        globals=globals(),\n        number=1\n    ))\nplt.plot(tailles, temps)\nplt.xlabel(\"Taille du tableau\")\nplt.ylabel(\"Temps d'exécution (en secondes)\")\nplt.show()\n\n\n\n\n\n\n\n\nDans les deux cas, la forme grossièrement parabolique de la courbe est caractéristique de la complexité quadratique."
  },
  {
    "objectID": "algo1/tris.html#compléments",
    "href": "algo1/tris.html#compléments",
    "title": "Algorithmes de tris",
    "section": "Compléments",
    "text": "Compléments\nSur le site interstices.info un article très complet sur les algorithmes de tri, avec des animations pour mieux comprendre."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spécialité NSI - Première",
    "section": "",
    "text": "Bienvenue !\nCe site est destiné à regrouper les cours et les exercices concernant l’enseignement de spécialité NSI de première du lycée Émile Duclaux d’Aurillac.\nLien vers l’ENT du lycée : https://cas.ent.auvergnerhonealpes.fr/login"
  },
  {
    "objectID": "ressources.html",
    "href": "ressources.html",
    "title": "Sources utilisées",
    "section": "",
    "text": "Pour rédiger ce cours et préparer les exercices, TP, projets présentés ici, j’ai utilisé de nombreuses sources que je vais essayer de citer ici, sans prétendre être exhaustif.\n\nDocuments d’accompagnement Eduscol.\nContenus du MOOC “Numérique et Sciences Informatiques : les fondamentaux” de l’INRIA, disponible sur la plateforme fun-mooc.\nApprendre à programmer avec Python 3, Gérard Swinnen, éditions Eyrolles, 2012. Disponible en ligne\nLe site interstices : https://interstices.info/.\nLes images et illustrations sont soit produites par mes soins, soit issues de Pixabay ou de Wikimedia commons ou encore de Pexels et, dans tous les cas, libres de droits.\nCours de David Roche.\nCours de Frédéric Junier.\nCours de Van Zuijlen Stéphan.\nCours de Konieczko Quentin\nCours de Olivier Lécluse\nCours du Lycée Blaise Pascal de Clermont-Ferrand\nCours du lycée Champollion de Grenoble\nCours du site Lyceum\nCours du site Mon Lycée Numérique\nCours du Lycée Stanislas de Wissembourg\nCours d’informatique de François Brucker (école Centrale de Marseille)\nCours de Philippe Rigaux sur les bases de données.\nCours de Gilles Lassus\nLe site MDN Web Docs : excellentissime ressource pour tout apprendre sur les langages HTML, CSS, Javascript et le protocole HTTP.\nLe site de M. JANVIER."
  }
]